// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssd-git.juniper.net/contrail/cn2/contrail/pkg/apis/core/v1alpha1/generated.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "k8s.io/api/core/v1/generated.pb.h"
#include "k8s.io/apimachinery/pkg/apis/meta/v1/generated.pb.h"
#include "k8s.io/apimachinery/pkg/runtime/generated.pb.h"
#include "k8s.io/apimachinery/pkg/runtime/schema/generated.pb.h"
#include "k8s.io/apimachinery/pkg/util/intstr/generated.pb.h"
#include "ssd-git.juniper.net/contrail/cn2/third_party/apiserver-builder-alpha/pkg/builders/generated.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[132]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
namespace ssd_git {
namespace juniper {
namespace net {
namespace contrail {
namespace cn2 {
namespace contrail {
namespace pkg {
namespace apis {
namespace core {
namespace v1alpha1 {
class APSAttribute;
struct APSAttributeDefaultTypeInternal;
extern APSAttributeDefaultTypeInternal _APSAttribute_default_instance_;
class AddressFamilies;
struct AddressFamiliesDefaultTypeInternal;
extern AddressFamiliesDefaultTypeInternal _AddressFamilies_default_instance_;
class AddressGroup;
struct AddressGroupDefaultTypeInternal;
extern AddressGroupDefaultTypeInternal _AddressGroup_default_instance_;
class AddressGroupList;
struct AddressGroupListDefaultTypeInternal;
extern AddressGroupListDefaultTypeInternal _AddressGroupList_default_instance_;
class AddressGroupPrefix;
struct AddressGroupPrefixDefaultTypeInternal;
extern AddressGroupPrefixDefaultTypeInternal _AddressGroupPrefix_default_instance_;
class AddressGroupSpec;
struct AddressGroupSpecDefaultTypeInternal;
extern AddressGroupSpecDefaultTypeInternal _AddressGroupSpec_default_instance_;
class AddressGroupStatus;
struct AddressGroupStatusDefaultTypeInternal;
extern AddressGroupStatusDefaultTypeInternal _AddressGroupStatus_default_instance_;
class AllowedAddressPair;
struct AllowedAddressPairDefaultTypeInternal;
extern AllowedAddressPairDefaultTypeInternal _AllowedAddressPair_default_instance_;
class AllowedAddressPairSubnet;
struct AllowedAddressPairSubnetDefaultTypeInternal;
extern AllowedAddressPairSubnetDefaultTypeInternal _AllowedAddressPairSubnet_default_instance_;
class AllowedAddressPairs;
struct AllowedAddressPairsDefaultTypeInternal;
extern AllowedAddressPairsDefaultTypeInternal _AllowedAddressPairs_default_instance_;
class ApplicationPolicySet;
struct ApplicationPolicySetDefaultTypeInternal;
extern ApplicationPolicySetDefaultTypeInternal _ApplicationPolicySet_default_instance_;
class ApplicationPolicySetList;
struct ApplicationPolicySetListDefaultTypeInternal;
extern ApplicationPolicySetListDefaultTypeInternal _ApplicationPolicySetList_default_instance_;
class ApplicationPolicySetSpec;
struct ApplicationPolicySetSpecDefaultTypeInternal;
extern ApplicationPolicySetSpecDefaultTypeInternal _ApplicationPolicySetSpec_default_instance_;
class ApplicationPolicySetStatus;
struct ApplicationPolicySetStatusDefaultTypeInternal;
extern ApplicationPolicySetStatusDefaultTypeInternal _ApplicationPolicySetStatus_default_instance_;
class AuthenticationData;
struct AuthenticationDataDefaultTypeInternal;
extern AuthenticationDataDefaultTypeInternal _AuthenticationData_default_instance_;
class AuthenticationKeyItem;
struct AuthenticationKeyItemDefaultTypeInternal;
extern AuthenticationKeyItemDefaultTypeInternal _AuthenticationKeyItem_default_instance_;
class BGPAsAService;
struct BGPAsAServiceDefaultTypeInternal;
extern BGPAsAServiceDefaultTypeInternal _BGPAsAService_default_instance_;
class BGPAsAServiceList;
struct BGPAsAServiceListDefaultTypeInternal;
extern BGPAsAServiceListDefaultTypeInternal _BGPAsAServiceList_default_instance_;
class BGPAsAServiceSpec;
struct BGPAsAServiceSpecDefaultTypeInternal;
extern BGPAsAServiceSpecDefaultTypeInternal _BGPAsAServiceSpec_default_instance_;
class BGPAsAServiceStatus;
struct BGPAsAServiceStatusDefaultTypeInternal;
extern BGPAsAServiceStatusDefaultTypeInternal _BGPAsAServiceStatus_default_instance_;
class BGPFamilyAttributes;
struct BGPFamilyAttributesDefaultTypeInternal;
extern BGPFamilyAttributesDefaultTypeInternal _BGPFamilyAttributes_default_instance_;
class BGPPrefixLimit;
struct BGPPrefixLimitDefaultTypeInternal;
extern BGPPrefixLimitDefaultTypeInternal _BGPPrefixLimit_default_instance_;
class BGPRouter;
struct BGPRouterDefaultTypeInternal;
extern BGPRouterDefaultTypeInternal _BGPRouter_default_instance_;
class BGPRouterList;
struct BGPRouterListDefaultTypeInternal;
extern BGPRouterListDefaultTypeInternal _BGPRouterList_default_instance_;
class BGPRouterParameters;
struct BGPRouterParametersDefaultTypeInternal;
extern BGPRouterParametersDefaultTypeInternal _BGPRouterParameters_default_instance_;
class BGPRouterReference;
struct BGPRouterReferenceDefaultTypeInternal;
extern BGPRouterReferenceDefaultTypeInternal _BGPRouterReference_default_instance_;
class BGPRouterReferenceAttributes;
struct BGPRouterReferenceAttributesDefaultTypeInternal;
extern BGPRouterReferenceAttributesDefaultTypeInternal _BGPRouterReferenceAttributes_default_instance_;
class BGPRouterSpec;
struct BGPRouterSpecDefaultTypeInternal;
extern BGPRouterSpecDefaultTypeInternal _BGPRouterSpec_default_instance_;
class BGPRouterStatus;
struct BGPRouterStatusDefaultTypeInternal;
extern BGPRouterStatusDefaultTypeInternal _BGPRouterStatus_default_instance_;
class BGPSession;
struct BGPSessionDefaultTypeInternal;
extern BGPSessionDefaultTypeInternal _BGPSession_default_instance_;
class BGPSessionAttributes;
struct BGPSessionAttributesDefaultTypeInternal;
extern BGPSessionAttributesDefaultTypeInternal _BGPSessionAttributes_default_instance_;
class BGPSessionIPAttributes;
struct BGPSessionIPAttributesDefaultTypeInternal;
extern BGPSessionIPAttributesDefaultTypeInternal _BGPSessionIPAttributes_default_instance_;
class CommonSpec;
struct CommonSpecDefaultTypeInternal;
extern CommonSpecDefaultTypeInternal _CommonSpec_default_instance_;
class CommonStatus;
struct CommonStatusDefaultTypeInternal;
extern CommonStatusDefaultTypeInternal _CommonStatus_default_instance_;
class ContrailFqName;
struct ContrailFqNameDefaultTypeInternal;
extern ContrailFqNameDefaultTypeInternal _ContrailFqName_default_instance_;
class EncapsulationPriorities;
struct EncapsulationPrioritiesDefaultTypeInternal;
extern EncapsulationPrioritiesDefaultTypeInternal _EncapsulationPriorities_default_instance_;
class FirewallActionListType;
struct FirewallActionListTypeDefaultTypeInternal;
extern FirewallActionListTypeDefaultTypeInternal _FirewallActionListType_default_instance_;
class FirewallPolicy;
struct FirewallPolicyDefaultTypeInternal;
extern FirewallPolicyDefaultTypeInternal _FirewallPolicy_default_instance_;
class FirewallPolicyAttribute;
struct FirewallPolicyAttributeDefaultTypeInternal;
extern FirewallPolicyAttributeDefaultTypeInternal _FirewallPolicyAttribute_default_instance_;
class FirewallPolicyList;
struct FirewallPolicyListDefaultTypeInternal;
extern FirewallPolicyListDefaultTypeInternal _FirewallPolicyList_default_instance_;
class FirewallPolicyReference;
struct FirewallPolicyReferenceDefaultTypeInternal;
extern FirewallPolicyReferenceDefaultTypeInternal _FirewallPolicyReference_default_instance_;
class FirewallPolicySpec;
struct FirewallPolicySpecDefaultTypeInternal;
extern FirewallPolicySpecDefaultTypeInternal _FirewallPolicySpec_default_instance_;
class FirewallPolicyStatus;
struct FirewallPolicyStatusDefaultTypeInternal;
extern FirewallPolicyStatusDefaultTypeInternal _FirewallPolicyStatus_default_instance_;
class FirewallRule;
struct FirewallRuleDefaultTypeInternal;
extern FirewallRuleDefaultTypeInternal _FirewallRule_default_instance_;
class FirewallRuleEndpointType;
struct FirewallRuleEndpointTypeDefaultTypeInternal;
extern FirewallRuleEndpointTypeDefaultTypeInternal _FirewallRuleEndpointType_default_instance_;
class FirewallRuleList;
struct FirewallRuleListDefaultTypeInternal;
extern FirewallRuleListDefaultTypeInternal _FirewallRuleList_default_instance_;
class FirewallRuleReference;
struct FirewallRuleReferenceDefaultTypeInternal;
extern FirewallRuleReferenceDefaultTypeInternal _FirewallRuleReference_default_instance_;
class FirewallRuleSpec;
struct FirewallRuleSpecDefaultTypeInternal;
extern FirewallRuleSpecDefaultTypeInternal _FirewallRuleSpec_default_instance_;
class FirewallRuleStatus;
struct FirewallRuleStatusDefaultTypeInternal;
extern FirewallRuleStatusDefaultTypeInternal _FirewallRuleStatus_default_instance_;
class FirewallServiceType;
struct FirewallServiceTypeDefaultTypeInternal;
extern FirewallServiceTypeDefaultTypeInternal _FirewallServiceType_default_instance_;
class FirewallSubnet;
struct FirewallSubnetDefaultTypeInternal;
extern FirewallSubnetDefaultTypeInternal _FirewallSubnet_default_instance_;
class FloatingIP;
struct FloatingIPDefaultTypeInternal;
extern FloatingIPDefaultTypeInternal _FloatingIP_default_instance_;
class FloatingIPList;
struct FloatingIPListDefaultTypeInternal;
extern FloatingIPListDefaultTypeInternal _FloatingIPList_default_instance_;
class FloatingIPPortMappings;
struct FloatingIPPortMappingsDefaultTypeInternal;
extern FloatingIPPortMappingsDefaultTypeInternal _FloatingIPPortMappings_default_instance_;
class FloatingIPPortPortMapping;
struct FloatingIPPortPortMappingDefaultTypeInternal;
extern FloatingIPPortPortMappingDefaultTypeInternal _FloatingIPPortPortMapping_default_instance_;
class FloatingIPSpec;
struct FloatingIPSpecDefaultTypeInternal;
extern FloatingIPSpecDefaultTypeInternal _FloatingIPSpec_default_instance_;
class FloatingIPStatus;
struct FloatingIPStatusDefaultTypeInternal;
extern FloatingIPStatusDefaultTypeInternal _FloatingIPStatus_default_instance_;
class GlobalSystemConfig;
struct GlobalSystemConfigDefaultTypeInternal;
extern GlobalSystemConfigDefaultTypeInternal _GlobalSystemConfig_default_instance_;
class GlobalSystemConfigList;
struct GlobalSystemConfigListDefaultTypeInternal;
extern GlobalSystemConfigListDefaultTypeInternal _GlobalSystemConfigList_default_instance_;
class GlobalSystemConfigSpec;
struct GlobalSystemConfigSpecDefaultTypeInternal;
extern GlobalSystemConfigSpecDefaultTypeInternal _GlobalSystemConfigSpec_default_instance_;
class GlobalSystemConfigStatus;
struct GlobalSystemConfigStatusDefaultTypeInternal;
extern GlobalSystemConfigStatusDefaultTypeInternal _GlobalSystemConfigStatus_default_instance_;
class GlobalVrouterConfig;
struct GlobalVrouterConfigDefaultTypeInternal;
extern GlobalVrouterConfigDefaultTypeInternal _GlobalVrouterConfig_default_instance_;
class GlobalVrouterConfigList;
struct GlobalVrouterConfigListDefaultTypeInternal;
extern GlobalVrouterConfigListDefaultTypeInternal _GlobalVrouterConfigList_default_instance_;
class GlobalVrouterConfigSpec;
struct GlobalVrouterConfigSpecDefaultTypeInternal;
extern GlobalVrouterConfigSpecDefaultTypeInternal _GlobalVrouterConfigSpec_default_instance_;
class GlobalVrouterConfigStatus;
struct GlobalVrouterConfigStatusDefaultTypeInternal;
extern GlobalVrouterConfigStatusDefaultTypeInternal _GlobalVrouterConfigStatus_default_instance_;
class IPRange;
struct IPRangeDefaultTypeInternal;
extern IPRangeDefaultTypeInternal _IPRange_default_instance_;
class ImportVirtualNetworkRouter;
struct ImportVirtualNetworkRouterDefaultTypeInternal;
extern ImportVirtualNetworkRouterDefaultTypeInternal _ImportVirtualNetworkRouter_default_instance_;
class InstanceIP;
struct InstanceIPDefaultTypeInternal;
extern InstanceIPDefaultTypeInternal _InstanceIP_default_instance_;
class InstanceIPList;
struct InstanceIPListDefaultTypeInternal;
extern InstanceIPListDefaultTypeInternal _InstanceIPList_default_instance_;
class InstanceIPSpec;
struct InstanceIPSpecDefaultTypeInternal;
extern InstanceIPSpecDefaultTypeInternal _InstanceIPSpec_default_instance_;
class InstanceIPStatus;
struct InstanceIPStatusDefaultTypeInternal;
extern InstanceIPStatusDefaultTypeInternal _InstanceIPStatus_default_instance_;
class LinklocalServiceEntryType;
struct LinklocalServiceEntryTypeDefaultTypeInternal;
extern LinklocalServiceEntryTypeDefaultTypeInternal _LinklocalServiceEntryType_default_instance_;
class LinklocalServices;
struct LinklocalServicesDefaultTypeInternal;
extern LinklocalServicesDefaultTypeInternal _LinklocalServices_default_instance_;
class MACAddresses;
struct MACAddressesDefaultTypeInternal;
extern MACAddressesDefaultTypeInternal _MACAddresses_default_instance_;
class PolicyBasedForwardingRule;
struct PolicyBasedForwardingRuleDefaultTypeInternal;
extern PolicyBasedForwardingRuleDefaultTypeInternal _PolicyBasedForwardingRule_default_instance_;
class PortRange;
struct PortRangeDefaultTypeInternal;
extern PortRangeDefaultTypeInternal _PortRange_default_instance_;
class PortTranslationPool;
struct PortTranslationPoolDefaultTypeInternal;
extern PortTranslationPoolDefaultTypeInternal _PortTranslationPool_default_instance_;
class PortTranslationPools;
struct PortTranslationPoolsDefaultTypeInternal;
extern PortTranslationPoolsDefaultTypeInternal _PortTranslationPools_default_instance_;
class PortType;
struct PortTypeDefaultTypeInternal;
extern PortTypeDefaultTypeInternal _PortType_default_instance_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class ReconcilerState;
struct ReconcilerStateDefaultTypeInternal;
extern ReconcilerStateDefaultTypeInternal _ReconcilerState_default_instance_;
class ResourceReference;
struct ResourceReferenceDefaultTypeInternal;
extern ResourceReferenceDefaultTypeInternal _ResourceReference_default_instance_;
class RouteOriginOverride;
struct RouteOriginOverrideDefaultTypeInternal;
extern RouteOriginOverrideDefaultTypeInternal _RouteOriginOverride_default_instance_;
class RouteTarget;
struct RouteTargetDefaultTypeInternal;
extern RouteTargetDefaultTypeInternal _RouteTarget_default_instance_;
class RouteTargetList;
struct RouteTargetListDefaultTypeInternal;
extern RouteTargetListDefaultTypeInternal _RouteTargetList_default_instance_;
class RouteTargetReference;
struct RouteTargetReferenceDefaultTypeInternal;
extern RouteTargetReferenceDefaultTypeInternal _RouteTargetReference_default_instance_;
class RouteTargetReferenceAttributes;
struct RouteTargetReferenceAttributesDefaultTypeInternal;
extern RouteTargetReferenceAttributesDefaultTypeInternal _RouteTargetReferenceAttributes_default_instance_;
class RouteTargetSpec;
struct RouteTargetSpecDefaultTypeInternal;
extern RouteTargetSpecDefaultTypeInternal _RouteTargetSpec_default_instance_;
class RouteTargetStatus;
struct RouteTargetStatusDefaultTypeInternal;
extern RouteTargetStatusDefaultTypeInternal _RouteTargetStatus_default_instance_;
class RoutingInstance;
struct RoutingInstanceDefaultTypeInternal;
extern RoutingInstanceDefaultTypeInternal _RoutingInstance_default_instance_;
class RoutingInstanceList;
struct RoutingInstanceListDefaultTypeInternal;
extern RoutingInstanceListDefaultTypeInternal _RoutingInstanceList_default_instance_;
class RoutingInstanceReference;
struct RoutingInstanceReferenceDefaultTypeInternal;
extern RoutingInstanceReferenceDefaultTypeInternal _RoutingInstanceReference_default_instance_;
class RoutingInstanceSpec;
struct RoutingInstanceSpecDefaultTypeInternal;
extern RoutingInstanceSpecDefaultTypeInternal _RoutingInstanceSpec_default_instance_;
class RoutingInstanceStatus;
struct RoutingInstanceStatusDefaultTypeInternal;
extern RoutingInstanceStatusDefaultTypeInternal _RoutingInstanceStatus_default_instance_;
class RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse;
struct RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUseDefaultTypeInternal;
extern RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUseDefaultTypeInternal _RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse_default_instance_;
class Subnet;
struct SubnetDefaultTypeInternal;
extern SubnetDefaultTypeInternal _Subnet_default_instance_;
class SubnetList;
struct SubnetListDefaultTypeInternal;
extern SubnetListDefaultTypeInternal _SubnetList_default_instance_;
class SubnetReference;
struct SubnetReferenceDefaultTypeInternal;
extern SubnetReferenceDefaultTypeInternal _SubnetReference_default_instance_;
class SubnetSpec;
struct SubnetSpecDefaultTypeInternal;
extern SubnetSpecDefaultTypeInternal _SubnetSpec_default_instance_;
class SubnetStatus;
struct SubnetStatusDefaultTypeInternal;
extern SubnetStatusDefaultTypeInternal _SubnetStatus_default_instance_;
class Tag;
struct TagDefaultTypeInternal;
extern TagDefaultTypeInternal _Tag_default_instance_;
class TagList;
struct TagListDefaultTypeInternal;
extern TagListDefaultTypeInternal _TagList_default_instance_;
class TagSpec;
struct TagSpecDefaultTypeInternal;
extern TagSpecDefaultTypeInternal _TagSpec_default_instance_;
class TagStatus;
struct TagStatusDefaultTypeInternal;
extern TagStatusDefaultTypeInternal _TagStatus_default_instance_;
class TagType;
struct TagTypeDefaultTypeInternal;
extern TagTypeDefaultTypeInternal _TagType_default_instance_;
class TagTypeList;
struct TagTypeListDefaultTypeInternal;
extern TagTypeListDefaultTypeInternal _TagTypeList_default_instance_;
class TagTypeSpec;
struct TagTypeSpecDefaultTypeInternal;
extern TagTypeSpecDefaultTypeInternal _TagTypeSpec_default_instance_;
class TagTypeStatus;
struct TagTypeStatusDefaultTypeInternal;
extern TagTypeStatusDefaultTypeInternal _TagTypeStatus_default_instance_;
class VirtualMachine;
struct VirtualMachineDefaultTypeInternal;
extern VirtualMachineDefaultTypeInternal _VirtualMachine_default_instance_;
class VirtualMachineInterface;
struct VirtualMachineInterfaceDefaultTypeInternal;
extern VirtualMachineInterfaceDefaultTypeInternal _VirtualMachineInterface_default_instance_;
class VirtualMachineInterfaceList;
struct VirtualMachineInterfaceListDefaultTypeInternal;
extern VirtualMachineInterfaceListDefaultTypeInternal _VirtualMachineInterfaceList_default_instance_;
class VirtualMachineInterfaceProperties;
struct VirtualMachineInterfacePropertiesDefaultTypeInternal;
extern VirtualMachineInterfacePropertiesDefaultTypeInternal _VirtualMachineInterfaceProperties_default_instance_;
class VirtualMachineInterfaceSpec;
struct VirtualMachineInterfaceSpecDefaultTypeInternal;
extern VirtualMachineInterfaceSpecDefaultTypeInternal _VirtualMachineInterfaceSpec_default_instance_;
class VirtualMachineInterfaceStatus;
struct VirtualMachineInterfaceStatusDefaultTypeInternal;
extern VirtualMachineInterfaceStatusDefaultTypeInternal _VirtualMachineInterfaceStatus_default_instance_;
class VirtualMachineList;
struct VirtualMachineListDefaultTypeInternal;
extern VirtualMachineListDefaultTypeInternal _VirtualMachineList_default_instance_;
class VirtualMachineSpec;
struct VirtualMachineSpecDefaultTypeInternal;
extern VirtualMachineSpecDefaultTypeInternal _VirtualMachineSpec_default_instance_;
class VirtualMachineStatus;
struct VirtualMachineStatusDefaultTypeInternal;
extern VirtualMachineStatusDefaultTypeInternal _VirtualMachineStatus_default_instance_;
class VirtualNetwork;
struct VirtualNetworkDefaultTypeInternal;
extern VirtualNetworkDefaultTypeInternal _VirtualNetwork_default_instance_;
class VirtualNetworkList;
struct VirtualNetworkListDefaultTypeInternal;
extern VirtualNetworkListDefaultTypeInternal _VirtualNetworkList_default_instance_;
class VirtualNetworkRouteTargetReferenceList;
struct VirtualNetworkRouteTargetReferenceListDefaultTypeInternal;
extern VirtualNetworkRouteTargetReferenceListDefaultTypeInternal _VirtualNetworkRouteTargetReferenceList_default_instance_;
class VirtualNetworkRouter;
struct VirtualNetworkRouterDefaultTypeInternal;
extern VirtualNetworkRouterDefaultTypeInternal _VirtualNetworkRouter_default_instance_;
class VirtualNetworkRouterEntry;
struct VirtualNetworkRouterEntryDefaultTypeInternal;
extern VirtualNetworkRouterEntryDefaultTypeInternal _VirtualNetworkRouterEntry_default_instance_;
class VirtualNetworkRouterList;
struct VirtualNetworkRouterListDefaultTypeInternal;
extern VirtualNetworkRouterListDefaultTypeInternal _VirtualNetworkRouterList_default_instance_;
class VirtualNetworkRouterSpec;
struct VirtualNetworkRouterSpecDefaultTypeInternal;
extern VirtualNetworkRouterSpecDefaultTypeInternal _VirtualNetworkRouterSpec_default_instance_;
class VirtualNetworkRouterStatus;
struct VirtualNetworkRouterStatusDefaultTypeInternal;
extern VirtualNetworkRouterStatusDefaultTypeInternal _VirtualNetworkRouterStatus_default_instance_;
class VirtualNetworkSpec;
struct VirtualNetworkSpecDefaultTypeInternal;
extern VirtualNetworkSpecDefaultTypeInternal _VirtualNetworkSpec_default_instance_;
class VirtualNetworkStatus;
struct VirtualNetworkStatusDefaultTypeInternal;
extern VirtualNetworkStatusDefaultTypeInternal _VirtualNetworkStatus_default_instance_;
class VirtualNetworkType;
struct VirtualNetworkTypeDefaultTypeInternal;
extern VirtualNetworkTypeDefaultTypeInternal _VirtualNetworkType_default_instance_;
class VirtualRouter;
struct VirtualRouterDefaultTypeInternal;
extern VirtualRouterDefaultTypeInternal _VirtualRouter_default_instance_;
class VirtualRouterList;
struct VirtualRouterListDefaultTypeInternal;
extern VirtualRouterListDefaultTypeInternal _VirtualRouterList_default_instance_;
class VirtualRouterSpec;
struct VirtualRouterSpecDefaultTypeInternal;
extern VirtualRouterSpecDefaultTypeInternal _VirtualRouterSpec_default_instance_;
class VirtualRouterStatus;
struct VirtualRouterStatusDefaultTypeInternal;
extern VirtualRouterStatusDefaultTypeInternal _VirtualRouterStatus_default_instance_;
}  // namespace v1alpha1
}  // namespace core
}  // namespace apis
}  // namespace pkg
}  // namespace contrail
}  // namespace cn2
}  // namespace contrail
}  // namespace net
}  // namespace juniper
}  // namespace ssd_git
PROTOBUF_NAMESPACE_OPEN
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterList* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterList>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec>(Arena*);
template<> ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* Arena::CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ssd_git {
namespace juniper {
namespace net {
namespace contrail {
namespace cn2 {
namespace contrail {
namespace pkg {
namespace apis {
namespace core {
namespace v1alpha1 {

// ===================================================================

class APSAttribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute) */ {
 public:
  inline APSAttribute() : APSAttribute(nullptr) {}
  ~APSAttribute() override;
  explicit constexpr APSAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APSAttribute(const APSAttribute& from);
  APSAttribute(APSAttribute&& from) noexcept
    : APSAttribute() {
    *this = ::std::move(from);
  }

  inline APSAttribute& operator=(const APSAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline APSAttribute& operator=(APSAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APSAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const APSAttribute* internal_default_instance() {
    return reinterpret_cast<const APSAttribute*>(
               &_APSAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(APSAttribute& a, APSAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(APSAttribute* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APSAttribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline APSAttribute* New() const final {
    return new APSAttribute();
  }

  APSAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<APSAttribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APSAttribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const APSAttribute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APSAttribute* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute";
  }
  protected:
  explicit APSAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 1,
  };
  // optional string sequence = 1;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;
  public:
  void clear_sequence();
  const std::string& sequence() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence();
  PROTOBUF_MUST_USE_RESULT std::string* release_sequence();
  void set_allocated_sequence(std::string* sequence);
  private:
  const std::string& _internal_sequence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence(const std::string& value);
  std::string* _internal_mutable_sequence();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AddressFamilies final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies) */ {
 public:
  inline AddressFamilies() : AddressFamilies(nullptr) {}
  ~AddressFamilies() override;
  explicit constexpr AddressFamilies(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressFamilies(const AddressFamilies& from);
  AddressFamilies(AddressFamilies&& from) noexcept
    : AddressFamilies() {
    *this = ::std::move(from);
  }

  inline AddressFamilies& operator=(const AddressFamilies& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressFamilies& operator=(AddressFamilies&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressFamilies& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressFamilies* internal_default_instance() {
    return reinterpret_cast<const AddressFamilies*>(
               &_AddressFamilies_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddressFamilies& a, AddressFamilies& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressFamilies* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressFamilies* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddressFamilies* New() const final {
    return new AddressFamilies();
  }

  AddressFamilies* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddressFamilies>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressFamilies& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressFamilies& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressFamilies* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies";
  }
  protected:
  explicit AddressFamilies(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 1,
  };
  // repeated string family = 1;
  int family_size() const;
  private:
  int _internal_family_size() const;
  public:
  void clear_family();
  const std::string& family(int index) const;
  std::string* mutable_family(int index);
  void set_family(int index, const std::string& value);
  void set_family(int index, std::string&& value);
  void set_family(int index, const char* value);
  void set_family(int index, const char* value, size_t size);
  std::string* add_family();
  void add_family(const std::string& value);
  void add_family(std::string&& value);
  void add_family(const char* value);
  void add_family(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& family() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_family();
  private:
  const std::string& _internal_family(int index) const;
  std::string* _internal_add_family();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> family_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AddressGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup) */ {
 public:
  inline AddressGroup() : AddressGroup(nullptr) {}
  ~AddressGroup() override;
  explicit constexpr AddressGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressGroup(const AddressGroup& from);
  AddressGroup(AddressGroup&& from) noexcept
    : AddressGroup() {
    *this = ::std::move(from);
  }

  inline AddressGroup& operator=(const AddressGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressGroup& operator=(AddressGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressGroup* internal_default_instance() {
    return reinterpret_cast<const AddressGroup*>(
               &_AddressGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AddressGroup& a, AddressGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressGroup* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddressGroup* New() const final {
    return new AddressGroup();
  }

  AddressGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddressGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup";
  }
  protected:
  explicit AddressGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AddressGroupList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList) */ {
 public:
  inline AddressGroupList() : AddressGroupList(nullptr) {}
  ~AddressGroupList() override;
  explicit constexpr AddressGroupList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressGroupList(const AddressGroupList& from);
  AddressGroupList(AddressGroupList&& from) noexcept
    : AddressGroupList() {
    *this = ::std::move(from);
  }

  inline AddressGroupList& operator=(const AddressGroupList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressGroupList& operator=(AddressGroupList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressGroupList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressGroupList* internal_default_instance() {
    return reinterpret_cast<const AddressGroupList*>(
               &_AddressGroupList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AddressGroupList& a, AddressGroupList& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressGroupList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressGroupList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddressGroupList* New() const final {
    return new AddressGroupList();
  }

  AddressGroupList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddressGroupList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressGroupList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressGroupList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressGroupList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList";
  }
  protected:
  explicit AddressGroupList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AddressGroupPrefix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix) */ {
 public:
  inline AddressGroupPrefix() : AddressGroupPrefix(nullptr) {}
  ~AddressGroupPrefix() override;
  explicit constexpr AddressGroupPrefix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressGroupPrefix(const AddressGroupPrefix& from);
  AddressGroupPrefix(AddressGroupPrefix&& from) noexcept
    : AddressGroupPrefix() {
    *this = ::std::move(from);
  }

  inline AddressGroupPrefix& operator=(const AddressGroupPrefix& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressGroupPrefix& operator=(AddressGroupPrefix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressGroupPrefix& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressGroupPrefix* internal_default_instance() {
    return reinterpret_cast<const AddressGroupPrefix*>(
               &_AddressGroupPrefix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AddressGroupPrefix& a, AddressGroupPrefix& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressGroupPrefix* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressGroupPrefix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddressGroupPrefix* New() const final {
    return new AddressGroupPrefix();
  }

  AddressGroupPrefix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddressGroupPrefix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressGroupPrefix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressGroupPrefix& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressGroupPrefix* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix";
  }
  protected:
  explicit AddressGroupPrefix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubnetFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet subnet = 1;
  int subnet_size() const;
  private:
  int _internal_subnet_size() const;
  public:
  void clear_subnet();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* mutable_subnet(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet >*
      mutable_subnet();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet& _internal_subnet(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* _internal_add_subnet();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet& subnet(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* add_subnet();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet >&
      subnet() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet > subnet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AddressGroupSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec) */ {
 public:
  inline AddressGroupSpec() : AddressGroupSpec(nullptr) {}
  ~AddressGroupSpec() override;
  explicit constexpr AddressGroupSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressGroupSpec(const AddressGroupSpec& from);
  AddressGroupSpec(AddressGroupSpec&& from) noexcept
    : AddressGroupSpec() {
    *this = ::std::move(from);
  }

  inline AddressGroupSpec& operator=(const AddressGroupSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressGroupSpec& operator=(AddressGroupSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressGroupSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressGroupSpec* internal_default_instance() {
    return reinterpret_cast<const AddressGroupSpec*>(
               &_AddressGroupSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AddressGroupSpec& a, AddressGroupSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressGroupSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressGroupSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddressGroupSpec* New() const final {
    return new AddressGroupSpec();
  }

  AddressGroupSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddressGroupSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressGroupSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressGroupSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressGroupSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec";
  }
  protected:
  explicit AddressGroupSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonSpecFieldNumber = 1,
    kAddressGroupPrefixesFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix addressGroupPrefixes = 2;
  bool has_addressgroupprefixes() const;
  private:
  bool _internal_has_addressgroupprefixes() const;
  public:
  void clear_addressgroupprefixes();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix& addressgroupprefixes() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* release_addressgroupprefixes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* mutable_addressgroupprefixes();
  void set_allocated_addressgroupprefixes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* addressgroupprefixes);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix& _internal_addressgroupprefixes() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* _internal_mutable_addressgroupprefixes();
  public:
  void unsafe_arena_set_allocated_addressgroupprefixes(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* addressgroupprefixes);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* unsafe_arena_release_addressgroupprefixes();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* addressgroupprefixes_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AddressGroupStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus) */ {
 public:
  inline AddressGroupStatus() : AddressGroupStatus(nullptr) {}
  ~AddressGroupStatus() override;
  explicit constexpr AddressGroupStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressGroupStatus(const AddressGroupStatus& from);
  AddressGroupStatus(AddressGroupStatus&& from) noexcept
    : AddressGroupStatus() {
    *this = ::std::move(from);
  }

  inline AddressGroupStatus& operator=(const AddressGroupStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressGroupStatus& operator=(AddressGroupStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressGroupStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressGroupStatus* internal_default_instance() {
    return reinterpret_cast<const AddressGroupStatus*>(
               &_AddressGroupStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AddressGroupStatus& a, AddressGroupStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressGroupStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressGroupStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddressGroupStatus* New() const final {
    return new AddressGroupStatus();
  }

  AddressGroupStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddressGroupStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressGroupStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressGroupStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressGroupStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus";
  }
  protected:
  explicit AddressGroupStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AllowedAddressPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair) */ {
 public:
  inline AllowedAddressPair() : AllowedAddressPair(nullptr) {}
  ~AllowedAddressPair() override;
  explicit constexpr AllowedAddressPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowedAddressPair(const AllowedAddressPair& from);
  AllowedAddressPair(AllowedAddressPair&& from) noexcept
    : AllowedAddressPair() {
    *this = ::std::move(from);
  }

  inline AllowedAddressPair& operator=(const AllowedAddressPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowedAddressPair& operator=(AllowedAddressPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowedAddressPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowedAddressPair* internal_default_instance() {
    return reinterpret_cast<const AllowedAddressPair*>(
               &_AllowedAddressPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AllowedAddressPair& a, AllowedAddressPair& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowedAddressPair* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowedAddressPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllowedAddressPair* New() const final {
    return new AllowedAddressPair();
  }

  AllowedAddressPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllowedAddressPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllowedAddressPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AllowedAddressPair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllowedAddressPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair";
  }
  protected:
  explicit AllowedAddressPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacFieldNumber = 2,
    kAddressModeFieldNumber = 3,
    kIpFieldNumber = 1,
  };
  // optional string mac = 2;
  bool has_mac() const;
  private:
  bool _internal_has_mac() const;
  public:
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_MUST_USE_RESULT std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // optional string addressMode = 3;
  bool has_addressmode() const;
  private:
  bool _internal_has_addressmode() const;
  public:
  void clear_addressmode();
  const std::string& addressmode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addressmode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addressmode();
  PROTOBUF_MUST_USE_RESULT std::string* release_addressmode();
  void set_allocated_addressmode(std::string* addressmode);
  private:
  const std::string& _internal_addressmode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addressmode(const std::string& value);
  std::string* _internal_mutable_addressmode();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet ip = 1;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet& ip() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* release_ip();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* mutable_ip();
  void set_allocated_ip(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* ip);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet& _internal_ip() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* _internal_mutable_ip();
  public:
  void unsafe_arena_set_allocated_ip(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* ip);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* unsafe_arena_release_ip();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addressmode_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* ip_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AllowedAddressPairSubnet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet) */ {
 public:
  inline AllowedAddressPairSubnet() : AllowedAddressPairSubnet(nullptr) {}
  ~AllowedAddressPairSubnet() override;
  explicit constexpr AllowedAddressPairSubnet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowedAddressPairSubnet(const AllowedAddressPairSubnet& from);
  AllowedAddressPairSubnet(AllowedAddressPairSubnet&& from) noexcept
    : AllowedAddressPairSubnet() {
    *this = ::std::move(from);
  }

  inline AllowedAddressPairSubnet& operator=(const AllowedAddressPairSubnet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowedAddressPairSubnet& operator=(AllowedAddressPairSubnet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowedAddressPairSubnet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowedAddressPairSubnet* internal_default_instance() {
    return reinterpret_cast<const AllowedAddressPairSubnet*>(
               &_AllowedAddressPairSubnet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AllowedAddressPairSubnet& a, AllowedAddressPairSubnet& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowedAddressPairSubnet* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowedAddressPairSubnet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllowedAddressPairSubnet* New() const final {
    return new AllowedAddressPairSubnet();
  }

  AllowedAddressPairSubnet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllowedAddressPairSubnet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllowedAddressPairSubnet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AllowedAddressPairSubnet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllowedAddressPairSubnet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet";
  }
  protected:
  explicit AllowedAddressPairSubnet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpPrefixFieldNumber = 1,
    kIpPrefixLenFieldNumber = 2,
  };
  // optional string ipPrefix = 1;
  bool has_ipprefix() const;
  private:
  bool _internal_has_ipprefix() const;
  public:
  void clear_ipprefix();
  const std::string& ipprefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipprefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipprefix();
  PROTOBUF_MUST_USE_RESULT std::string* release_ipprefix();
  void set_allocated_ipprefix(std::string* ipprefix);
  private:
  const std::string& _internal_ipprefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipprefix(const std::string& value);
  std::string* _internal_mutable_ipprefix();
  public:

  // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString ipPrefixLen = 2;
  bool has_ipprefixlen() const;
  private:
  bool _internal_has_ipprefixlen() const;
  public:
  void clear_ipprefixlen();
  const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& ipprefixlen() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* release_ipprefixlen();
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* mutable_ipprefixlen();
  void set_allocated_ipprefixlen(::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen);
  private:
  const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& _internal_ipprefixlen() const;
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* _internal_mutable_ipprefixlen();
  public:
  void unsafe_arena_set_allocated_ipprefixlen(
      ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen);
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* unsafe_arena_release_ipprefixlen();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipprefix_;
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AllowedAddressPairs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs) */ {
 public:
  inline AllowedAddressPairs() : AllowedAddressPairs(nullptr) {}
  ~AllowedAddressPairs() override;
  explicit constexpr AllowedAddressPairs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowedAddressPairs(const AllowedAddressPairs& from);
  AllowedAddressPairs(AllowedAddressPairs&& from) noexcept
    : AllowedAddressPairs() {
    *this = ::std::move(from);
  }

  inline AllowedAddressPairs& operator=(const AllowedAddressPairs& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowedAddressPairs& operator=(AllowedAddressPairs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowedAddressPairs& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowedAddressPairs* internal_default_instance() {
    return reinterpret_cast<const AllowedAddressPairs*>(
               &_AllowedAddressPairs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AllowedAddressPairs& a, AllowedAddressPairs& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowedAddressPairs* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowedAddressPairs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllowedAddressPairs* New() const final {
    return new AllowedAddressPairs();
  }

  AllowedAddressPairs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllowedAddressPairs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllowedAddressPairs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AllowedAddressPairs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllowedAddressPairs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs";
  }
  protected:
  explicit AllowedAddressPairs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedAddressPairFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair allowedAddressPair = 1;
  int allowedaddresspair_size() const;
  private:
  int _internal_allowedaddresspair_size() const;
  public:
  void clear_allowedaddresspair();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair* mutable_allowedaddresspair(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair >*
      mutable_allowedaddresspair();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair& _internal_allowedaddresspair(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair* _internal_add_allowedaddresspair();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair& allowedaddresspair(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair* add_allowedaddresspair();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair >&
      allowedaddresspair() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair > allowedaddresspair_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ApplicationPolicySet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet) */ {
 public:
  inline ApplicationPolicySet() : ApplicationPolicySet(nullptr) {}
  ~ApplicationPolicySet() override;
  explicit constexpr ApplicationPolicySet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplicationPolicySet(const ApplicationPolicySet& from);
  ApplicationPolicySet(ApplicationPolicySet&& from) noexcept
    : ApplicationPolicySet() {
    *this = ::std::move(from);
  }

  inline ApplicationPolicySet& operator=(const ApplicationPolicySet& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationPolicySet& operator=(ApplicationPolicySet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationPolicySet& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationPolicySet* internal_default_instance() {
    return reinterpret_cast<const ApplicationPolicySet*>(
               &_ApplicationPolicySet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ApplicationPolicySet& a, ApplicationPolicySet& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationPolicySet* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationPolicySet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplicationPolicySet* New() const final {
    return new ApplicationPolicySet();
  }

  ApplicationPolicySet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationPolicySet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplicationPolicySet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplicationPolicySet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationPolicySet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet";
  }
  protected:
  explicit ApplicationPolicySet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ApplicationPolicySetList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList) */ {
 public:
  inline ApplicationPolicySetList() : ApplicationPolicySetList(nullptr) {}
  ~ApplicationPolicySetList() override;
  explicit constexpr ApplicationPolicySetList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplicationPolicySetList(const ApplicationPolicySetList& from);
  ApplicationPolicySetList(ApplicationPolicySetList&& from) noexcept
    : ApplicationPolicySetList() {
    *this = ::std::move(from);
  }

  inline ApplicationPolicySetList& operator=(const ApplicationPolicySetList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationPolicySetList& operator=(ApplicationPolicySetList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationPolicySetList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationPolicySetList* internal_default_instance() {
    return reinterpret_cast<const ApplicationPolicySetList*>(
               &_ApplicationPolicySetList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ApplicationPolicySetList& a, ApplicationPolicySetList& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationPolicySetList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationPolicySetList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplicationPolicySetList* New() const final {
    return new ApplicationPolicySetList();
  }

  ApplicationPolicySetList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationPolicySetList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplicationPolicySetList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplicationPolicySetList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationPolicySetList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList";
  }
  protected:
  explicit ApplicationPolicySetList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ApplicationPolicySetSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec) */ {
 public:
  inline ApplicationPolicySetSpec() : ApplicationPolicySetSpec(nullptr) {}
  ~ApplicationPolicySetSpec() override;
  explicit constexpr ApplicationPolicySetSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplicationPolicySetSpec(const ApplicationPolicySetSpec& from);
  ApplicationPolicySetSpec(ApplicationPolicySetSpec&& from) noexcept
    : ApplicationPolicySetSpec() {
    *this = ::std::move(from);
  }

  inline ApplicationPolicySetSpec& operator=(const ApplicationPolicySetSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationPolicySetSpec& operator=(ApplicationPolicySetSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationPolicySetSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationPolicySetSpec* internal_default_instance() {
    return reinterpret_cast<const ApplicationPolicySetSpec*>(
               &_ApplicationPolicySetSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ApplicationPolicySetSpec& a, ApplicationPolicySetSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationPolicySetSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationPolicySetSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplicationPolicySetSpec* New() const final {
    return new ApplicationPolicySetSpec();
  }

  ApplicationPolicySetSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationPolicySetSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplicationPolicySetSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplicationPolicySetSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationPolicySetSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec";
  }
  protected:
  explicit ApplicationPolicySetSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirewallPolicyReferencesFieldNumber = 2,
    kTagReferencesFieldNumber = 3,
    kCommonSpecFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference firewallPolicyReferences = 2;
  int firewallpolicyreferences_size() const;
  private:
  int _internal_firewallpolicyreferences_size() const;
  public:
  void clear_firewallpolicyreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference* mutable_firewallpolicyreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference >*
      mutable_firewallpolicyreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference& _internal_firewallpolicyreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference* _internal_add_firewallpolicyreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference& firewallpolicyreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference* add_firewallpolicyreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference >&
      firewallpolicyreferences() const;

  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 3;
  int tagreferences_size() const;
  private:
  int _internal_tagreferences_size() const;
  public:
  void clear_tagreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_tagreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_tagreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_tagreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_tagreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& tagreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_tagreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      tagreferences() const;

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference > firewallpolicyreferences_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > tagreferences_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ApplicationPolicySetStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus) */ {
 public:
  inline ApplicationPolicySetStatus() : ApplicationPolicySetStatus(nullptr) {}
  ~ApplicationPolicySetStatus() override;
  explicit constexpr ApplicationPolicySetStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplicationPolicySetStatus(const ApplicationPolicySetStatus& from);
  ApplicationPolicySetStatus(ApplicationPolicySetStatus&& from) noexcept
    : ApplicationPolicySetStatus() {
    *this = ::std::move(from);
  }

  inline ApplicationPolicySetStatus& operator=(const ApplicationPolicySetStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationPolicySetStatus& operator=(ApplicationPolicySetStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationPolicySetStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationPolicySetStatus* internal_default_instance() {
    return reinterpret_cast<const ApplicationPolicySetStatus*>(
               &_ApplicationPolicySetStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ApplicationPolicySetStatus& a, ApplicationPolicySetStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationPolicySetStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationPolicySetStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplicationPolicySetStatus* New() const final {
    return new ApplicationPolicySetStatus();
  }

  ApplicationPolicySetStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationPolicySetStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplicationPolicySetStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplicationPolicySetStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationPolicySetStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus";
  }
  protected:
  explicit ApplicationPolicySetStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
    kAllApplicationsFieldNumber = 3,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // optional bool allApplications = 3;
  bool has_allapplications() const;
  private:
  bool _internal_has_allapplications() const;
  public:
  void clear_allapplications();
  bool allapplications() const;
  void set_allapplications(bool value);
  private:
  bool _internal_allapplications() const;
  void _internal_set_allapplications(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  bool allapplications_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AuthenticationData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData) */ {
 public:
  inline AuthenticationData() : AuthenticationData(nullptr) {}
  ~AuthenticationData() override;
  explicit constexpr AuthenticationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticationData(const AuthenticationData& from);
  AuthenticationData(AuthenticationData&& from) noexcept
    : AuthenticationData() {
    *this = ::std::move(from);
  }

  inline AuthenticationData& operator=(const AuthenticationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticationData& operator=(AuthenticationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticationData* internal_default_instance() {
    return reinterpret_cast<const AuthenticationData*>(
               &_AuthenticationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AuthenticationData& a, AuthenticationData& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticationData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticationData* New() const final {
    return new AuthenticationData();
  }

  AuthenticationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticationData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticationData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticationData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticationData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData";
  }
  protected:
  explicit AuthenticationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyItemsFieldNumber = 2,
    kKeyTypeFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem keyItems = 2;
  int keyitems_size() const;
  private:
  int _internal_keyitems_size() const;
  public:
  void clear_keyitems();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem* mutable_keyitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem >*
      mutable_keyitems();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem& _internal_keyitems(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem* _internal_add_keyitems();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem& keyitems(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem* add_keyitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem >&
      keyitems() const;

  // optional string keyType = 1;
  bool has_keytype() const;
  private:
  bool _internal_has_keytype() const;
  public:
  void clear_keytype();
  const std::string& keytype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keytype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keytype();
  PROTOBUF_MUST_USE_RESULT std::string* release_keytype();
  void set_allocated_keytype(std::string* keytype);
  private:
  const std::string& _internal_keytype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keytype(const std::string& value);
  std::string* _internal_mutable_keytype();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem > keyitems_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keytype_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class AuthenticationKeyItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem) */ {
 public:
  inline AuthenticationKeyItem() : AuthenticationKeyItem(nullptr) {}
  ~AuthenticationKeyItem() override;
  explicit constexpr AuthenticationKeyItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticationKeyItem(const AuthenticationKeyItem& from);
  AuthenticationKeyItem(AuthenticationKeyItem&& from) noexcept
    : AuthenticationKeyItem() {
    *this = ::std::move(from);
  }

  inline AuthenticationKeyItem& operator=(const AuthenticationKeyItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticationKeyItem& operator=(AuthenticationKeyItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticationKeyItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticationKeyItem* internal_default_instance() {
    return reinterpret_cast<const AuthenticationKeyItem*>(
               &_AuthenticationKeyItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AuthenticationKeyItem& a, AuthenticationKeyItem& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticationKeyItem* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticationKeyItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticationKeyItem* New() const final {
    return new AuthenticationKeyItem();
  }

  AuthenticationKeyItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticationKeyItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticationKeyItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticationKeyItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticationKeyItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem";
  }
  protected:
  explicit AuthenticationKeyItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kKeyIdFieldNumber = 1,
  };
  // optional string key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional int32 keyId = 1;
  bool has_keyid() const;
  private:
  bool _internal_has_keyid() const;
  public:
  void clear_keyid();
  ::PROTOBUF_NAMESPACE_ID::int32 keyid() const;
  void set_keyid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_keyid() const;
  void _internal_set_keyid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::int32 keyid_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPAsAService final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService) */ {
 public:
  inline BGPAsAService() : BGPAsAService(nullptr) {}
  ~BGPAsAService() override;
  explicit constexpr BGPAsAService(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPAsAService(const BGPAsAService& from);
  BGPAsAService(BGPAsAService&& from) noexcept
    : BGPAsAService() {
    *this = ::std::move(from);
  }

  inline BGPAsAService& operator=(const BGPAsAService& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPAsAService& operator=(BGPAsAService&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPAsAService& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPAsAService* internal_default_instance() {
    return reinterpret_cast<const BGPAsAService*>(
               &_BGPAsAService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BGPAsAService& a, BGPAsAService& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPAsAService* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPAsAService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPAsAService* New() const final {
    return new BGPAsAService();
  }

  BGPAsAService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPAsAService>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPAsAService& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPAsAService& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPAsAService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService";
  }
  protected:
  explicit BGPAsAService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPAsAServiceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList) */ {
 public:
  inline BGPAsAServiceList() : BGPAsAServiceList(nullptr) {}
  ~BGPAsAServiceList() override;
  explicit constexpr BGPAsAServiceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPAsAServiceList(const BGPAsAServiceList& from);
  BGPAsAServiceList(BGPAsAServiceList&& from) noexcept
    : BGPAsAServiceList() {
    *this = ::std::move(from);
  }

  inline BGPAsAServiceList& operator=(const BGPAsAServiceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPAsAServiceList& operator=(BGPAsAServiceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPAsAServiceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPAsAServiceList* internal_default_instance() {
    return reinterpret_cast<const BGPAsAServiceList*>(
               &_BGPAsAServiceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BGPAsAServiceList& a, BGPAsAServiceList& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPAsAServiceList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPAsAServiceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPAsAServiceList* New() const final {
    return new BGPAsAServiceList();
  }

  BGPAsAServiceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPAsAServiceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPAsAServiceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPAsAServiceList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPAsAServiceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList";
  }
  protected:
  explicit BGPAsAServiceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPAsAServiceSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec) */ {
 public:
  inline BGPAsAServiceSpec() : BGPAsAServiceSpec(nullptr) {}
  ~BGPAsAServiceSpec() override;
  explicit constexpr BGPAsAServiceSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPAsAServiceSpec(const BGPAsAServiceSpec& from);
  BGPAsAServiceSpec(BGPAsAServiceSpec&& from) noexcept
    : BGPAsAServiceSpec() {
    *this = ::std::move(from);
  }

  inline BGPAsAServiceSpec& operator=(const BGPAsAServiceSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPAsAServiceSpec& operator=(BGPAsAServiceSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPAsAServiceSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPAsAServiceSpec* internal_default_instance() {
    return reinterpret_cast<const BGPAsAServiceSpec*>(
               &_BGPAsAServiceSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BGPAsAServiceSpec& a, BGPAsAServiceSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPAsAServiceSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPAsAServiceSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPAsAServiceSpec* New() const final {
    return new BGPAsAServiceSpec();
  }

  BGPAsAServiceSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPAsAServiceSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPAsAServiceSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPAsAServiceSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPAsAServiceSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec";
  }
  protected:
  explicit BGPAsAServiceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualMachineInterfaceReferencesFieldNumber = 8,
    kVirtualMachineInterfacesSelectorFieldNumber = 9,
    kIpAddressFieldNumber = 3,
    kCommonSpecFieldNumber = 1,
    kBgpAsAServiceSessionAttributesFieldNumber = 7,
    kAutonomousSystemFieldNumber = 4,
    kSharedFieldNumber = 2,
    kSuppressRouteAdvertisementFieldNumber = 5,
    kIpv4MappedIPv6NextHopFieldNumber = 6,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 8;
  int virtualmachineinterfacereferences_size() const;
  private:
  int _internal_virtualmachineinterfacereferences_size() const;
  public:
  void clear_virtualmachineinterfacereferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_virtualmachineinterfacereferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_virtualmachineinterfacereferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_virtualmachineinterfacereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_virtualmachineinterfacereferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& virtualmachineinterfacereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_virtualmachineinterfacereferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      virtualmachineinterfacereferences() const;

  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualMachineInterfacesSelector = 9;
  int virtualmachineinterfacesselector_size() const;
  private:
  int _internal_virtualmachineinterfacesselector_size() const;
  public:
  void clear_virtualmachineinterfacesselector();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* mutable_virtualmachineinterfacesselector(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector >*
      mutable_virtualmachineinterfacesselector();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& _internal_virtualmachineinterfacesselector(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* _internal_add_virtualmachineinterfacesselector();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& virtualmachineinterfacesselector(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* add_virtualmachineinterfacesselector();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector >&
      virtualmachineinterfacesselector() const;

  // optional string ipAddress = 3;
  bool has_ipaddress() const;
  private:
  bool _internal_has_ipaddress() const;
  public:
  void clear_ipaddress();
  const std::string& ipaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_ipaddress();
  void set_allocated_ipaddress(std::string* ipaddress);
  private:
  const std::string& _internal_ipaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipaddress(const std::string& value);
  std::string* _internal_mutable_ipaddress();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes bgpAsAServiceSessionAttributes = 7;
  bool has_bgpasaservicesessionattributes() const;
  private:
  bool _internal_has_bgpasaservicesessionattributes() const;
  public:
  void clear_bgpasaservicesessionattributes();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes& bgpasaservicesessionattributes() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* release_bgpasaservicesessionattributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* mutable_bgpasaservicesessionattributes();
  void set_allocated_bgpasaservicesessionattributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* bgpasaservicesessionattributes);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes& _internal_bgpasaservicesessionattributes() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* _internal_mutable_bgpasaservicesessionattributes();
  public:
  void unsafe_arena_set_allocated_bgpasaservicesessionattributes(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* bgpasaservicesessionattributes);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* unsafe_arena_release_bgpasaservicesessionattributes();

  // optional int32 autonomousSystem = 4;
  bool has_autonomoussystem() const;
  private:
  bool _internal_has_autonomoussystem() const;
  public:
  void clear_autonomoussystem();
  ::PROTOBUF_NAMESPACE_ID::int32 autonomoussystem() const;
  void set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_autonomoussystem() const;
  void _internal_set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool shared = 2;
  bool has_shared() const;
  private:
  bool _internal_has_shared() const;
  public:
  void clear_shared();
  bool shared() const;
  void set_shared(bool value);
  private:
  bool _internal_shared() const;
  void _internal_set_shared(bool value);
  public:

  // optional bool suppressRouteAdvertisement = 5;
  bool has_suppressrouteadvertisement() const;
  private:
  bool _internal_has_suppressrouteadvertisement() const;
  public:
  void clear_suppressrouteadvertisement();
  bool suppressrouteadvertisement() const;
  void set_suppressrouteadvertisement(bool value);
  private:
  bool _internal_suppressrouteadvertisement() const;
  void _internal_set_suppressrouteadvertisement(bool value);
  public:

  // optional bool ipv4MappedIPv6NextHop = 6;
  bool has_ipv4mappedipv6nexthop() const;
  private:
  bool _internal_has_ipv4mappedipv6nexthop() const;
  public:
  void clear_ipv4mappedipv6nexthop();
  bool ipv4mappedipv6nexthop() const;
  void set_ipv4mappedipv6nexthop(bool value);
  private:
  bool _internal_ipv4mappedipv6nexthop() const;
  void _internal_set_ipv4mappedipv6nexthop(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > virtualmachineinterfacereferences_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector > virtualmachineinterfacesselector_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddress_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* bgpasaservicesessionattributes_;
  ::PROTOBUF_NAMESPACE_ID::int32 autonomoussystem_;
  bool shared_;
  bool suppressrouteadvertisement_;
  bool ipv4mappedipv6nexthop_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPAsAServiceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus) */ {
 public:
  inline BGPAsAServiceStatus() : BGPAsAServiceStatus(nullptr) {}
  ~BGPAsAServiceStatus() override;
  explicit constexpr BGPAsAServiceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPAsAServiceStatus(const BGPAsAServiceStatus& from);
  BGPAsAServiceStatus(BGPAsAServiceStatus&& from) noexcept
    : BGPAsAServiceStatus() {
    *this = ::std::move(from);
  }

  inline BGPAsAServiceStatus& operator=(const BGPAsAServiceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPAsAServiceStatus& operator=(BGPAsAServiceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPAsAServiceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPAsAServiceStatus* internal_default_instance() {
    return reinterpret_cast<const BGPAsAServiceStatus*>(
               &_BGPAsAServiceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BGPAsAServiceStatus& a, BGPAsAServiceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPAsAServiceStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPAsAServiceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPAsAServiceStatus* New() const final {
    return new BGPAsAServiceStatus();
  }

  BGPAsAServiceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPAsAServiceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPAsAServiceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPAsAServiceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPAsAServiceStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus";
  }
  protected:
  explicit BGPAsAServiceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBgpRouterReferencesFieldNumber = 2,
    kSubnetReferencesFieldNumber = 3,
    kCommonStatusFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference bgpRouterReferences = 2;
  int bgprouterreferences_size() const;
  private:
  int _internal_bgprouterreferences_size() const;
  public:
  void clear_bgprouterreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* mutable_bgprouterreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference >*
      mutable_bgprouterreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference& _internal_bgprouterreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* _internal_add_bgprouterreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference& bgprouterreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* add_bgprouterreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference >&
      bgprouterreferences() const;

  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference subnetReferences = 3;
  int subnetreferences_size() const;
  private:
  int _internal_subnetreferences_size() const;
  public:
  void clear_subnetreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference* mutable_subnetreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference >*
      mutable_subnetreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference& _internal_subnetreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference* _internal_add_subnetreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference& subnetreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference* add_subnetreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference >&
      subnetreferences() const;

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference > bgprouterreferences_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference > subnetreferences_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPFamilyAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes) */ {
 public:
  inline BGPFamilyAttributes() : BGPFamilyAttributes(nullptr) {}
  ~BGPFamilyAttributes() override;
  explicit constexpr BGPFamilyAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPFamilyAttributes(const BGPFamilyAttributes& from);
  BGPFamilyAttributes(BGPFamilyAttributes&& from) noexcept
    : BGPFamilyAttributes() {
    *this = ::std::move(from);
  }

  inline BGPFamilyAttributes& operator=(const BGPFamilyAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPFamilyAttributes& operator=(BGPFamilyAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPFamilyAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPFamilyAttributes* internal_default_instance() {
    return reinterpret_cast<const BGPFamilyAttributes*>(
               &_BGPFamilyAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BGPFamilyAttributes& a, BGPFamilyAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPFamilyAttributes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPFamilyAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPFamilyAttributes* New() const final {
    return new BGPFamilyAttributes();
  }

  BGPFamilyAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPFamilyAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPFamilyAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPFamilyAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPFamilyAttributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes";
  }
  protected:
  explicit BGPFamilyAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultTunnelEncapFieldNumber = 4,
    kAddressFamilyFieldNumber = 1,
    kPrefixLimitFieldNumber = 3,
    kLoopCountFieldNumber = 2,
  };
  // repeated string defaultTunnelEncap = 4;
  int defaulttunnelencap_size() const;
  private:
  int _internal_defaulttunnelencap_size() const;
  public:
  void clear_defaulttunnelencap();
  const std::string& defaulttunnelencap(int index) const;
  std::string* mutable_defaulttunnelencap(int index);
  void set_defaulttunnelencap(int index, const std::string& value);
  void set_defaulttunnelencap(int index, std::string&& value);
  void set_defaulttunnelencap(int index, const char* value);
  void set_defaulttunnelencap(int index, const char* value, size_t size);
  std::string* add_defaulttunnelencap();
  void add_defaulttunnelencap(const std::string& value);
  void add_defaulttunnelencap(std::string&& value);
  void add_defaulttunnelencap(const char* value);
  void add_defaulttunnelencap(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& defaulttunnelencap() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_defaulttunnelencap();
  private:
  const std::string& _internal_defaulttunnelencap(int index) const;
  std::string* _internal_add_defaulttunnelencap();
  public:

  // optional string addressFamily = 1;
  bool has_addressfamily() const;
  private:
  bool _internal_has_addressfamily() const;
  public:
  void clear_addressfamily();
  const std::string& addressfamily() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addressfamily(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addressfamily();
  PROTOBUF_MUST_USE_RESULT std::string* release_addressfamily();
  void set_allocated_addressfamily(std::string* addressfamily);
  private:
  const std::string& _internal_addressfamily() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addressfamily(const std::string& value);
  std::string* _internal_mutable_addressfamily();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit prefixLimit = 3;
  bool has_prefixlimit() const;
  private:
  bool _internal_has_prefixlimit() const;
  public:
  void clear_prefixlimit();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit& prefixlimit() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* release_prefixlimit();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* mutable_prefixlimit();
  void set_allocated_prefixlimit(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* prefixlimit);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit& _internal_prefixlimit() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* _internal_mutable_prefixlimit();
  public:
  void unsafe_arena_set_allocated_prefixlimit(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* prefixlimit);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* unsafe_arena_release_prefixlimit();

  // optional int32 loopCount = 2;
  bool has_loopcount() const;
  private:
  bool _internal_has_loopcount() const;
  public:
  void clear_loopcount();
  ::PROTOBUF_NAMESPACE_ID::int32 loopcount() const;
  void set_loopcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_loopcount() const;
  void _internal_set_loopcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> defaulttunnelencap_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addressfamily_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* prefixlimit_;
  ::PROTOBUF_NAMESPACE_ID::int32 loopcount_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPPrefixLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit) */ {
 public:
  inline BGPPrefixLimit() : BGPPrefixLimit(nullptr) {}
  ~BGPPrefixLimit() override;
  explicit constexpr BGPPrefixLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPPrefixLimit(const BGPPrefixLimit& from);
  BGPPrefixLimit(BGPPrefixLimit&& from) noexcept
    : BGPPrefixLimit() {
    *this = ::std::move(from);
  }

  inline BGPPrefixLimit& operator=(const BGPPrefixLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPPrefixLimit& operator=(BGPPrefixLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPPrefixLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPPrefixLimit* internal_default_instance() {
    return reinterpret_cast<const BGPPrefixLimit*>(
               &_BGPPrefixLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BGPPrefixLimit& a, BGPPrefixLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPPrefixLimit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPPrefixLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPPrefixLimit* New() const final {
    return new BGPPrefixLimit();
  }

  BGPPrefixLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPPrefixLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPPrefixLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPPrefixLimit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPPrefixLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit";
  }
  protected:
  explicit BGPPrefixLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdleTimeoutFieldNumber = 1,
    kMaximumFieldNumber = 2,
  };
  // optional int32 idleTimeout = 1;
  bool has_idletimeout() const;
  private:
  bool _internal_has_idletimeout() const;
  public:
  void clear_idletimeout();
  ::PROTOBUF_NAMESPACE_ID::int32 idletimeout() const;
  void set_idletimeout(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_idletimeout() const;
  void _internal_set_idletimeout(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 maximum = 2;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  ::PROTOBUF_NAMESPACE_ID::int32 maximum() const;
  void set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maximum() const;
  void _internal_set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 idletimeout_;
  ::PROTOBUF_NAMESPACE_ID::int32 maximum_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPRouter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter) */ {
 public:
  inline BGPRouter() : BGPRouter(nullptr) {}
  ~BGPRouter() override;
  explicit constexpr BGPRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPRouter(const BGPRouter& from);
  BGPRouter(BGPRouter&& from) noexcept
    : BGPRouter() {
    *this = ::std::move(from);
  }

  inline BGPRouter& operator=(const BGPRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPRouter& operator=(BGPRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPRouter* internal_default_instance() {
    return reinterpret_cast<const BGPRouter*>(
               &_BGPRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BGPRouter& a, BGPRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPRouter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPRouter* New() const final {
    return new BGPRouter();
  }

  BGPRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPRouter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPRouter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPRouter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPRouter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter";
  }
  protected:
  explicit BGPRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPRouterList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList) */ {
 public:
  inline BGPRouterList() : BGPRouterList(nullptr) {}
  ~BGPRouterList() override;
  explicit constexpr BGPRouterList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPRouterList(const BGPRouterList& from);
  BGPRouterList(BGPRouterList&& from) noexcept
    : BGPRouterList() {
    *this = ::std::move(from);
  }

  inline BGPRouterList& operator=(const BGPRouterList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPRouterList& operator=(BGPRouterList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPRouterList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPRouterList* internal_default_instance() {
    return reinterpret_cast<const BGPRouterList*>(
               &_BGPRouterList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(BGPRouterList& a, BGPRouterList& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPRouterList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPRouterList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPRouterList* New() const final {
    return new BGPRouterList();
  }

  BGPRouterList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPRouterList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPRouterList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPRouterList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPRouterList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList";
  }
  protected:
  explicit BGPRouterList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPRouterParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters) */ {
 public:
  inline BGPRouterParameters() : BGPRouterParameters(nullptr) {}
  ~BGPRouterParameters() override;
  explicit constexpr BGPRouterParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPRouterParameters(const BGPRouterParameters& from);
  BGPRouterParameters(BGPRouterParameters&& from) noexcept
    : BGPRouterParameters() {
    *this = ::std::move(from);
  }

  inline BGPRouterParameters& operator=(const BGPRouterParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPRouterParameters& operator=(BGPRouterParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPRouterParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPRouterParameters* internal_default_instance() {
    return reinterpret_cast<const BGPRouterParameters*>(
               &_BGPRouterParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BGPRouterParameters& a, BGPRouterParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPRouterParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPRouterParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPRouterParameters* New() const final {
    return new BGPRouterParameters();
  }

  BGPRouterParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPRouterParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPRouterParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPRouterParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPRouterParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters";
  }
  protected:
  explicit BGPRouterParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorFieldNumber = 2,
    kIdentifierFieldNumber = 5,
    kAddressFieldNumber = 6,
    kRouterTypeFieldNumber = 13,
    kGatewayAddressFieldNumber = 14,
    kIpv6GatewayAddressFieldNumber = 15,
    kAddressFamiliesFieldNumber = 10,
    kAuthDataFieldNumber = 11,
    kAdminDownFieldNumber = 1,
    kAutonomousSystemFieldNumber = 4,
    kClusterIDFieldNumber = 3,
    kPortFieldNumber = 7,
    kSourcePortFieldNumber = 8,
    kHoldTimeFieldNumber = 9,
    kLocalAutonomousSystemFieldNumber = 12,
  };
  // optional string vendor = 2;
  bool has_vendor() const;
  private:
  bool _internal_has_vendor() const;
  public:
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_MUST_USE_RESULT std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // optional string identifier = 5;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_MUST_USE_RESULT std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string address = 6;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string routerType = 13;
  bool has_routertype() const;
  private:
  bool _internal_has_routertype() const;
  public:
  void clear_routertype();
  const std::string& routertype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_routertype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_routertype();
  PROTOBUF_MUST_USE_RESULT std::string* release_routertype();
  void set_allocated_routertype(std::string* routertype);
  private:
  const std::string& _internal_routertype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_routertype(const std::string& value);
  std::string* _internal_mutable_routertype();
  public:

  // optional string gatewayAddress = 14;
  bool has_gatewayaddress() const;
  private:
  bool _internal_has_gatewayaddress() const;
  public:
  void clear_gatewayaddress();
  const std::string& gatewayaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gatewayaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gatewayaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_gatewayaddress();
  void set_allocated_gatewayaddress(std::string* gatewayaddress);
  private:
  const std::string& _internal_gatewayaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gatewayaddress(const std::string& value);
  std::string* _internal_mutable_gatewayaddress();
  public:

  // optional string ipv6GatewayAddress = 15;
  bool has_ipv6gatewayaddress() const;
  private:
  bool _internal_has_ipv6gatewayaddress() const;
  public:
  void clear_ipv6gatewayaddress();
  const std::string& ipv6gatewayaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipv6gatewayaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipv6gatewayaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_ipv6gatewayaddress();
  void set_allocated_ipv6gatewayaddress(std::string* ipv6gatewayaddress);
  private:
  const std::string& _internal_ipv6gatewayaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipv6gatewayaddress(const std::string& value);
  std::string* _internal_mutable_ipv6gatewayaddress();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies addressFamilies = 10;
  bool has_addressfamilies() const;
  private:
  bool _internal_has_addressfamilies() const;
  public:
  void clear_addressfamilies();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies& addressfamilies() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* release_addressfamilies();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* mutable_addressfamilies();
  void set_allocated_addressfamilies(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies& _internal_addressfamilies() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* _internal_mutable_addressfamilies();
  public:
  void unsafe_arena_set_allocated_addressfamilies(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* unsafe_arena_release_addressfamilies();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData authData = 11;
  bool has_authdata() const;
  private:
  bool _internal_has_authdata() const;
  public:
  void clear_authdata();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData& authdata() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* release_authdata();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* mutable_authdata();
  void set_allocated_authdata(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData& _internal_authdata() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* _internal_mutable_authdata();
  public:
  void unsafe_arena_set_allocated_authdata(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* unsafe_arena_release_authdata();

  // optional bool adminDown = 1;
  bool has_admindown() const;
  private:
  bool _internal_has_admindown() const;
  public:
  void clear_admindown();
  bool admindown() const;
  void set_admindown(bool value);
  private:
  bool _internal_admindown() const;
  void _internal_set_admindown(bool value);
  public:

  // optional int32 autonomousSystem = 4;
  bool has_autonomoussystem() const;
  private:
  bool _internal_has_autonomoussystem() const;
  public:
  void clear_autonomoussystem();
  ::PROTOBUF_NAMESPACE_ID::int32 autonomoussystem() const;
  void set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_autonomoussystem() const;
  void _internal_set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 clusterID = 3;
  bool has_clusterid() const;
  private:
  bool _internal_has_clusterid() const;
  public:
  void clear_clusterid();
  ::PROTOBUF_NAMESPACE_ID::int64 clusterid() const;
  void set_clusterid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_clusterid() const;
  void _internal_set_clusterid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 port = 7;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 sourcePort = 8;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  ::PROTOBUF_NAMESPACE_ID::int32 sourceport() const;
  void set_sourceport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sourceport() const;
  void _internal_set_sourceport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 holdTime = 9;
  bool has_holdtime() const;
  private:
  bool _internal_has_holdtime() const;
  public:
  void clear_holdtime();
  ::PROTOBUF_NAMESPACE_ID::int32 holdtime() const;
  void set_holdtime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_holdtime() const;
  void _internal_set_holdtime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 localAutonomousSystem = 12;
  bool has_localautonomoussystem() const;
  private:
  bool _internal_has_localautonomoussystem() const;
  public:
  void clear_localautonomoussystem();
  ::PROTOBUF_NAMESPACE_ID::int32 localautonomoussystem() const;
  void set_localautonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_localautonomoussystem() const;
  void _internal_set_localautonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr routertype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gatewayaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv6gatewayaddress_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata_;
  bool admindown_;
  ::PROTOBUF_NAMESPACE_ID::int32 autonomoussystem_;
  ::PROTOBUF_NAMESPACE_ID::int64 clusterid_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  ::PROTOBUF_NAMESPACE_ID::int32 sourceport_;
  ::PROTOBUF_NAMESPACE_ID::int32 holdtime_;
  ::PROTOBUF_NAMESPACE_ID::int32 localautonomoussystem_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPRouterReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference) */ {
 public:
  inline BGPRouterReference() : BGPRouterReference(nullptr) {}
  ~BGPRouterReference() override;
  explicit constexpr BGPRouterReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPRouterReference(const BGPRouterReference& from);
  BGPRouterReference(BGPRouterReference&& from) noexcept
    : BGPRouterReference() {
    *this = ::std::move(from);
  }

  inline BGPRouterReference& operator=(const BGPRouterReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPRouterReference& operator=(BGPRouterReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPRouterReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPRouterReference* internal_default_instance() {
    return reinterpret_cast<const BGPRouterReference*>(
               &_BGPRouterReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(BGPRouterReference& a, BGPRouterReference& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPRouterReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPRouterReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPRouterReference* New() const final {
    return new BGPRouterReference();
  }

  BGPRouterReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPRouterReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPRouterReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPRouterReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPRouterReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference";
  }
  protected:
  explicit BGPRouterReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceReferenceFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
  bool has_resourcereference() const;
  private:
  bool _internal_has_resourcereference() const;
  public:
  void clear_resourcereference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& resourcereference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_resourcereference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_resourcereference();
  void set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_resourcereference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_resourcereference();
  public:
  void unsafe_arena_set_allocated_resourcereference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_resourcereference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes attributes = 2;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes& attributes() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* release_attributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* mutable_attributes();
  void set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* attributes);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes& _internal_attributes() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* attributes);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* attributes_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPRouterReferenceAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes) */ {
 public:
  inline BGPRouterReferenceAttributes() : BGPRouterReferenceAttributes(nullptr) {}
  ~BGPRouterReferenceAttributes() override;
  explicit constexpr BGPRouterReferenceAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPRouterReferenceAttributes(const BGPRouterReferenceAttributes& from);
  BGPRouterReferenceAttributes(BGPRouterReferenceAttributes&& from) noexcept
    : BGPRouterReferenceAttributes() {
    *this = ::std::move(from);
  }

  inline BGPRouterReferenceAttributes& operator=(const BGPRouterReferenceAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPRouterReferenceAttributes& operator=(BGPRouterReferenceAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPRouterReferenceAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPRouterReferenceAttributes* internal_default_instance() {
    return reinterpret_cast<const BGPRouterReferenceAttributes*>(
               &_BGPRouterReferenceAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(BGPRouterReferenceAttributes& a, BGPRouterReferenceAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPRouterReferenceAttributes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPRouterReferenceAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPRouterReferenceAttributes* New() const final {
    return new BGPRouterReferenceAttributes();
  }

  BGPRouterReferenceAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPRouterReferenceAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPRouterReferenceAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPRouterReferenceAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPRouterReferenceAttributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes";
  }
  protected:
  explicit BGPRouterReferenceAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession session = 1;
  int session_size() const;
  private:
  int _internal_session_size() const;
  public:
  void clear_session();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession* mutable_session(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession >*
      mutable_session();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession& _internal_session(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession* _internal_add_session();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession& session(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession* add_session();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession >&
      session() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession > session_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPRouterSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec) */ {
 public:
  inline BGPRouterSpec() : BGPRouterSpec(nullptr) {}
  ~BGPRouterSpec() override;
  explicit constexpr BGPRouterSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPRouterSpec(const BGPRouterSpec& from);
  BGPRouterSpec(BGPRouterSpec&& from) noexcept
    : BGPRouterSpec() {
    *this = ::std::move(from);
  }

  inline BGPRouterSpec& operator=(const BGPRouterSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPRouterSpec& operator=(BGPRouterSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPRouterSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPRouterSpec* internal_default_instance() {
    return reinterpret_cast<const BGPRouterSpec*>(
               &_BGPRouterSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(BGPRouterSpec& a, BGPRouterSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPRouterSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPRouterSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPRouterSpec* New() const final {
    return new BGPRouterSpec();
  }

  BGPRouterSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPRouterSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPRouterSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPRouterSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPRouterSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec";
  }
  protected:
  explicit BGPRouterSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBgpRouterReferencesFieldNumber = 4,
    kCommonSpecFieldNumber = 1,
    kParentFieldNumber = 2,
    kBgpRouterParametersFieldNumber = 3,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference bgpRouterReferences = 4;
  int bgprouterreferences_size() const;
  private:
  int _internal_bgprouterreferences_size() const;
  public:
  void clear_bgprouterreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* mutable_bgprouterreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference >*
      mutable_bgprouterreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference& _internal_bgprouterreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* _internal_add_bgprouterreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference& bgprouterreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* add_bgprouterreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference >&
      bgprouterreferences() const;

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .k8s.io.api.core.v1.ObjectReference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::k8s::io::api::core::v1::ObjectReference& parent() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::api::core::v1::ObjectReference* release_parent();
  ::k8s::io::api::core::v1::ObjectReference* mutable_parent();
  void set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent);
  private:
  const ::k8s::io::api::core::v1::ObjectReference& _internal_parent() const;
  ::k8s::io::api::core::v1::ObjectReference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::k8s::io::api::core::v1::ObjectReference* parent);
  ::k8s::io::api::core::v1::ObjectReference* unsafe_arena_release_parent();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters bgpRouterParameters = 3;
  bool has_bgprouterparameters() const;
  private:
  bool _internal_has_bgprouterparameters() const;
  public:
  void clear_bgprouterparameters();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters& bgprouterparameters() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* release_bgprouterparameters();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* mutable_bgprouterparameters();
  void set_allocated_bgprouterparameters(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* bgprouterparameters);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters& _internal_bgprouterparameters() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* _internal_mutable_bgprouterparameters();
  public:
  void unsafe_arena_set_allocated_bgprouterparameters(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* bgprouterparameters);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* unsafe_arena_release_bgprouterparameters();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference > bgprouterreferences_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::k8s::io::api::core::v1::ObjectReference* parent_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* bgprouterparameters_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPRouterStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus) */ {
 public:
  inline BGPRouterStatus() : BGPRouterStatus(nullptr) {}
  ~BGPRouterStatus() override;
  explicit constexpr BGPRouterStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPRouterStatus(const BGPRouterStatus& from);
  BGPRouterStatus(BGPRouterStatus&& from) noexcept
    : BGPRouterStatus() {
    *this = ::std::move(from);
  }

  inline BGPRouterStatus& operator=(const BGPRouterStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPRouterStatus& operator=(BGPRouterStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPRouterStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPRouterStatus* internal_default_instance() {
    return reinterpret_cast<const BGPRouterStatus*>(
               &_BGPRouterStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(BGPRouterStatus& a, BGPRouterStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPRouterStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPRouterStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPRouterStatus* New() const final {
    return new BGPRouterStatus();
  }

  BGPRouterStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPRouterStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPRouterStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPRouterStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPRouterStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus";
  }
  protected:
  explicit BGPRouterStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPSession final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession) */ {
 public:
  inline BGPSession() : BGPSession(nullptr) {}
  ~BGPSession() override;
  explicit constexpr BGPSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPSession(const BGPSession& from);
  BGPSession(BGPSession&& from) noexcept
    : BGPSession() {
    *this = ::std::move(from);
  }

  inline BGPSession& operator=(const BGPSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPSession& operator=(BGPSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPSession* internal_default_instance() {
    return reinterpret_cast<const BGPSession*>(
               &_BGPSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(BGPSession& a, BGPSession& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPSession* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPSession* New() const final {
    return new BGPSession();
  }

  BGPSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPSession>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPSession& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPSession& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession";
  }
  protected:
  explicit BGPSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionAttributesFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes sessionAttributes = 1;
  int sessionattributes_size() const;
  private:
  int _internal_sessionattributes_size() const;
  public:
  void clear_sessionattributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* mutable_sessionattributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes >*
      mutable_sessionattributes();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes& _internal_sessionattributes(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* _internal_add_sessionattributes();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes& sessionattributes(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* add_sessionattributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes >&
      sessionattributes() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes > sessionattributes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPSessionAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes) */ {
 public:
  inline BGPSessionAttributes() : BGPSessionAttributes(nullptr) {}
  ~BGPSessionAttributes() override;
  explicit constexpr BGPSessionAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPSessionAttributes(const BGPSessionAttributes& from);
  BGPSessionAttributes(BGPSessionAttributes&& from) noexcept
    : BGPSessionAttributes() {
    *this = ::std::move(from);
  }

  inline BGPSessionAttributes& operator=(const BGPSessionAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPSessionAttributes& operator=(BGPSessionAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPSessionAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPSessionAttributes* internal_default_instance() {
    return reinterpret_cast<const BGPSessionAttributes*>(
               &_BGPSessionAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(BGPSessionAttributes& a, BGPSessionAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPSessionAttributes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPSessionAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPSessionAttributes* New() const final {
    return new BGPSessionAttributes();
  }

  BGPSessionAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPSessionAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPSessionAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPSessionAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPSessionAttributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes";
  }
  protected:
  explicit BGPSessionAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyAttributesFieldNumber = 10,
    kBgpRouterFieldNumber = 1,
    kPrivateAsActionFieldNumber = 11,
    kAddressFamiliesFieldNumber = 8,
    kAuthDataFieldNumber = 9,
    kRouteOriginOverrideFieldNumber = 12,
    kAdminDownFieldNumber = 2,
    kPassiveFieldNumber = 3,
    kAsOverrideFieldNumber = 4,
    kHoldTimeFieldNumber = 5,
    kLoopCountFieldNumber = 6,
    kLocalAutonomousSystemFieldNumber = 7,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes familyAttributes = 10;
  int familyattributes_size() const;
  private:
  int _internal_familyattributes_size() const;
  public:
  void clear_familyattributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes* mutable_familyattributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes >*
      mutable_familyattributes();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes& _internal_familyattributes(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes* _internal_add_familyattributes();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes& familyattributes(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes* add_familyattributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes >&
      familyattributes() const;

  // optional string bgpRouter = 1;
  bool has_bgprouter() const;
  private:
  bool _internal_has_bgprouter() const;
  public:
  void clear_bgprouter();
  const std::string& bgprouter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bgprouter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bgprouter();
  PROTOBUF_MUST_USE_RESULT std::string* release_bgprouter();
  void set_allocated_bgprouter(std::string* bgprouter);
  private:
  const std::string& _internal_bgprouter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bgprouter(const std::string& value);
  std::string* _internal_mutable_bgprouter();
  public:

  // optional string privateAsAction = 11;
  bool has_privateasaction() const;
  private:
  bool _internal_has_privateasaction() const;
  public:
  void clear_privateasaction();
  const std::string& privateasaction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privateasaction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privateasaction();
  PROTOBUF_MUST_USE_RESULT std::string* release_privateasaction();
  void set_allocated_privateasaction(std::string* privateasaction);
  private:
  const std::string& _internal_privateasaction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privateasaction(const std::string& value);
  std::string* _internal_mutable_privateasaction();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies addressFamilies = 8;
  bool has_addressfamilies() const;
  private:
  bool _internal_has_addressfamilies() const;
  public:
  void clear_addressfamilies();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies& addressfamilies() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* release_addressfamilies();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* mutable_addressfamilies();
  void set_allocated_addressfamilies(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies& _internal_addressfamilies() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* _internal_mutable_addressfamilies();
  public:
  void unsafe_arena_set_allocated_addressfamilies(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* unsafe_arena_release_addressfamilies();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData authData = 9;
  bool has_authdata() const;
  private:
  bool _internal_has_authdata() const;
  public:
  void clear_authdata();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData& authdata() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* release_authdata();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* mutable_authdata();
  void set_allocated_authdata(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData& _internal_authdata() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* _internal_mutable_authdata();
  public:
  void unsafe_arena_set_allocated_authdata(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* unsafe_arena_release_authdata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride routeOriginOverride = 12;
  bool has_routeoriginoverride() const;
  private:
  bool _internal_has_routeoriginoverride() const;
  public:
  void clear_routeoriginoverride();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride& routeoriginoverride() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* release_routeoriginoverride();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* mutable_routeoriginoverride();
  void set_allocated_routeoriginoverride(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* routeoriginoverride);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride& _internal_routeoriginoverride() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* _internal_mutable_routeoriginoverride();
  public:
  void unsafe_arena_set_allocated_routeoriginoverride(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* routeoriginoverride);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* unsafe_arena_release_routeoriginoverride();

  // optional bool adminDown = 2;
  bool has_admindown() const;
  private:
  bool _internal_has_admindown() const;
  public:
  void clear_admindown();
  bool admindown() const;
  void set_admindown(bool value);
  private:
  bool _internal_admindown() const;
  void _internal_set_admindown(bool value);
  public:

  // optional bool passive = 3;
  bool has_passive() const;
  private:
  bool _internal_has_passive() const;
  public:
  void clear_passive();
  bool passive() const;
  void set_passive(bool value);
  private:
  bool _internal_passive() const;
  void _internal_set_passive(bool value);
  public:

  // optional bool asOverride = 4;
  bool has_asoverride() const;
  private:
  bool _internal_has_asoverride() const;
  public:
  void clear_asoverride();
  bool asoverride() const;
  void set_asoverride(bool value);
  private:
  bool _internal_asoverride() const;
  void _internal_set_asoverride(bool value);
  public:

  // optional int32 holdTime = 5;
  bool has_holdtime() const;
  private:
  bool _internal_has_holdtime() const;
  public:
  void clear_holdtime();
  ::PROTOBUF_NAMESPACE_ID::int32 holdtime() const;
  void set_holdtime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_holdtime() const;
  void _internal_set_holdtime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 loopCount = 6;
  bool has_loopcount() const;
  private:
  bool _internal_has_loopcount() const;
  public:
  void clear_loopcount();
  ::PROTOBUF_NAMESPACE_ID::int32 loopcount() const;
  void set_loopcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_loopcount() const;
  void _internal_set_loopcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 localAutonomousSystem = 7;
  bool has_localautonomoussystem() const;
  private:
  bool _internal_has_localautonomoussystem() const;
  public:
  void clear_localautonomoussystem();
  ::PROTOBUF_NAMESPACE_ID::int32 localautonomoussystem() const;
  void set_localautonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_localautonomoussystem() const;
  void _internal_set_localautonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes > familyattributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bgprouter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privateasaction_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* routeoriginoverride_;
  bool admindown_;
  bool passive_;
  bool asoverride_;
  ::PROTOBUF_NAMESPACE_ID::int32 holdtime_;
  ::PROTOBUF_NAMESPACE_ID::int32 loopcount_;
  ::PROTOBUF_NAMESPACE_ID::int32 localautonomoussystem_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class BGPSessionIPAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes) */ {
 public:
  inline BGPSessionIPAttributes() : BGPSessionIPAttributes(nullptr) {}
  ~BGPSessionIPAttributes() override;
  explicit constexpr BGPSessionIPAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPSessionIPAttributes(const BGPSessionIPAttributes& from);
  BGPSessionIPAttributes(BGPSessionIPAttributes&& from) noexcept
    : BGPSessionIPAttributes() {
    *this = ::std::move(from);
  }

  inline BGPSessionIPAttributes& operator=(const BGPSessionIPAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPSessionIPAttributes& operator=(BGPSessionIPAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPSessionIPAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPSessionIPAttributes* internal_default_instance() {
    return reinterpret_cast<const BGPSessionIPAttributes*>(
               &_BGPSessionIPAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(BGPSessionIPAttributes& a, BGPSessionIPAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPSessionIPAttributes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPSessionIPAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGPSessionIPAttributes* New() const final {
    return new BGPSessionIPAttributes();
  }

  BGPSessionIPAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGPSessionIPAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPSessionIPAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPSessionIPAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPSessionIPAttributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes";
  }
  protected:
  explicit BGPSessionIPAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBgpaasPrimaryIPFieldNumber = 1,
    kBgpaasSecondaryIPFieldNumber = 2,
  };
  // optional string bgpaasPrimaryIP = 1;
  bool has_bgpaasprimaryip() const;
  private:
  bool _internal_has_bgpaasprimaryip() const;
  public:
  void clear_bgpaasprimaryip();
  const std::string& bgpaasprimaryip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bgpaasprimaryip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bgpaasprimaryip();
  PROTOBUF_MUST_USE_RESULT std::string* release_bgpaasprimaryip();
  void set_allocated_bgpaasprimaryip(std::string* bgpaasprimaryip);
  private:
  const std::string& _internal_bgpaasprimaryip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bgpaasprimaryip(const std::string& value);
  std::string* _internal_mutable_bgpaasprimaryip();
  public:

  // optional string bgpaasSecondaryIP = 2;
  bool has_bgpaassecondaryip() const;
  private:
  bool _internal_has_bgpaassecondaryip() const;
  public:
  void clear_bgpaassecondaryip();
  const std::string& bgpaassecondaryip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bgpaassecondaryip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bgpaassecondaryip();
  PROTOBUF_MUST_USE_RESULT std::string* release_bgpaassecondaryip();
  void set_allocated_bgpaassecondaryip(std::string* bgpaassecondaryip);
  private:
  const std::string& _internal_bgpaassecondaryip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bgpaassecondaryip(const std::string& value);
  std::string* _internal_mutable_bgpaassecondaryip();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bgpaasprimaryip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bgpaassecondaryip_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class CommonSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec) */ {
 public:
  inline CommonSpec() : CommonSpec(nullptr) {}
  ~CommonSpec() override;
  explicit constexpr CommonSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonSpec(const CommonSpec& from);
  CommonSpec(CommonSpec&& from) noexcept
    : CommonSpec() {
    *this = ::std::move(from);
  }

  inline CommonSpec& operator=(const CommonSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonSpec& operator=(CommonSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonSpec* internal_default_instance() {
    return reinterpret_cast<const CommonSpec*>(
               &_CommonSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CommonSpec& a, CommonSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommonSpec* New() const final {
    return new CommonSpec();
  }

  CommonSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommonSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec";
  }
  protected:
  explicit CommonSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContrailFqNameFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName contrailFqName = 1;
  bool has_contrailfqname() const;
  private:
  bool _internal_has_contrailfqname() const;
  public:
  void clear_contrailfqname();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName& contrailfqname() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* release_contrailfqname();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* mutable_contrailfqname();
  void set_allocated_contrailfqname(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName& _internal_contrailfqname() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* _internal_mutable_contrailfqname();
  public:
  void unsafe_arena_set_allocated_contrailfqname(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* unsafe_arena_release_contrailfqname();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class CommonStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus) */ {
 public:
  inline CommonStatus() : CommonStatus(nullptr) {}
  ~CommonStatus() override;
  explicit constexpr CommonStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonStatus(const CommonStatus& from);
  CommonStatus(CommonStatus&& from) noexcept
    : CommonStatus() {
    *this = ::std::move(from);
  }

  inline CommonStatus& operator=(const CommonStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonStatus& operator=(CommonStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonStatus* internal_default_instance() {
    return reinterpret_cast<const CommonStatus*>(
               &_CommonStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CommonStatus& a, CommonStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommonStatus* New() const final {
    return new CommonStatus();
  }

  CommonStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommonStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus";
  }
  protected:
  explicit CommonStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReconcilerStateFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState reconcilerState = 1;
  bool has_reconcilerstate() const;
  private:
  bool _internal_has_reconcilerstate() const;
  public:
  void clear_reconcilerstate();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState& reconcilerstate() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* release_reconcilerstate();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* mutable_reconcilerstate();
  void set_allocated_reconcilerstate(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* reconcilerstate);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState& _internal_reconcilerstate() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* _internal_mutable_reconcilerstate();
  public:
  void unsafe_arena_set_allocated_reconcilerstate(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* reconcilerstate);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* unsafe_arena_release_reconcilerstate();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* reconcilerstate_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ContrailFqName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName) */ {
 public:
  inline ContrailFqName() : ContrailFqName(nullptr) {}
  ~ContrailFqName() override;
  explicit constexpr ContrailFqName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContrailFqName(const ContrailFqName& from);
  ContrailFqName(ContrailFqName&& from) noexcept
    : ContrailFqName() {
    *this = ::std::move(from);
  }

  inline ContrailFqName& operator=(const ContrailFqName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContrailFqName& operator=(ContrailFqName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContrailFqName& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContrailFqName* internal_default_instance() {
    return reinterpret_cast<const ContrailFqName*>(
               &_ContrailFqName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ContrailFqName& a, ContrailFqName& b) {
    a.Swap(&b);
  }
  inline void Swap(ContrailFqName* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContrailFqName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContrailFqName* New() const final {
    return new ContrailFqName();
  }

  ContrailFqName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContrailFqName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContrailFqName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContrailFqName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContrailFqName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName";
  }
  protected:
  explicit ContrailFqName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFqNameFieldNumber = 1,
  };
  // repeated string fqName = 1;
  int fqname_size() const;
  private:
  int _internal_fqname_size() const;
  public:
  void clear_fqname();
  const std::string& fqname(int index) const;
  std::string* mutable_fqname(int index);
  void set_fqname(int index, const std::string& value);
  void set_fqname(int index, std::string&& value);
  void set_fqname(int index, const char* value);
  void set_fqname(int index, const char* value, size_t size);
  std::string* add_fqname();
  void add_fqname(const std::string& value);
  void add_fqname(std::string&& value);
  void add_fqname(const char* value);
  void add_fqname(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fqname() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fqname();
  private:
  const std::string& _internal_fqname(int index) const;
  std::string* _internal_add_fqname();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fqname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class EncapsulationPriorities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities) */ {
 public:
  inline EncapsulationPriorities() : EncapsulationPriorities(nullptr) {}
  ~EncapsulationPriorities() override;
  explicit constexpr EncapsulationPriorities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncapsulationPriorities(const EncapsulationPriorities& from);
  EncapsulationPriorities(EncapsulationPriorities&& from) noexcept
    : EncapsulationPriorities() {
    *this = ::std::move(from);
  }

  inline EncapsulationPriorities& operator=(const EncapsulationPriorities& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncapsulationPriorities& operator=(EncapsulationPriorities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncapsulationPriorities& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncapsulationPriorities* internal_default_instance() {
    return reinterpret_cast<const EncapsulationPriorities*>(
               &_EncapsulationPriorities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(EncapsulationPriorities& a, EncapsulationPriorities& b) {
    a.Swap(&b);
  }
  inline void Swap(EncapsulationPriorities* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncapsulationPriorities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EncapsulationPriorities* New() const final {
    return new EncapsulationPriorities();
  }

  EncapsulationPriorities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EncapsulationPriorities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncapsulationPriorities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EncapsulationPriorities& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncapsulationPriorities* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities";
  }
  protected:
  explicit EncapsulationPriorities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncapsulationFieldNumber = 1,
  };
  // repeated string encapsulation = 1;
  int encapsulation_size() const;
  private:
  int _internal_encapsulation_size() const;
  public:
  void clear_encapsulation();
  const std::string& encapsulation(int index) const;
  std::string* mutable_encapsulation(int index);
  void set_encapsulation(int index, const std::string& value);
  void set_encapsulation(int index, std::string&& value);
  void set_encapsulation(int index, const char* value);
  void set_encapsulation(int index, const char* value, size_t size);
  std::string* add_encapsulation();
  void add_encapsulation(const std::string& value);
  void add_encapsulation(std::string&& value);
  void add_encapsulation(const char* value);
  void add_encapsulation(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& encapsulation() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_encapsulation();
  private:
  const std::string& _internal_encapsulation(int index) const;
  std::string* _internal_add_encapsulation();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> encapsulation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallActionListType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType) */ {
 public:
  inline FirewallActionListType() : FirewallActionListType(nullptr) {}
  ~FirewallActionListType() override;
  explicit constexpr FirewallActionListType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallActionListType(const FirewallActionListType& from);
  FirewallActionListType(FirewallActionListType&& from) noexcept
    : FirewallActionListType() {
    *this = ::std::move(from);
  }

  inline FirewallActionListType& operator=(const FirewallActionListType& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallActionListType& operator=(FirewallActionListType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallActionListType& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallActionListType* internal_default_instance() {
    return reinterpret_cast<const FirewallActionListType*>(
               &_FirewallActionListType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(FirewallActionListType& a, FirewallActionListType& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallActionListType* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallActionListType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallActionListType* New() const final {
    return new FirewallActionListType();
  }

  FirewallActionListType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallActionListType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallActionListType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallActionListType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallActionListType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType";
  }
  protected:
  explicit FirewallActionListType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimpleActionFieldNumber = 1,
  };
  // optional string simpleAction = 1;
  bool has_simpleaction() const;
  private:
  bool _internal_has_simpleaction() const;
  public:
  void clear_simpleaction();
  const std::string& simpleaction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simpleaction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simpleaction();
  PROTOBUF_MUST_USE_RESULT std::string* release_simpleaction();
  void set_allocated_simpleaction(std::string* simpleaction);
  private:
  const std::string& _internal_simpleaction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simpleaction(const std::string& value);
  std::string* _internal_mutable_simpleaction();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simpleaction_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy) */ {
 public:
  inline FirewallPolicy() : FirewallPolicy(nullptr) {}
  ~FirewallPolicy() override;
  explicit constexpr FirewallPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallPolicy(const FirewallPolicy& from);
  FirewallPolicy(FirewallPolicy&& from) noexcept
    : FirewallPolicy() {
    *this = ::std::move(from);
  }

  inline FirewallPolicy& operator=(const FirewallPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallPolicy& operator=(FirewallPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallPolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallPolicy* internal_default_instance() {
    return reinterpret_cast<const FirewallPolicy*>(
               &_FirewallPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(FirewallPolicy& a, FirewallPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallPolicy* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallPolicy* New() const final {
    return new FirewallPolicy();
  }

  FirewallPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallPolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallPolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallPolicy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallPolicy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy";
  }
  protected:
  explicit FirewallPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallPolicyAttribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute) */ {
 public:
  inline FirewallPolicyAttribute() : FirewallPolicyAttribute(nullptr) {}
  ~FirewallPolicyAttribute() override;
  explicit constexpr FirewallPolicyAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallPolicyAttribute(const FirewallPolicyAttribute& from);
  FirewallPolicyAttribute(FirewallPolicyAttribute&& from) noexcept
    : FirewallPolicyAttribute() {
    *this = ::std::move(from);
  }

  inline FirewallPolicyAttribute& operator=(const FirewallPolicyAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallPolicyAttribute& operator=(FirewallPolicyAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallPolicyAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallPolicyAttribute* internal_default_instance() {
    return reinterpret_cast<const FirewallPolicyAttribute*>(
               &_FirewallPolicyAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(FirewallPolicyAttribute& a, FirewallPolicyAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallPolicyAttribute* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallPolicyAttribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallPolicyAttribute* New() const final {
    return new FirewallPolicyAttribute();
  }

  FirewallPolicyAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallPolicyAttribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallPolicyAttribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallPolicyAttribute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallPolicyAttribute* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute";
  }
  protected:
  explicit FirewallPolicyAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 1,
  };
  // optional string sequence = 1;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;
  public:
  void clear_sequence();
  const std::string& sequence() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence();
  PROTOBUF_MUST_USE_RESULT std::string* release_sequence();
  void set_allocated_sequence(std::string* sequence);
  private:
  const std::string& _internal_sequence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence(const std::string& value);
  std::string* _internal_mutable_sequence();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallPolicyList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList) */ {
 public:
  inline FirewallPolicyList() : FirewallPolicyList(nullptr) {}
  ~FirewallPolicyList() override;
  explicit constexpr FirewallPolicyList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallPolicyList(const FirewallPolicyList& from);
  FirewallPolicyList(FirewallPolicyList&& from) noexcept
    : FirewallPolicyList() {
    *this = ::std::move(from);
  }

  inline FirewallPolicyList& operator=(const FirewallPolicyList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallPolicyList& operator=(FirewallPolicyList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallPolicyList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallPolicyList* internal_default_instance() {
    return reinterpret_cast<const FirewallPolicyList*>(
               &_FirewallPolicyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FirewallPolicyList& a, FirewallPolicyList& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallPolicyList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallPolicyList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallPolicyList* New() const final {
    return new FirewallPolicyList();
  }

  FirewallPolicyList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallPolicyList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallPolicyList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallPolicyList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallPolicyList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList";
  }
  protected:
  explicit FirewallPolicyList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallPolicyReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference) */ {
 public:
  inline FirewallPolicyReference() : FirewallPolicyReference(nullptr) {}
  ~FirewallPolicyReference() override;
  explicit constexpr FirewallPolicyReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallPolicyReference(const FirewallPolicyReference& from);
  FirewallPolicyReference(FirewallPolicyReference&& from) noexcept
    : FirewallPolicyReference() {
    *this = ::std::move(from);
  }

  inline FirewallPolicyReference& operator=(const FirewallPolicyReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallPolicyReference& operator=(FirewallPolicyReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallPolicyReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallPolicyReference* internal_default_instance() {
    return reinterpret_cast<const FirewallPolicyReference*>(
               &_FirewallPolicyReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(FirewallPolicyReference& a, FirewallPolicyReference& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallPolicyReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallPolicyReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallPolicyReference* New() const final {
    return new FirewallPolicyReference();
  }

  FirewallPolicyReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallPolicyReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallPolicyReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallPolicyReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallPolicyReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference";
  }
  protected:
  explicit FirewallPolicyReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceReferenceFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
  bool has_resourcereference() const;
  private:
  bool _internal_has_resourcereference() const;
  public:
  void clear_resourcereference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& resourcereference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_resourcereference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_resourcereference();
  void set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_resourcereference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_resourcereference();
  public:
  void unsafe_arena_set_allocated_resourcereference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_resourcereference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute attributes = 2;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute& attributes() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* release_attributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* mutable_attributes();
  void set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* attributes);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute& _internal_attributes() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* attributes);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* attributes_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallPolicySpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec) */ {
 public:
  inline FirewallPolicySpec() : FirewallPolicySpec(nullptr) {}
  ~FirewallPolicySpec() override;
  explicit constexpr FirewallPolicySpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallPolicySpec(const FirewallPolicySpec& from);
  FirewallPolicySpec(FirewallPolicySpec&& from) noexcept
    : FirewallPolicySpec() {
    *this = ::std::move(from);
  }

  inline FirewallPolicySpec& operator=(const FirewallPolicySpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallPolicySpec& operator=(FirewallPolicySpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallPolicySpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallPolicySpec* internal_default_instance() {
    return reinterpret_cast<const FirewallPolicySpec*>(
               &_FirewallPolicySpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(FirewallPolicySpec& a, FirewallPolicySpec& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallPolicySpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallPolicySpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallPolicySpec* New() const final {
    return new FirewallPolicySpec();
  }

  FirewallPolicySpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallPolicySpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallPolicySpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallPolicySpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallPolicySpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec";
  }
  protected:
  explicit FirewallPolicySpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirewallRuleFieldNumber = 3,
    kCommonSpecFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference firewallRule = 3;
  int firewallrule_size() const;
  private:
  int _internal_firewallrule_size() const;
  public:
  void clear_firewallrule();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference* mutable_firewallrule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference >*
      mutable_firewallrule();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference& _internal_firewallrule(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference* _internal_add_firewallrule();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference& firewallrule(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference* add_firewallrule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference >&
      firewallrule() const;

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference > firewallrule_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallPolicyStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus) */ {
 public:
  inline FirewallPolicyStatus() : FirewallPolicyStatus(nullptr) {}
  ~FirewallPolicyStatus() override;
  explicit constexpr FirewallPolicyStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallPolicyStatus(const FirewallPolicyStatus& from);
  FirewallPolicyStatus(FirewallPolicyStatus&& from) noexcept
    : FirewallPolicyStatus() {
    *this = ::std::move(from);
  }

  inline FirewallPolicyStatus& operator=(const FirewallPolicyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallPolicyStatus& operator=(FirewallPolicyStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallPolicyStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallPolicyStatus* internal_default_instance() {
    return reinterpret_cast<const FirewallPolicyStatus*>(
               &_FirewallPolicyStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(FirewallPolicyStatus& a, FirewallPolicyStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallPolicyStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallPolicyStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallPolicyStatus* New() const final {
    return new FirewallPolicyStatus();
  }

  FirewallPolicyStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallPolicyStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallPolicyStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallPolicyStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallPolicyStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus";
  }
  protected:
  explicit FirewallPolicyStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule) */ {
 public:
  inline FirewallRule() : FirewallRule(nullptr) {}
  ~FirewallRule() override;
  explicit constexpr FirewallRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallRule(const FirewallRule& from);
  FirewallRule(FirewallRule&& from) noexcept
    : FirewallRule() {
    *this = ::std::move(from);
  }

  inline FirewallRule& operator=(const FirewallRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallRule& operator=(FirewallRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallRule* internal_default_instance() {
    return reinterpret_cast<const FirewallRule*>(
               &_FirewallRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(FirewallRule& a, FirewallRule& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallRule* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallRule* New() const final {
    return new FirewallRule();
  }

  FirewallRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallRule& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallRule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule";
  }
  protected:
  explicit FirewallRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallRuleEndpointType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType) */ {
 public:
  inline FirewallRuleEndpointType() : FirewallRuleEndpointType(nullptr) {}
  ~FirewallRuleEndpointType() override;
  explicit constexpr FirewallRuleEndpointType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallRuleEndpointType(const FirewallRuleEndpointType& from);
  FirewallRuleEndpointType(FirewallRuleEndpointType&& from) noexcept
    : FirewallRuleEndpointType() {
    *this = ::std::move(from);
  }

  inline FirewallRuleEndpointType& operator=(const FirewallRuleEndpointType& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallRuleEndpointType& operator=(FirewallRuleEndpointType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallRuleEndpointType& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallRuleEndpointType* internal_default_instance() {
    return reinterpret_cast<const FirewallRuleEndpointType*>(
               &_FirewallRuleEndpointType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(FirewallRuleEndpointType& a, FirewallRuleEndpointType& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallRuleEndpointType* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallRuleEndpointType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallRuleEndpointType* New() const final {
    return new FirewallRuleEndpointType();
  }

  FirewallRuleEndpointType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallRuleEndpointType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallRuleEndpointType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallRuleEndpointType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallRuleEndpointType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType";
  }
  protected:
  explicit FirewallRuleEndpointType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 4,
    kTagIdsFieldNumber = 5,
    kAddressGroupFieldNumber = 3,
    kSubnetFieldNumber = 1,
    kAnyFieldNumber = 6,
  };
  // repeated string tags = 4;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // repeated int64 tagIds = 5;
  int tagids_size() const;
  private:
  int _internal_tagids_size() const;
  public:
  void clear_tagids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tagids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_tagids() const;
  void _internal_add_tagids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_tagids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 tagids(int index) const;
  void set_tagids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_tagids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      tagids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_tagids();

  // optional string addressGroup = 3;
  bool has_addressgroup() const;
  private:
  bool _internal_has_addressgroup() const;
  public:
  void clear_addressgroup();
  const std::string& addressgroup() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addressgroup(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addressgroup();
  PROTOBUF_MUST_USE_RESULT std::string* release_addressgroup();
  void set_allocated_addressgroup(std::string* addressgroup);
  private:
  const std::string& _internal_addressgroup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addressgroup(const std::string& value);
  std::string* _internal_mutable_addressgroup();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet subnet = 1;
  bool has_subnet() const;
  private:
  bool _internal_has_subnet() const;
  public:
  void clear_subnet();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet& subnet() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* release_subnet();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* mutable_subnet();
  void set_allocated_subnet(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* subnet);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet& _internal_subnet() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* _internal_mutable_subnet();
  public:
  void unsafe_arena_set_allocated_subnet(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* subnet);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* unsafe_arena_release_subnet();

  // optional bool any = 6;
  bool has_any() const;
  private:
  bool _internal_has_any() const;
  public:
  void clear_any();
  bool any() const;
  void set_any(bool value);
  private:
  bool _internal_any() const;
  void _internal_set_any(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > tagids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addressgroup_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* subnet_;
  bool any_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallRuleList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList) */ {
 public:
  inline FirewallRuleList() : FirewallRuleList(nullptr) {}
  ~FirewallRuleList() override;
  explicit constexpr FirewallRuleList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallRuleList(const FirewallRuleList& from);
  FirewallRuleList(FirewallRuleList&& from) noexcept
    : FirewallRuleList() {
    *this = ::std::move(from);
  }

  inline FirewallRuleList& operator=(const FirewallRuleList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallRuleList& operator=(FirewallRuleList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallRuleList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallRuleList* internal_default_instance() {
    return reinterpret_cast<const FirewallRuleList*>(
               &_FirewallRuleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(FirewallRuleList& a, FirewallRuleList& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallRuleList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallRuleList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallRuleList* New() const final {
    return new FirewallRuleList();
  }

  FirewallRuleList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallRuleList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallRuleList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallRuleList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallRuleList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList";
  }
  protected:
  explicit FirewallRuleList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallRuleReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference) */ {
 public:
  inline FirewallRuleReference() : FirewallRuleReference(nullptr) {}
  ~FirewallRuleReference() override;
  explicit constexpr FirewallRuleReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallRuleReference(const FirewallRuleReference& from);
  FirewallRuleReference(FirewallRuleReference&& from) noexcept
    : FirewallRuleReference() {
    *this = ::std::move(from);
  }

  inline FirewallRuleReference& operator=(const FirewallRuleReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallRuleReference& operator=(FirewallRuleReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallRuleReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallRuleReference* internal_default_instance() {
    return reinterpret_cast<const FirewallRuleReference*>(
               &_FirewallRuleReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(FirewallRuleReference& a, FirewallRuleReference& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallRuleReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallRuleReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallRuleReference* New() const final {
    return new FirewallRuleReference();
  }

  FirewallRuleReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallRuleReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallRuleReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallRuleReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallRuleReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference";
  }
  protected:
  explicit FirewallRuleReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceReferenceFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
  bool has_resourcereference() const;
  private:
  bool _internal_has_resourcereference() const;
  public:
  void clear_resourcereference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& resourcereference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_resourcereference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_resourcereference();
  void set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_resourcereference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_resourcereference();
  public:
  void unsafe_arena_set_allocated_resourcereference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_resourcereference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute attributes = 2;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute& attributes() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* release_attributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* mutable_attributes();
  void set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* attributes);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute& _internal_attributes() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* attributes);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* attributes_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallRuleSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec) */ {
 public:
  inline FirewallRuleSpec() : FirewallRuleSpec(nullptr) {}
  ~FirewallRuleSpec() override;
  explicit constexpr FirewallRuleSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallRuleSpec(const FirewallRuleSpec& from);
  FirewallRuleSpec(FirewallRuleSpec&& from) noexcept
    : FirewallRuleSpec() {
    *this = ::std::move(from);
  }

  inline FirewallRuleSpec& operator=(const FirewallRuleSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallRuleSpec& operator=(FirewallRuleSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallRuleSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallRuleSpec* internal_default_instance() {
    return reinterpret_cast<const FirewallRuleSpec*>(
               &_FirewallRuleSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(FirewallRuleSpec& a, FirewallRuleSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallRuleSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallRuleSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallRuleSpec* New() const final {
    return new FirewallRuleSpec();
  }

  FirewallRuleSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallRuleSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallRuleSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallRuleSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallRuleSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec";
  }
  protected:
  explicit FirewallRuleSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchTagsFieldNumber = 7,
    kMatchTagsTypesFieldNumber = 8,
    kTagReferencesFieldNumber = 10,
    kDirectionFieldNumber = 9,
    kCommonSpecFieldNumber = 1,
    kAddressGroupReferenceFieldNumber = 2,
    kActionListFieldNumber = 3,
    kServiceFieldNumber = 4,
    kEndpoint1FieldNumber = 5,
    kEndpoint2FieldNumber = 6,
  };
  // repeated string matchTags = 7;
  int matchtags_size() const;
  private:
  int _internal_matchtags_size() const;
  public:
  void clear_matchtags();
  const std::string& matchtags(int index) const;
  std::string* mutable_matchtags(int index);
  void set_matchtags(int index, const std::string& value);
  void set_matchtags(int index, std::string&& value);
  void set_matchtags(int index, const char* value);
  void set_matchtags(int index, const char* value, size_t size);
  std::string* add_matchtags();
  void add_matchtags(const std::string& value);
  void add_matchtags(std::string&& value);
  void add_matchtags(const char* value);
  void add_matchtags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& matchtags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_matchtags();
  private:
  const std::string& _internal_matchtags(int index) const;
  std::string* _internal_add_matchtags();
  public:

  // repeated int64 matchTagsTypes = 8;
  int matchtagstypes_size() const;
  private:
  int _internal_matchtagstypes_size() const;
  public:
  void clear_matchtagstypes();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_matchtagstypes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_matchtagstypes() const;
  void _internal_add_matchtagstypes(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_matchtagstypes();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 matchtagstypes(int index) const;
  void set_matchtagstypes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_matchtagstypes(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      matchtagstypes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_matchtagstypes();

  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 10;
  int tagreferences_size() const;
  private:
  int _internal_tagreferences_size() const;
  public:
  void clear_tagreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_tagreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_tagreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_tagreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_tagreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& tagreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_tagreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      tagreferences() const;

  // optional string direction = 9;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const std::string& direction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_direction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_direction();
  PROTOBUF_MUST_USE_RESULT std::string* release_direction();
  void set_allocated_direction(std::string* direction);
  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(const std::string& value);
  std::string* _internal_mutable_direction();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference addressGroupReference = 2;
  bool has_addressgroupreference() const;
  private:
  bool _internal_has_addressgroupreference() const;
  public:
  void clear_addressgroupreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& addressgroupreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_addressgroupreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_addressgroupreference();
  void set_allocated_addressgroupreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* addressgroupreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_addressgroupreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_addressgroupreference();
  public:
  void unsafe_arena_set_allocated_addressgroupreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* addressgroupreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_addressgroupreference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType actionList = 3;
  bool has_actionlist() const;
  private:
  bool _internal_has_actionlist() const;
  public:
  void clear_actionlist();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType& actionlist() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* release_actionlist();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* mutable_actionlist();
  void set_allocated_actionlist(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* actionlist);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType& _internal_actionlist() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* _internal_mutable_actionlist();
  public:
  void unsafe_arena_set_allocated_actionlist(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* actionlist);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* unsafe_arena_release_actionlist();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType service = 4;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType& service() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* release_service();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* mutable_service();
  void set_allocated_service(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* service);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType& _internal_service() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* service);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* unsafe_arena_release_service();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType Endpoint1 = 5;
  bool has_endpoint1() const;
  private:
  bool _internal_has_endpoint1() const;
  public:
  void clear_endpoint1();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType& endpoint1() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* release_endpoint1();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* mutable_endpoint1();
  void set_allocated_endpoint1(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint1);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType& _internal_endpoint1() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* _internal_mutable_endpoint1();
  public:
  void unsafe_arena_set_allocated_endpoint1(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint1);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* unsafe_arena_release_endpoint1();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType Endpoint2 = 6;
  bool has_endpoint2() const;
  private:
  bool _internal_has_endpoint2() const;
  public:
  void clear_endpoint2();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType& endpoint2() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* release_endpoint2();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* mutable_endpoint2();
  void set_allocated_endpoint2(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint2);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType& _internal_endpoint2() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* _internal_mutable_endpoint2();
  public:
  void unsafe_arena_set_allocated_endpoint2(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint2);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* unsafe_arena_release_endpoint2();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> matchtags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > matchtagstypes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > tagreferences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* addressgroupreference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* actionlist_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* service_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint1_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint2_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallRuleStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus) */ {
 public:
  inline FirewallRuleStatus() : FirewallRuleStatus(nullptr) {}
  ~FirewallRuleStatus() override;
  explicit constexpr FirewallRuleStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallRuleStatus(const FirewallRuleStatus& from);
  FirewallRuleStatus(FirewallRuleStatus&& from) noexcept
    : FirewallRuleStatus() {
    *this = ::std::move(from);
  }

  inline FirewallRuleStatus& operator=(const FirewallRuleStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallRuleStatus& operator=(FirewallRuleStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallRuleStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallRuleStatus* internal_default_instance() {
    return reinterpret_cast<const FirewallRuleStatus*>(
               &_FirewallRuleStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(FirewallRuleStatus& a, FirewallRuleStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallRuleStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallRuleStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallRuleStatus* New() const final {
    return new FirewallRuleStatus();
  }

  FirewallRuleStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallRuleStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallRuleStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallRuleStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallRuleStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus";
  }
  protected:
  explicit FirewallRuleStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallServiceType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType) */ {
 public:
  inline FirewallServiceType() : FirewallServiceType(nullptr) {}
  ~FirewallServiceType() override;
  explicit constexpr FirewallServiceType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallServiceType(const FirewallServiceType& from);
  FirewallServiceType(FirewallServiceType&& from) noexcept
    : FirewallServiceType() {
    *this = ::std::move(from);
  }

  inline FirewallServiceType& operator=(const FirewallServiceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallServiceType& operator=(FirewallServiceType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallServiceType& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallServiceType* internal_default_instance() {
    return reinterpret_cast<const FirewallServiceType*>(
               &_FirewallServiceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(FirewallServiceType& a, FirewallServiceType& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallServiceType* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallServiceType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallServiceType* New() const final {
    return new FirewallServiceType();
  }

  FirewallServiceType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallServiceType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallServiceType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallServiceType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallServiceType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType";
  }
  protected:
  explicit FirewallServiceType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolFieldNumber = 1,
    kSourcePortsFieldNumber = 3,
    kDestinationPortsFieldNumber = 4,
    kProtocolIdFieldNumber = 2,
  };
  // optional string protocol = 1;
  bool has_protocol() const;
  private:
  bool _internal_has_protocol() const;
  public:
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_MUST_USE_RESULT std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType sourcePorts = 3;
  bool has_sourceports() const;
  private:
  bool _internal_has_sourceports() const;
  public:
  void clear_sourceports();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType& sourceports() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* release_sourceports();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* mutable_sourceports();
  void set_allocated_sourceports(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* sourceports);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType& _internal_sourceports() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* _internal_mutable_sourceports();
  public:
  void unsafe_arena_set_allocated_sourceports(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* sourceports);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* unsafe_arena_release_sourceports();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType destinationPorts = 4;
  bool has_destinationports() const;
  private:
  bool _internal_has_destinationports() const;
  public:
  void clear_destinationports();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType& destinationports() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* release_destinationports();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* mutable_destinationports();
  void set_allocated_destinationports(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* destinationports);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType& _internal_destinationports() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* _internal_mutable_destinationports();
  public:
  void unsafe_arena_set_allocated_destinationports(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* destinationports);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* unsafe_arena_release_destinationports();

  // optional int64 protocolId = 2;
  bool has_protocolid() const;
  private:
  bool _internal_has_protocolid() const;
  public:
  void clear_protocolid();
  ::PROTOBUF_NAMESPACE_ID::int64 protocolid() const;
  void set_protocolid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_protocolid() const;
  void _internal_set_protocolid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* sourceports_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* destinationports_;
  ::PROTOBUF_NAMESPACE_ID::int64 protocolid_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FirewallSubnet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet) */ {
 public:
  inline FirewallSubnet() : FirewallSubnet(nullptr) {}
  ~FirewallSubnet() override;
  explicit constexpr FirewallSubnet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirewallSubnet(const FirewallSubnet& from);
  FirewallSubnet(FirewallSubnet&& from) noexcept
    : FirewallSubnet() {
    *this = ::std::move(from);
  }

  inline FirewallSubnet& operator=(const FirewallSubnet& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirewallSubnet& operator=(FirewallSubnet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirewallSubnet& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirewallSubnet* internal_default_instance() {
    return reinterpret_cast<const FirewallSubnet*>(
               &_FirewallSubnet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(FirewallSubnet& a, FirewallSubnet& b) {
    a.Swap(&b);
  }
  inline void Swap(FirewallSubnet* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirewallSubnet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirewallSubnet* New() const final {
    return new FirewallSubnet();
  }

  FirewallSubnet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirewallSubnet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirewallSubnet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FirewallSubnet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirewallSubnet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet";
  }
  protected:
  explicit FirewallSubnet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpPrefixFieldNumber = 1,
    kIpPrefixLenFieldNumber = 2,
  };
  // optional string ipPrefix = 1;
  bool has_ipprefix() const;
  private:
  bool _internal_has_ipprefix() const;
  public:
  void clear_ipprefix();
  const std::string& ipprefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipprefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipprefix();
  PROTOBUF_MUST_USE_RESULT std::string* release_ipprefix();
  void set_allocated_ipprefix(std::string* ipprefix);
  private:
  const std::string& _internal_ipprefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipprefix(const std::string& value);
  std::string* _internal_mutable_ipprefix();
  public:

  // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString ipPrefixLen = 2;
  bool has_ipprefixlen() const;
  private:
  bool _internal_has_ipprefixlen() const;
  public:
  void clear_ipprefixlen();
  const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& ipprefixlen() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* release_ipprefixlen();
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* mutable_ipprefixlen();
  void set_allocated_ipprefixlen(::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen);
  private:
  const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& _internal_ipprefixlen() const;
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* _internal_mutable_ipprefixlen();
  public:
  void unsafe_arena_set_allocated_ipprefixlen(
      ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen);
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* unsafe_arena_release_ipprefixlen();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipprefix_;
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FloatingIP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP) */ {
 public:
  inline FloatingIP() : FloatingIP(nullptr) {}
  ~FloatingIP() override;
  explicit constexpr FloatingIP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatingIP(const FloatingIP& from);
  FloatingIP(FloatingIP&& from) noexcept
    : FloatingIP() {
    *this = ::std::move(from);
  }

  inline FloatingIP& operator=(const FloatingIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatingIP& operator=(FloatingIP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatingIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatingIP* internal_default_instance() {
    return reinterpret_cast<const FloatingIP*>(
               &_FloatingIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(FloatingIP& a, FloatingIP& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatingIP* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatingIP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FloatingIP* New() const final {
    return new FloatingIP();
  }

  FloatingIP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FloatingIP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatingIP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FloatingIP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatingIP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP";
  }
  protected:
  explicit FloatingIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FloatingIPList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList) */ {
 public:
  inline FloatingIPList() : FloatingIPList(nullptr) {}
  ~FloatingIPList() override;
  explicit constexpr FloatingIPList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatingIPList(const FloatingIPList& from);
  FloatingIPList(FloatingIPList&& from) noexcept
    : FloatingIPList() {
    *this = ::std::move(from);
  }

  inline FloatingIPList& operator=(const FloatingIPList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatingIPList& operator=(FloatingIPList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatingIPList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatingIPList* internal_default_instance() {
    return reinterpret_cast<const FloatingIPList*>(
               &_FloatingIPList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(FloatingIPList& a, FloatingIPList& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatingIPList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatingIPList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FloatingIPList* New() const final {
    return new FloatingIPList();
  }

  FloatingIPList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FloatingIPList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatingIPList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FloatingIPList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatingIPList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList";
  }
  protected:
  explicit FloatingIPList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FloatingIPPortMappings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings) */ {
 public:
  inline FloatingIPPortMappings() : FloatingIPPortMappings(nullptr) {}
  ~FloatingIPPortMappings() override;
  explicit constexpr FloatingIPPortMappings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatingIPPortMappings(const FloatingIPPortMappings& from);
  FloatingIPPortMappings(FloatingIPPortMappings&& from) noexcept
    : FloatingIPPortMappings() {
    *this = ::std::move(from);
  }

  inline FloatingIPPortMappings& operator=(const FloatingIPPortMappings& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatingIPPortMappings& operator=(FloatingIPPortMappings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatingIPPortMappings& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatingIPPortMappings* internal_default_instance() {
    return reinterpret_cast<const FloatingIPPortMappings*>(
               &_FloatingIPPortMappings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(FloatingIPPortMappings& a, FloatingIPPortMappings& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatingIPPortMappings* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatingIPPortMappings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FloatingIPPortMappings* New() const final {
    return new FloatingIPPortMappings();
  }

  FloatingIPPortMappings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FloatingIPPortMappings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatingIPPortMappings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FloatingIPPortMappings& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatingIPPortMappings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings";
  }
  protected:
  explicit FloatingIPPortMappings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortMappingsFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping portMappings = 1;
  int portmappings_size() const;
  private:
  int _internal_portmappings_size() const;
  public:
  void clear_portmappings();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping* mutable_portmappings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping >*
      mutable_portmappings();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping& _internal_portmappings(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping* _internal_add_portmappings();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping& portmappings(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping* add_portmappings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping >&
      portmappings() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping > portmappings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FloatingIPPortPortMapping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping) */ {
 public:
  inline FloatingIPPortPortMapping() : FloatingIPPortPortMapping(nullptr) {}
  ~FloatingIPPortPortMapping() override;
  explicit constexpr FloatingIPPortPortMapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatingIPPortPortMapping(const FloatingIPPortPortMapping& from);
  FloatingIPPortPortMapping(FloatingIPPortPortMapping&& from) noexcept
    : FloatingIPPortPortMapping() {
    *this = ::std::move(from);
  }

  inline FloatingIPPortPortMapping& operator=(const FloatingIPPortPortMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatingIPPortPortMapping& operator=(FloatingIPPortPortMapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatingIPPortPortMapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatingIPPortPortMapping* internal_default_instance() {
    return reinterpret_cast<const FloatingIPPortPortMapping*>(
               &_FloatingIPPortPortMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(FloatingIPPortPortMapping& a, FloatingIPPortPortMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatingIPPortPortMapping* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatingIPPortPortMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FloatingIPPortPortMapping* New() const final {
    return new FloatingIPPortPortMapping();
  }

  FloatingIPPortPortMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FloatingIPPortPortMapping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatingIPPortPortMapping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FloatingIPPortPortMapping& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatingIPPortPortMapping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping";
  }
  protected:
  explicit FloatingIPPortPortMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolFieldNumber = 3,
    kSrcPortFieldNumber = 1,
    kDstPortFieldNumber = 2,
  };
  // optional string protocol = 3;
  bool has_protocol() const;
  private:
  bool _internal_has_protocol() const;
  public:
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_MUST_USE_RESULT std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // optional int32 srcPort = 1;
  bool has_srcport() const;
  private:
  bool _internal_has_srcport() const;
  public:
  void clear_srcport();
  ::PROTOBUF_NAMESPACE_ID::int32 srcport() const;
  void set_srcport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_srcport() const;
  void _internal_set_srcport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 dstPort = 2;
  bool has_dstport() const;
  private:
  bool _internal_has_dstport() const;
  public:
  void clear_dstport();
  ::PROTOBUF_NAMESPACE_ID::int32 dstport() const;
  void set_dstport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dstport() const;
  void _internal_set_dstport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
  ::PROTOBUF_NAMESPACE_ID::int32 srcport_;
  ::PROTOBUF_NAMESPACE_ID::int32 dstport_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FloatingIPSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec) */ {
 public:
  inline FloatingIPSpec() : FloatingIPSpec(nullptr) {}
  ~FloatingIPSpec() override;
  explicit constexpr FloatingIPSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatingIPSpec(const FloatingIPSpec& from);
  FloatingIPSpec(FloatingIPSpec&& from) noexcept
    : FloatingIPSpec() {
    *this = ::std::move(from);
  }

  inline FloatingIPSpec& operator=(const FloatingIPSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatingIPSpec& operator=(FloatingIPSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatingIPSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatingIPSpec* internal_default_instance() {
    return reinterpret_cast<const FloatingIPSpec*>(
               &_FloatingIPSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(FloatingIPSpec& a, FloatingIPSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatingIPSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatingIPSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FloatingIPSpec* New() const final {
    return new FloatingIPSpec();
  }

  FloatingIPSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FloatingIPSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatingIPSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FloatingIPSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatingIPSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec";
  }
  protected:
  explicit FloatingIPSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualMachineInterfaceReferencesFieldNumber = 7,
    kFloatingIPAddressFieldNumber = 2,
    kFloatingIPTrafficDirectionFieldNumber = 4,
    kCommonSpecFieldNumber = 1,
    kFloatingIPPortMappingsFieldNumber = 3,
    kParentFieldNumber = 5,
    kFloatingIPPortMappingsEnableFieldNumber = 8,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 7;
  int virtualmachineinterfacereferences_size() const;
  private:
  int _internal_virtualmachineinterfacereferences_size() const;
  public:
  void clear_virtualmachineinterfacereferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_virtualmachineinterfacereferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_virtualmachineinterfacereferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_virtualmachineinterfacereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_virtualmachineinterfacereferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& virtualmachineinterfacereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_virtualmachineinterfacereferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      virtualmachineinterfacereferences() const;

  // optional string floatingIPAddress = 2;
  bool has_floatingipaddress() const;
  private:
  bool _internal_has_floatingipaddress() const;
  public:
  void clear_floatingipaddress();
  const std::string& floatingipaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_floatingipaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_floatingipaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_floatingipaddress();
  void set_allocated_floatingipaddress(std::string* floatingipaddress);
  private:
  const std::string& _internal_floatingipaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_floatingipaddress(const std::string& value);
  std::string* _internal_mutable_floatingipaddress();
  public:

  // optional string floatingIPTrafficDirection = 4;
  bool has_floatingiptrafficdirection() const;
  private:
  bool _internal_has_floatingiptrafficdirection() const;
  public:
  void clear_floatingiptrafficdirection();
  const std::string& floatingiptrafficdirection() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_floatingiptrafficdirection(ArgT0&& arg0, ArgT... args);
  std::string* mutable_floatingiptrafficdirection();
  PROTOBUF_MUST_USE_RESULT std::string* release_floatingiptrafficdirection();
  void set_allocated_floatingiptrafficdirection(std::string* floatingiptrafficdirection);
  private:
  const std::string& _internal_floatingiptrafficdirection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_floatingiptrafficdirection(const std::string& value);
  std::string* _internal_mutable_floatingiptrafficdirection();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings floatingIPPortMappings = 3;
  bool has_floatingipportmappings() const;
  private:
  bool _internal_has_floatingipportmappings() const;
  public:
  void clear_floatingipportmappings();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings& floatingipportmappings() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* release_floatingipportmappings();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* mutable_floatingipportmappings();
  void set_allocated_floatingipportmappings(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* floatingipportmappings);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings& _internal_floatingipportmappings() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* _internal_mutable_floatingipportmappings();
  public:
  void unsafe_arena_set_allocated_floatingipportmappings(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* floatingipportmappings);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* unsafe_arena_release_floatingipportmappings();

  // optional .k8s.io.api.core.v1.ObjectReference parent = 5;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::k8s::io::api::core::v1::ObjectReference& parent() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::api::core::v1::ObjectReference* release_parent();
  ::k8s::io::api::core::v1::ObjectReference* mutable_parent();
  void set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent);
  private:
  const ::k8s::io::api::core::v1::ObjectReference& _internal_parent() const;
  ::k8s::io::api::core::v1::ObjectReference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::k8s::io::api::core::v1::ObjectReference* parent);
  ::k8s::io::api::core::v1::ObjectReference* unsafe_arena_release_parent();

  // optional bool floatingIPPortMappingsEnable = 8;
  bool has_floatingipportmappingsenable() const;
  private:
  bool _internal_has_floatingipportmappingsenable() const;
  public:
  void clear_floatingipportmappingsenable();
  bool floatingipportmappingsenable() const;
  void set_floatingipportmappingsenable(bool value);
  private:
  bool _internal_floatingipportmappingsenable() const;
  void _internal_set_floatingipportmappingsenable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > virtualmachineinterfacereferences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr floatingipaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr floatingiptrafficdirection_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* floatingipportmappings_;
  ::k8s::io::api::core::v1::ObjectReference* parent_;
  bool floatingipportmappingsenable_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FloatingIPStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus) */ {
 public:
  inline FloatingIPStatus() : FloatingIPStatus(nullptr) {}
  ~FloatingIPStatus() override;
  explicit constexpr FloatingIPStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatingIPStatus(const FloatingIPStatus& from);
  FloatingIPStatus(FloatingIPStatus&& from) noexcept
    : FloatingIPStatus() {
    *this = ::std::move(from);
  }

  inline FloatingIPStatus& operator=(const FloatingIPStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatingIPStatus& operator=(FloatingIPStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatingIPStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatingIPStatus* internal_default_instance() {
    return reinterpret_cast<const FloatingIPStatus*>(
               &_FloatingIPStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(FloatingIPStatus& a, FloatingIPStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatingIPStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatingIPStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FloatingIPStatus* New() const final {
    return new FloatingIPStatus();
  }

  FloatingIPStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FloatingIPStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatingIPStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FloatingIPStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatingIPStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus";
  }
  protected:
  explicit FloatingIPStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
    kSubnetReferenceFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference subnetReference = 2;
  bool has_subnetreference() const;
  private:
  bool _internal_has_subnetreference() const;
  public:
  void clear_subnetreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& subnetreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_subnetreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_subnetreference();
  void set_allocated_subnetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_subnetreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_subnetreference();
  public:
  void unsafe_arena_set_allocated_subnetreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_subnetreference();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GlobalSystemConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig) */ {
 public:
  inline GlobalSystemConfig() : GlobalSystemConfig(nullptr) {}
  ~GlobalSystemConfig() override;
  explicit constexpr GlobalSystemConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalSystemConfig(const GlobalSystemConfig& from);
  GlobalSystemConfig(GlobalSystemConfig&& from) noexcept
    : GlobalSystemConfig() {
    *this = ::std::move(from);
  }

  inline GlobalSystemConfig& operator=(const GlobalSystemConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalSystemConfig& operator=(GlobalSystemConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalSystemConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalSystemConfig* internal_default_instance() {
    return reinterpret_cast<const GlobalSystemConfig*>(
               &_GlobalSystemConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(GlobalSystemConfig& a, GlobalSystemConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalSystemConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalSystemConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalSystemConfig* New() const final {
    return new GlobalSystemConfig();
  }

  GlobalSystemConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalSystemConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalSystemConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlobalSystemConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalSystemConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig";
  }
  protected:
  explicit GlobalSystemConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GlobalSystemConfigList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList) */ {
 public:
  inline GlobalSystemConfigList() : GlobalSystemConfigList(nullptr) {}
  ~GlobalSystemConfigList() override;
  explicit constexpr GlobalSystemConfigList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalSystemConfigList(const GlobalSystemConfigList& from);
  GlobalSystemConfigList(GlobalSystemConfigList&& from) noexcept
    : GlobalSystemConfigList() {
    *this = ::std::move(from);
  }

  inline GlobalSystemConfigList& operator=(const GlobalSystemConfigList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalSystemConfigList& operator=(GlobalSystemConfigList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalSystemConfigList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalSystemConfigList* internal_default_instance() {
    return reinterpret_cast<const GlobalSystemConfigList*>(
               &_GlobalSystemConfigList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(GlobalSystemConfigList& a, GlobalSystemConfigList& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalSystemConfigList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalSystemConfigList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalSystemConfigList* New() const final {
    return new GlobalSystemConfigList();
  }

  GlobalSystemConfigList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalSystemConfigList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalSystemConfigList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlobalSystemConfigList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalSystemConfigList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList";
  }
  protected:
  explicit GlobalSystemConfigList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GlobalSystemConfigSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec) */ {
 public:
  inline GlobalSystemConfigSpec() : GlobalSystemConfigSpec(nullptr) {}
  ~GlobalSystemConfigSpec() override;
  explicit constexpr GlobalSystemConfigSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalSystemConfigSpec(const GlobalSystemConfigSpec& from);
  GlobalSystemConfigSpec(GlobalSystemConfigSpec&& from) noexcept
    : GlobalSystemConfigSpec() {
    *this = ::std::move(from);
  }

  inline GlobalSystemConfigSpec& operator=(const GlobalSystemConfigSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalSystemConfigSpec& operator=(GlobalSystemConfigSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalSystemConfigSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalSystemConfigSpec* internal_default_instance() {
    return reinterpret_cast<const GlobalSystemConfigSpec*>(
               &_GlobalSystemConfigSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(GlobalSystemConfigSpec& a, GlobalSystemConfigSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalSystemConfigSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalSystemConfigSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalSystemConfigSpec* New() const final {
    return new GlobalSystemConfigSpec();
  }

  GlobalSystemConfigSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalSystemConfigSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalSystemConfigSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlobalSystemConfigSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalSystemConfigSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec";
  }
  protected:
  explicit GlobalSystemConfigSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBgpRouterReferencesFieldNumber = 4,
    kCommonSpecFieldNumber = 1,
    kAutonomousSystemFieldNumber = 3,
    kEnable4BytesASFieldNumber = 2,
    kIbgpAutoMeshFieldNumber = 5,
    kDefaultEnableSNATFieldNumber = 6,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference bgpRouterReferences = 4;
  int bgprouterreferences_size() const;
  private:
  int _internal_bgprouterreferences_size() const;
  public:
  void clear_bgprouterreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_bgprouterreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_bgprouterreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_bgprouterreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_bgprouterreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& bgprouterreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_bgprouterreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      bgprouterreferences() const;

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional int32 autonomousSystem = 3;
  bool has_autonomoussystem() const;
  private:
  bool _internal_has_autonomoussystem() const;
  public:
  void clear_autonomoussystem();
  ::PROTOBUF_NAMESPACE_ID::int32 autonomoussystem() const;
  void set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_autonomoussystem() const;
  void _internal_set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool enable4bytesAS = 2;
  bool has_enable4bytesas() const;
  private:
  bool _internal_has_enable4bytesas() const;
  public:
  void clear_enable4bytesas();
  bool enable4bytesas() const;
  void set_enable4bytesas(bool value);
  private:
  bool _internal_enable4bytesas() const;
  void _internal_set_enable4bytesas(bool value);
  public:

  // optional bool ibgpAutoMesh = 5;
  bool has_ibgpautomesh() const;
  private:
  bool _internal_has_ibgpautomesh() const;
  public:
  void clear_ibgpautomesh();
  bool ibgpautomesh() const;
  void set_ibgpautomesh(bool value);
  private:
  bool _internal_ibgpautomesh() const;
  void _internal_set_ibgpautomesh(bool value);
  public:

  // optional bool defaultEnableSNAT = 6;
  bool has_defaultenablesnat() const;
  private:
  bool _internal_has_defaultenablesnat() const;
  public:
  void clear_defaultenablesnat();
  bool defaultenablesnat() const;
  void set_defaultenablesnat(bool value);
  private:
  bool _internal_defaultenablesnat() const;
  void _internal_set_defaultenablesnat(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > bgprouterreferences_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::PROTOBUF_NAMESPACE_ID::int32 autonomoussystem_;
  bool enable4bytesas_;
  bool ibgpautomesh_;
  bool defaultenablesnat_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GlobalSystemConfigStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus) */ {
 public:
  inline GlobalSystemConfigStatus() : GlobalSystemConfigStatus(nullptr) {}
  ~GlobalSystemConfigStatus() override;
  explicit constexpr GlobalSystemConfigStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalSystemConfigStatus(const GlobalSystemConfigStatus& from);
  GlobalSystemConfigStatus(GlobalSystemConfigStatus&& from) noexcept
    : GlobalSystemConfigStatus() {
    *this = ::std::move(from);
  }

  inline GlobalSystemConfigStatus& operator=(const GlobalSystemConfigStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalSystemConfigStatus& operator=(GlobalSystemConfigStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalSystemConfigStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalSystemConfigStatus* internal_default_instance() {
    return reinterpret_cast<const GlobalSystemConfigStatus*>(
               &_GlobalSystemConfigStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(GlobalSystemConfigStatus& a, GlobalSystemConfigStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalSystemConfigStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalSystemConfigStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalSystemConfigStatus* New() const final {
    return new GlobalSystemConfigStatus();
  }

  GlobalSystemConfigStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalSystemConfigStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalSystemConfigStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlobalSystemConfigStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalSystemConfigStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus";
  }
  protected:
  explicit GlobalSystemConfigStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GlobalVrouterConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig) */ {
 public:
  inline GlobalVrouterConfig() : GlobalVrouterConfig(nullptr) {}
  ~GlobalVrouterConfig() override;
  explicit constexpr GlobalVrouterConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalVrouterConfig(const GlobalVrouterConfig& from);
  GlobalVrouterConfig(GlobalVrouterConfig&& from) noexcept
    : GlobalVrouterConfig() {
    *this = ::std::move(from);
  }

  inline GlobalVrouterConfig& operator=(const GlobalVrouterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalVrouterConfig& operator=(GlobalVrouterConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalVrouterConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalVrouterConfig* internal_default_instance() {
    return reinterpret_cast<const GlobalVrouterConfig*>(
               &_GlobalVrouterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(GlobalVrouterConfig& a, GlobalVrouterConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalVrouterConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalVrouterConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalVrouterConfig* New() const final {
    return new GlobalVrouterConfig();
  }

  GlobalVrouterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalVrouterConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalVrouterConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlobalVrouterConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalVrouterConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig";
  }
  protected:
  explicit GlobalVrouterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GlobalVrouterConfigList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList) */ {
 public:
  inline GlobalVrouterConfigList() : GlobalVrouterConfigList(nullptr) {}
  ~GlobalVrouterConfigList() override;
  explicit constexpr GlobalVrouterConfigList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalVrouterConfigList(const GlobalVrouterConfigList& from);
  GlobalVrouterConfigList(GlobalVrouterConfigList&& from) noexcept
    : GlobalVrouterConfigList() {
    *this = ::std::move(from);
  }

  inline GlobalVrouterConfigList& operator=(const GlobalVrouterConfigList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalVrouterConfigList& operator=(GlobalVrouterConfigList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalVrouterConfigList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalVrouterConfigList* internal_default_instance() {
    return reinterpret_cast<const GlobalVrouterConfigList*>(
               &_GlobalVrouterConfigList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(GlobalVrouterConfigList& a, GlobalVrouterConfigList& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalVrouterConfigList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalVrouterConfigList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalVrouterConfigList* New() const final {
    return new GlobalVrouterConfigList();
  }

  GlobalVrouterConfigList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalVrouterConfigList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalVrouterConfigList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlobalVrouterConfigList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalVrouterConfigList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList";
  }
  protected:
  explicit GlobalVrouterConfigList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GlobalVrouterConfigSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec) */ {
 public:
  inline GlobalVrouterConfigSpec() : GlobalVrouterConfigSpec(nullptr) {}
  ~GlobalVrouterConfigSpec() override;
  explicit constexpr GlobalVrouterConfigSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalVrouterConfigSpec(const GlobalVrouterConfigSpec& from);
  GlobalVrouterConfigSpec(GlobalVrouterConfigSpec&& from) noexcept
    : GlobalVrouterConfigSpec() {
    *this = ::std::move(from);
  }

  inline GlobalVrouterConfigSpec& operator=(const GlobalVrouterConfigSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalVrouterConfigSpec& operator=(GlobalVrouterConfigSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalVrouterConfigSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalVrouterConfigSpec* internal_default_instance() {
    return reinterpret_cast<const GlobalVrouterConfigSpec*>(
               &_GlobalVrouterConfigSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(GlobalVrouterConfigSpec& a, GlobalVrouterConfigSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalVrouterConfigSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalVrouterConfigSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalVrouterConfigSpec* New() const final {
    return new GlobalVrouterConfigSpec();
  }

  GlobalVrouterConfigSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalVrouterConfigSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalVrouterConfigSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlobalVrouterConfigSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalVrouterConfigSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec";
  }
  protected:
  explicit GlobalVrouterConfigSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonSpecFieldNumber = 1,
    kParentFieldNumber = 2,
    kEncapsulationPrioritiesFieldNumber = 3,
    kLinklocalServicesFieldNumber = 4,
    kPortTranslationPoolsFieldNumber = 5,
    kFlowExportRateFieldNumber = 6,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .k8s.io.api.core.v1.ObjectReference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::k8s::io::api::core::v1::ObjectReference& parent() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::api::core::v1::ObjectReference* release_parent();
  ::k8s::io::api::core::v1::ObjectReference* mutable_parent();
  void set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent);
  private:
  const ::k8s::io::api::core::v1::ObjectReference& _internal_parent() const;
  ::k8s::io::api::core::v1::ObjectReference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::k8s::io::api::core::v1::ObjectReference* parent);
  ::k8s::io::api::core::v1::ObjectReference* unsafe_arena_release_parent();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities encapsulationPriorities = 3;
  bool has_encapsulationpriorities() const;
  private:
  bool _internal_has_encapsulationpriorities() const;
  public:
  void clear_encapsulationpriorities();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities& encapsulationpriorities() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* release_encapsulationpriorities();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* mutable_encapsulationpriorities();
  void set_allocated_encapsulationpriorities(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* encapsulationpriorities);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities& _internal_encapsulationpriorities() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* _internal_mutable_encapsulationpriorities();
  public:
  void unsafe_arena_set_allocated_encapsulationpriorities(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* encapsulationpriorities);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* unsafe_arena_release_encapsulationpriorities();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices linklocalServices = 4;
  bool has_linklocalservices() const;
  private:
  bool _internal_has_linklocalservices() const;
  public:
  void clear_linklocalservices();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices& linklocalservices() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* release_linklocalservices();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* mutable_linklocalservices();
  void set_allocated_linklocalservices(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* linklocalservices);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices& _internal_linklocalservices() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* _internal_mutable_linklocalservices();
  public:
  void unsafe_arena_set_allocated_linklocalservices(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* linklocalservices);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* unsafe_arena_release_linklocalservices();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools portTranslationPools = 5;
  bool has_porttranslationpools() const;
  private:
  bool _internal_has_porttranslationpools() const;
  public:
  void clear_porttranslationpools();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools& porttranslationpools() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* release_porttranslationpools();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* mutable_porttranslationpools();
  void set_allocated_porttranslationpools(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* porttranslationpools);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools& _internal_porttranslationpools() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* _internal_mutable_porttranslationpools();
  public:
  void unsafe_arena_set_allocated_porttranslationpools(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* porttranslationpools);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* unsafe_arena_release_porttranslationpools();

  // optional int32 flowExportRate = 6;
  bool has_flowexportrate() const;
  private:
  bool _internal_has_flowexportrate() const;
  public:
  void clear_flowexportrate();
  ::PROTOBUF_NAMESPACE_ID::int32 flowexportrate() const;
  void set_flowexportrate(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_flowexportrate() const;
  void _internal_set_flowexportrate(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::k8s::io::api::core::v1::ObjectReference* parent_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* encapsulationpriorities_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* linklocalservices_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* porttranslationpools_;
  ::PROTOBUF_NAMESPACE_ID::int32 flowexportrate_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GlobalVrouterConfigStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus) */ {
 public:
  inline GlobalVrouterConfigStatus() : GlobalVrouterConfigStatus(nullptr) {}
  ~GlobalVrouterConfigStatus() override;
  explicit constexpr GlobalVrouterConfigStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalVrouterConfigStatus(const GlobalVrouterConfigStatus& from);
  GlobalVrouterConfigStatus(GlobalVrouterConfigStatus&& from) noexcept
    : GlobalVrouterConfigStatus() {
    *this = ::std::move(from);
  }

  inline GlobalVrouterConfigStatus& operator=(const GlobalVrouterConfigStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalVrouterConfigStatus& operator=(GlobalVrouterConfigStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalVrouterConfigStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalVrouterConfigStatus* internal_default_instance() {
    return reinterpret_cast<const GlobalVrouterConfigStatus*>(
               &_GlobalVrouterConfigStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(GlobalVrouterConfigStatus& a, GlobalVrouterConfigStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalVrouterConfigStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalVrouterConfigStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalVrouterConfigStatus* New() const final {
    return new GlobalVrouterConfigStatus();
  }

  GlobalVrouterConfigStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalVrouterConfigStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalVrouterConfigStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlobalVrouterConfigStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalVrouterConfigStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus";
  }
  protected:
  explicit GlobalVrouterConfigStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class IPRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange) */ {
 public:
  inline IPRange() : IPRange(nullptr) {}
  ~IPRange() override;
  explicit constexpr IPRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPRange(const IPRange& from);
  IPRange(IPRange&& from) noexcept
    : IPRange() {
    *this = ::std::move(from);
  }

  inline IPRange& operator=(const IPRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPRange& operator=(IPRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPRange* internal_default_instance() {
    return reinterpret_cast<const IPRange*>(
               &_IPRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(IPRange& a, IPRange& b) {
    a.Swap(&b);
  }
  inline void Swap(IPRange* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IPRange* New() const final {
    return new IPRange();
  }

  IPRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IPRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange";
  }
  protected:
  explicit IPRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // optional string from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_MUST_USE_RESULT std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // optional string to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_MUST_USE_RESULT std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ImportVirtualNetworkRouter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter) */ {
 public:
  inline ImportVirtualNetworkRouter() : ImportVirtualNetworkRouter(nullptr) {}
  ~ImportVirtualNetworkRouter() override;
  explicit constexpr ImportVirtualNetworkRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImportVirtualNetworkRouter(const ImportVirtualNetworkRouter& from);
  ImportVirtualNetworkRouter(ImportVirtualNetworkRouter&& from) noexcept
    : ImportVirtualNetworkRouter() {
    *this = ::std::move(from);
  }

  inline ImportVirtualNetworkRouter& operator=(const ImportVirtualNetworkRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportVirtualNetworkRouter& operator=(ImportVirtualNetworkRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportVirtualNetworkRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportVirtualNetworkRouter* internal_default_instance() {
    return reinterpret_cast<const ImportVirtualNetworkRouter*>(
               &_ImportVirtualNetworkRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(ImportVirtualNetworkRouter& a, ImportVirtualNetworkRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportVirtualNetworkRouter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportVirtualNetworkRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImportVirtualNetworkRouter* New() const final {
    return new ImportVirtualNetworkRouter();
  }

  ImportVirtualNetworkRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImportVirtualNetworkRouter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImportVirtualNetworkRouter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImportVirtualNetworkRouter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportVirtualNetworkRouter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter";
  }
  protected:
  explicit ImportVirtualNetworkRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualNetworkRoutersFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry virtualNetworkRouters = 1;
  int virtualnetworkrouters_size() const;
  private:
  int _internal_virtualnetworkrouters_size() const;
  public:
  void clear_virtualnetworkrouters();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry* mutable_virtualnetworkrouters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry >*
      mutable_virtualnetworkrouters();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry& _internal_virtualnetworkrouters(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry* _internal_add_virtualnetworkrouters();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry& virtualnetworkrouters(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry* add_virtualnetworkrouters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry >&
      virtualnetworkrouters() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry > virtualnetworkrouters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class InstanceIP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP) */ {
 public:
  inline InstanceIP() : InstanceIP(nullptr) {}
  ~InstanceIP() override;
  explicit constexpr InstanceIP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceIP(const InstanceIP& from);
  InstanceIP(InstanceIP&& from) noexcept
    : InstanceIP() {
    *this = ::std::move(from);
  }

  inline InstanceIP& operator=(const InstanceIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceIP& operator=(InstanceIP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceIP* internal_default_instance() {
    return reinterpret_cast<const InstanceIP*>(
               &_InstanceIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(InstanceIP& a, InstanceIP& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceIP* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceIP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstanceIP* New() const final {
    return new InstanceIP();
  }

  InstanceIP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstanceIP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceIP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstanceIP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceIP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP";
  }
  protected:
  explicit InstanceIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class InstanceIPList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList) */ {
 public:
  inline InstanceIPList() : InstanceIPList(nullptr) {}
  ~InstanceIPList() override;
  explicit constexpr InstanceIPList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceIPList(const InstanceIPList& from);
  InstanceIPList(InstanceIPList&& from) noexcept
    : InstanceIPList() {
    *this = ::std::move(from);
  }

  inline InstanceIPList& operator=(const InstanceIPList& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceIPList& operator=(InstanceIPList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceIPList& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceIPList* internal_default_instance() {
    return reinterpret_cast<const InstanceIPList*>(
               &_InstanceIPList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(InstanceIPList& a, InstanceIPList& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceIPList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceIPList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstanceIPList* New() const final {
    return new InstanceIPList();
  }

  InstanceIPList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstanceIPList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceIPList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstanceIPList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceIPList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList";
  }
  protected:
  explicit InstanceIPList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class InstanceIPSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec) */ {
 public:
  inline InstanceIPSpec() : InstanceIPSpec(nullptr) {}
  ~InstanceIPSpec() override;
  explicit constexpr InstanceIPSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceIPSpec(const InstanceIPSpec& from);
  InstanceIPSpec(InstanceIPSpec&& from) noexcept
    : InstanceIPSpec() {
    *this = ::std::move(from);
  }

  inline InstanceIPSpec& operator=(const InstanceIPSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceIPSpec& operator=(InstanceIPSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceIPSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceIPSpec* internal_default_instance() {
    return reinterpret_cast<const InstanceIPSpec*>(
               &_InstanceIPSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(InstanceIPSpec& a, InstanceIPSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceIPSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceIPSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstanceIPSpec* New() const final {
    return new InstanceIPSpec();
  }

  InstanceIPSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstanceIPSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceIPSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstanceIPSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceIPSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec";
  }
  protected:
  explicit InstanceIPSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualMachineInterfaceReferencesFieldNumber = 6,
    kIpRangeKeysFieldNumber = 7,
    kInstanceIPAddressFieldNumber = 2,
    kInstanceIPFamilyFieldNumber = 3,
    kCidrFieldNumber = 4,
    kCommonSpecFieldNumber = 1,
    kVirtualNetworkReferenceFieldNumber = 5,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 6;
  int virtualmachineinterfacereferences_size() const;
  private:
  int _internal_virtualmachineinterfacereferences_size() const;
  public:
  void clear_virtualmachineinterfacereferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_virtualmachineinterfacereferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_virtualmachineinterfacereferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_virtualmachineinterfacereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_virtualmachineinterfacereferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& virtualmachineinterfacereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_virtualmachineinterfacereferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      virtualmachineinterfacereferences() const;

  // repeated string ipRangeKeys = 7;
  int iprangekeys_size() const;
  private:
  int _internal_iprangekeys_size() const;
  public:
  void clear_iprangekeys();
  const std::string& iprangekeys(int index) const;
  std::string* mutable_iprangekeys(int index);
  void set_iprangekeys(int index, const std::string& value);
  void set_iprangekeys(int index, std::string&& value);
  void set_iprangekeys(int index, const char* value);
  void set_iprangekeys(int index, const char* value, size_t size);
  std::string* add_iprangekeys();
  void add_iprangekeys(const std::string& value);
  void add_iprangekeys(std::string&& value);
  void add_iprangekeys(const char* value);
  void add_iprangekeys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& iprangekeys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_iprangekeys();
  private:
  const std::string& _internal_iprangekeys(int index) const;
  std::string* _internal_add_iprangekeys();
  public:

  // optional string instanceIPAddress = 2;
  bool has_instanceipaddress() const;
  private:
  bool _internal_has_instanceipaddress() const;
  public:
  void clear_instanceipaddress();
  const std::string& instanceipaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instanceipaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instanceipaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_instanceipaddress();
  void set_allocated_instanceipaddress(std::string* instanceipaddress);
  private:
  const std::string& _internal_instanceipaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instanceipaddress(const std::string& value);
  std::string* _internal_mutable_instanceipaddress();
  public:

  // optional string instanceIPFamily = 3;
  bool has_instanceipfamily() const;
  private:
  bool _internal_has_instanceipfamily() const;
  public:
  void clear_instanceipfamily();
  const std::string& instanceipfamily() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instanceipfamily(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instanceipfamily();
  PROTOBUF_MUST_USE_RESULT std::string* release_instanceipfamily();
  void set_allocated_instanceipfamily(std::string* instanceipfamily);
  private:
  const std::string& _internal_instanceipfamily() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instanceipfamily(const std::string& value);
  std::string* _internal_mutable_instanceipfamily();
  public:

  // optional string cidr = 4;
  bool has_cidr() const;
  private:
  bool _internal_has_cidr() const;
  public:
  void clear_cidr();
  const std::string& cidr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cidr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cidr();
  PROTOBUF_MUST_USE_RESULT std::string* release_cidr();
  void set_allocated_cidr(std::string* cidr);
  private:
  const std::string& _internal_cidr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cidr(const std::string& value);
  std::string* _internal_mutable_cidr();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualNetworkReference = 5;
  bool has_virtualnetworkreference() const;
  private:
  bool _internal_has_virtualnetworkreference() const;
  public:
  void clear_virtualnetworkreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& virtualnetworkreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_virtualnetworkreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_virtualnetworkreference();
  void set_allocated_virtualnetworkreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_virtualnetworkreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_virtualnetworkreference();
  public:
  void unsafe_arena_set_allocated_virtualnetworkreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_virtualnetworkreference();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > virtualmachineinterfacereferences_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> iprangekeys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instanceipaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instanceipfamily_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cidr_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class InstanceIPStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus) */ {
 public:
  inline InstanceIPStatus() : InstanceIPStatus(nullptr) {}
  ~InstanceIPStatus() override;
  explicit constexpr InstanceIPStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceIPStatus(const InstanceIPStatus& from);
  InstanceIPStatus(InstanceIPStatus&& from) noexcept
    : InstanceIPStatus() {
    *this = ::std::move(from);
  }

  inline InstanceIPStatus& operator=(const InstanceIPStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceIPStatus& operator=(InstanceIPStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceIPStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceIPStatus* internal_default_instance() {
    return reinterpret_cast<const InstanceIPStatus*>(
               &_InstanceIPStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(InstanceIPStatus& a, InstanceIPStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceIPStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceIPStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstanceIPStatus* New() const final {
    return new InstanceIPStatus();
  }

  InstanceIPStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstanceIPStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceIPStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstanceIPStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceIPStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus";
  }
  protected:
  explicit InstanceIPStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
    kSubnetReferenceFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference subnetReference = 2;
  bool has_subnetreference() const;
  private:
  bool _internal_has_subnetreference() const;
  public:
  void clear_subnetreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& subnetreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_subnetreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_subnetreference();
  void set_allocated_subnetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_subnetreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_subnetreference();
  public:
  void unsafe_arena_set_allocated_subnetreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_subnetreference();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class LinklocalServiceEntryType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType) */ {
 public:
  inline LinklocalServiceEntryType() : LinklocalServiceEntryType(nullptr) {}
  ~LinklocalServiceEntryType() override;
  explicit constexpr LinklocalServiceEntryType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinklocalServiceEntryType(const LinklocalServiceEntryType& from);
  LinklocalServiceEntryType(LinklocalServiceEntryType&& from) noexcept
    : LinklocalServiceEntryType() {
    *this = ::std::move(from);
  }

  inline LinklocalServiceEntryType& operator=(const LinklocalServiceEntryType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinklocalServiceEntryType& operator=(LinklocalServiceEntryType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinklocalServiceEntryType& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinklocalServiceEntryType* internal_default_instance() {
    return reinterpret_cast<const LinklocalServiceEntryType*>(
               &_LinklocalServiceEntryType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(LinklocalServiceEntryType& a, LinklocalServiceEntryType& b) {
    a.Swap(&b);
  }
  inline void Swap(LinklocalServiceEntryType* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinklocalServiceEntryType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinklocalServiceEntryType* New() const final {
    return new LinklocalServiceEntryType();
  }

  LinklocalServiceEntryType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinklocalServiceEntryType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinklocalServiceEntryType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinklocalServiceEntryType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinklocalServiceEntryType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType";
  }
  protected:
  explicit LinklocalServiceEntryType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFabricServiceIPFieldNumber = 2,
    kIpFabricDNSServiceNameFieldNumber = 1,
    kLinklocalServiceIPFieldNumber = 4,
    kLinklocalServiceNameFieldNumber = 5,
    kIpFabricServicePortFieldNumber = 3,
    kLinklocalServicePortFieldNumber = 6,
  };
  // repeated string ipFabricServiceIP = 2;
  int ipfabricserviceip_size() const;
  private:
  int _internal_ipfabricserviceip_size() const;
  public:
  void clear_ipfabricserviceip();
  const std::string& ipfabricserviceip(int index) const;
  std::string* mutable_ipfabricserviceip(int index);
  void set_ipfabricserviceip(int index, const std::string& value);
  void set_ipfabricserviceip(int index, std::string&& value);
  void set_ipfabricserviceip(int index, const char* value);
  void set_ipfabricserviceip(int index, const char* value, size_t size);
  std::string* add_ipfabricserviceip();
  void add_ipfabricserviceip(const std::string& value);
  void add_ipfabricserviceip(std::string&& value);
  void add_ipfabricserviceip(const char* value);
  void add_ipfabricserviceip(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ipfabricserviceip() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ipfabricserviceip();
  private:
  const std::string& _internal_ipfabricserviceip(int index) const;
  std::string* _internal_add_ipfabricserviceip();
  public:

  // optional string ipFabricDNSServiceName = 1;
  bool has_ipfabricdnsservicename() const;
  private:
  bool _internal_has_ipfabricdnsservicename() const;
  public:
  void clear_ipfabricdnsservicename();
  const std::string& ipfabricdnsservicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipfabricdnsservicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipfabricdnsservicename();
  PROTOBUF_MUST_USE_RESULT std::string* release_ipfabricdnsservicename();
  void set_allocated_ipfabricdnsservicename(std::string* ipfabricdnsservicename);
  private:
  const std::string& _internal_ipfabricdnsservicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipfabricdnsservicename(const std::string& value);
  std::string* _internal_mutable_ipfabricdnsservicename();
  public:

  // optional string linklocalServiceIP = 4;
  bool has_linklocalserviceip() const;
  private:
  bool _internal_has_linklocalserviceip() const;
  public:
  void clear_linklocalserviceip();
  const std::string& linklocalserviceip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linklocalserviceip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linklocalserviceip();
  PROTOBUF_MUST_USE_RESULT std::string* release_linklocalserviceip();
  void set_allocated_linklocalserviceip(std::string* linklocalserviceip);
  private:
  const std::string& _internal_linklocalserviceip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linklocalserviceip(const std::string& value);
  std::string* _internal_mutable_linklocalserviceip();
  public:

  // optional string linklocalServiceName = 5;
  bool has_linklocalservicename() const;
  private:
  bool _internal_has_linklocalservicename() const;
  public:
  void clear_linklocalservicename();
  const std::string& linklocalservicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linklocalservicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linklocalservicename();
  PROTOBUF_MUST_USE_RESULT std::string* release_linklocalservicename();
  void set_allocated_linklocalservicename(std::string* linklocalservicename);
  private:
  const std::string& _internal_linklocalservicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linklocalservicename(const std::string& value);
  std::string* _internal_mutable_linklocalservicename();
  public:

  // optional int32 ipFabricServicePort = 3;
  bool has_ipfabricserviceport() const;
  private:
  bool _internal_has_ipfabricserviceport() const;
  public:
  void clear_ipfabricserviceport();
  ::PROTOBUF_NAMESPACE_ID::int32 ipfabricserviceport() const;
  void set_ipfabricserviceport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ipfabricserviceport() const;
  void _internal_set_ipfabricserviceport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 linklocalServicePort = 6;
  bool has_linklocalserviceport() const;
  private:
  bool _internal_has_linklocalserviceport() const;
  public:
  void clear_linklocalserviceport();
  ::PROTOBUF_NAMESPACE_ID::int32 linklocalserviceport() const;
  void set_linklocalserviceport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_linklocalserviceport() const;
  void _internal_set_linklocalserviceport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ipfabricserviceip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipfabricdnsservicename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linklocalserviceip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linklocalservicename_;
  ::PROTOBUF_NAMESPACE_ID::int32 ipfabricserviceport_;
  ::PROTOBUF_NAMESPACE_ID::int32 linklocalserviceport_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class LinklocalServices final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices) */ {
 public:
  inline LinklocalServices() : LinklocalServices(nullptr) {}
  ~LinklocalServices() override;
  explicit constexpr LinklocalServices(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinklocalServices(const LinklocalServices& from);
  LinklocalServices(LinklocalServices&& from) noexcept
    : LinklocalServices() {
    *this = ::std::move(from);
  }

  inline LinklocalServices& operator=(const LinklocalServices& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinklocalServices& operator=(LinklocalServices&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinklocalServices& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinklocalServices* internal_default_instance() {
    return reinterpret_cast<const LinklocalServices*>(
               &_LinklocalServices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(LinklocalServices& a, LinklocalServices& b) {
    a.Swap(&b);
  }
  inline void Swap(LinklocalServices* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinklocalServices* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinklocalServices* New() const final {
    return new LinklocalServices();
  }

  LinklocalServices* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinklocalServices>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinklocalServices& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinklocalServices& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinklocalServices* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices";
  }
  protected:
  explicit LinklocalServices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinklocalServiceEntryFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType linklocalServiceEntry = 1;
  int linklocalserviceentry_size() const;
  private:
  int _internal_linklocalserviceentry_size() const;
  public:
  void clear_linklocalserviceentry();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType* mutable_linklocalserviceentry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType >*
      mutable_linklocalserviceentry();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType& _internal_linklocalserviceentry(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType* _internal_add_linklocalserviceentry();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType& linklocalserviceentry(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType* add_linklocalserviceentry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType >&
      linklocalserviceentry() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType > linklocalserviceentry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class MACAddresses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses) */ {
 public:
  inline MACAddresses() : MACAddresses(nullptr) {}
  ~MACAddresses() override;
  explicit constexpr MACAddresses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MACAddresses(const MACAddresses& from);
  MACAddresses(MACAddresses&& from) noexcept
    : MACAddresses() {
    *this = ::std::move(from);
  }

  inline MACAddresses& operator=(const MACAddresses& from) {
    CopyFrom(from);
    return *this;
  }
  inline MACAddresses& operator=(MACAddresses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MACAddresses& default_instance() {
    return *internal_default_instance();
  }
  static inline const MACAddresses* internal_default_instance() {
    return reinterpret_cast<const MACAddresses*>(
               &_MACAddresses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(MACAddresses& a, MACAddresses& b) {
    a.Swap(&b);
  }
  inline void Swap(MACAddresses* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MACAddresses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MACAddresses* New() const final {
    return new MACAddresses();
  }

  MACAddresses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MACAddresses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MACAddresses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MACAddresses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MACAddresses* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses";
  }
  protected:
  explicit MACAddresses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddressFieldNumber = 1,
  };
  // repeated string macAddress = 1;
  int macaddress_size() const;
  private:
  int _internal_macaddress_size() const;
  public:
  void clear_macaddress();
  const std::string& macaddress(int index) const;
  std::string* mutable_macaddress(int index);
  void set_macaddress(int index, const std::string& value);
  void set_macaddress(int index, std::string&& value);
  void set_macaddress(int index, const char* value);
  void set_macaddress(int index, const char* value, size_t size);
  std::string* add_macaddress();
  void add_macaddress(const std::string& value);
  void add_macaddress(std::string&& value);
  void add_macaddress(const char* value);
  void add_macaddress(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& macaddress() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_macaddress();
  private:
  const std::string& _internal_macaddress(int index) const;
  std::string* _internal_add_macaddress();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> macaddress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class PolicyBasedForwardingRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule) */ {
 public:
  inline PolicyBasedForwardingRule() : PolicyBasedForwardingRule(nullptr) {}
  ~PolicyBasedForwardingRule() override;
  explicit constexpr PolicyBasedForwardingRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyBasedForwardingRule(const PolicyBasedForwardingRule& from);
  PolicyBasedForwardingRule(PolicyBasedForwardingRule&& from) noexcept
    : PolicyBasedForwardingRule() {
    *this = ::std::move(from);
  }

  inline PolicyBasedForwardingRule& operator=(const PolicyBasedForwardingRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyBasedForwardingRule& operator=(PolicyBasedForwardingRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolicyBasedForwardingRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyBasedForwardingRule* internal_default_instance() {
    return reinterpret_cast<const PolicyBasedForwardingRule*>(
               &_PolicyBasedForwardingRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(PolicyBasedForwardingRule& a, PolicyBasedForwardingRule& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyBasedForwardingRule* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyBasedForwardingRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PolicyBasedForwardingRule* New() const final {
    return new PolicyBasedForwardingRule();
  }

  PolicyBasedForwardingRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PolicyBasedForwardingRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolicyBasedForwardingRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolicyBasedForwardingRule& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolicyBasedForwardingRule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule";
  }
  protected:
  explicit PolicyBasedForwardingRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
  };
  // optional string direction = 1;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const std::string& direction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_direction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_direction();
  PROTOBUF_MUST_USE_RESULT std::string* release_direction();
  void set_allocated_direction(std::string* direction);
  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(const std::string& value);
  std::string* _internal_mutable_direction();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class PortRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange) */ {
 public:
  inline PortRange() : PortRange(nullptr) {}
  ~PortRange() override;
  explicit constexpr PortRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortRange(const PortRange& from);
  PortRange(PortRange&& from) noexcept
    : PortRange() {
    *this = ::std::move(from);
  }

  inline PortRange& operator=(const PortRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortRange& operator=(PortRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortRange* internal_default_instance() {
    return reinterpret_cast<const PortRange*>(
               &_PortRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(PortRange& a, PortRange& b) {
    a.Swap(&b);
  }
  inline void Swap(PortRange* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortRange* New() const final {
    return new PortRange();
  }

  PortRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange";
  }
  protected:
  explicit PortRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartPortFieldNumber = 1,
    kEndPortFieldNumber = 2,
  };
  // optional int32 startPort = 1;
  bool has_startport() const;
  private:
  bool _internal_has_startport() const;
  public:
  void clear_startport();
  ::PROTOBUF_NAMESPACE_ID::int32 startport() const;
  void set_startport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_startport() const;
  void _internal_set_startport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 endPort = 2;
  bool has_endport() const;
  private:
  bool _internal_has_endport() const;
  public:
  void clear_endport();
  ::PROTOBUF_NAMESPACE_ID::int32 endport() const;
  void set_endport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_endport() const;
  void _internal_set_endport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 startport_;
  ::PROTOBUF_NAMESPACE_ID::int32 endport_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class PortTranslationPool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool) */ {
 public:
  inline PortTranslationPool() : PortTranslationPool(nullptr) {}
  ~PortTranslationPool() override;
  explicit constexpr PortTranslationPool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortTranslationPool(const PortTranslationPool& from);
  PortTranslationPool(PortTranslationPool&& from) noexcept
    : PortTranslationPool() {
    *this = ::std::move(from);
  }

  inline PortTranslationPool& operator=(const PortTranslationPool& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortTranslationPool& operator=(PortTranslationPool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortTranslationPool& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortTranslationPool* internal_default_instance() {
    return reinterpret_cast<const PortTranslationPool*>(
               &_PortTranslationPool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(PortTranslationPool& a, PortTranslationPool& b) {
    a.Swap(&b);
  }
  inline void Swap(PortTranslationPool* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortTranslationPool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortTranslationPool* New() const final {
    return new PortTranslationPool();
  }

  PortTranslationPool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortTranslationPool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortTranslationPool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortTranslationPool& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortTranslationPool* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool";
  }
  protected:
  explicit PortTranslationPool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolFieldNumber = 1,
    kPortRangeFieldNumber = 2,
    kPortCountFieldNumber = 3,
  };
  // optional string protocol = 1;
  bool has_protocol() const;
  private:
  bool _internal_has_protocol() const;
  public:
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_MUST_USE_RESULT std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange portRange = 2;
  bool has_portrange() const;
  private:
  bool _internal_has_portrange() const;
  public:
  void clear_portrange();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange& portrange() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* release_portrange();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* mutable_portrange();
  void set_allocated_portrange(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* portrange);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange& _internal_portrange() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* _internal_mutable_portrange();
  public:
  void unsafe_arena_set_allocated_portrange(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* portrange);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* unsafe_arena_release_portrange();

  // optional int32 portCount = 3;
  bool has_portcount() const;
  private:
  bool _internal_has_portcount() const;
  public:
  void clear_portcount();
  ::PROTOBUF_NAMESPACE_ID::int32 portcount() const;
  void set_portcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_portcount() const;
  void _internal_set_portcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* portrange_;
  ::PROTOBUF_NAMESPACE_ID::int32 portcount_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class PortTranslationPools final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools) */ {
 public:
  inline PortTranslationPools() : PortTranslationPools(nullptr) {}
  ~PortTranslationPools() override;
  explicit constexpr PortTranslationPools(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortTranslationPools(const PortTranslationPools& from);
  PortTranslationPools(PortTranslationPools&& from) noexcept
    : PortTranslationPools() {
    *this = ::std::move(from);
  }

  inline PortTranslationPools& operator=(const PortTranslationPools& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortTranslationPools& operator=(PortTranslationPools&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortTranslationPools& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortTranslationPools* internal_default_instance() {
    return reinterpret_cast<const PortTranslationPools*>(
               &_PortTranslationPools_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(PortTranslationPools& a, PortTranslationPools& b) {
    a.Swap(&b);
  }
  inline void Swap(PortTranslationPools* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortTranslationPools* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortTranslationPools* New() const final {
    return new PortTranslationPools();
  }

  PortTranslationPools* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortTranslationPools>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortTranslationPools& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortTranslationPools& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortTranslationPools* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools";
  }
  protected:
  explicit PortTranslationPools(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoolsFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool pools = 1;
  int pools_size() const;
  private:
  int _internal_pools_size() const;
  public:
  void clear_pools();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool* mutable_pools(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool >*
      mutable_pools();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool& _internal_pools(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool* _internal_add_pools();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool& pools(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool* add_pools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool >&
      pools() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool > pools_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class PortType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType) */ {
 public:
  inline PortType() : PortType(nullptr) {}
  ~PortType() override;
  explicit constexpr PortType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortType(const PortType& from);
  PortType(PortType&& from) noexcept
    : PortType() {
    *this = ::std::move(from);
  }

  inline PortType& operator=(const PortType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortType& operator=(PortType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortType& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortType* internal_default_instance() {
    return reinterpret_cast<const PortType*>(
               &_PortType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(PortType& a, PortType& b) {
    a.Swap(&b);
  }
  inline void Swap(PortType* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortType* New() const final {
    return new PortType();
  }

  PortType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType";
  }
  protected:
  explicit PortType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartPortFieldNumber = 1,
    kEndPortFieldNumber = 2,
  };
  // optional int64 startPort = 1;
  bool has_startport() const;
  private:
  bool _internal_has_startport() const;
  public:
  void clear_startport();
  ::PROTOBUF_NAMESPACE_ID::int64 startport() const;
  void set_startport(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_startport() const;
  void _internal_set_startport(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 endPort = 2;
  bool has_endport() const;
  private:
  bool _internal_has_endport() const;
  public:
  void clear_endport();
  ::PROTOBUF_NAMESPACE_ID::int64 endport() const;
  void set_endport(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_endport() const;
  void _internal_set_endport(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 startport_;
  ::PROTOBUF_NAMESPACE_ID::int64 endport_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Range final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() override;
  explicit constexpr Range(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Range(const Range& from);
  Range(Range&& from) noexcept
    : Range() {
    *this = ::std::move(from);
  }

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(Range& a, Range& b) {
    a.Swap(&b);
  }
  inline void Swap(Range* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Range* New() const final {
    return new Range();
  }

  Range* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Range>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Range& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Range& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Range* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range";
  }
  protected:
  explicit Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpRangesFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange ipRanges = 2;
  int ipranges_size() const;
  private:
  int _internal_ipranges_size() const;
  public:
  void clear_ipranges();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange* mutable_ipranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange >*
      mutable_ipranges();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange& _internal_ipranges(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange* _internal_add_ipranges();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange& ipranges(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange* add_ipranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange >&
      ipranges() const;

  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange > ipranges_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ReconcilerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState) */ {
 public:
  inline ReconcilerState() : ReconcilerState(nullptr) {}
  ~ReconcilerState() override;
  explicit constexpr ReconcilerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReconcilerState(const ReconcilerState& from);
  ReconcilerState(ReconcilerState&& from) noexcept
    : ReconcilerState() {
    *this = ::std::move(from);
  }

  inline ReconcilerState& operator=(const ReconcilerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconcilerState& operator=(ReconcilerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconcilerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconcilerState* internal_default_instance() {
    return reinterpret_cast<const ReconcilerState*>(
               &_ReconcilerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(ReconcilerState& a, ReconcilerState& b) {
    a.Swap(&b);
  }
  inline void Swap(ReconcilerState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconcilerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReconcilerState* New() const final {
    return new ReconcilerState();
  }

  ReconcilerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReconcilerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReconcilerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReconcilerState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReconcilerState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState";
  }
  protected:
  explicit ReconcilerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kObservationFieldNumber = 2,
  };
  // optional string state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_MUST_USE_RESULT std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional string observation = 2;
  bool has_observation() const;
  private:
  bool _internal_has_observation() const;
  public:
  void clear_observation();
  const std::string& observation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_observation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_observation();
  PROTOBUF_MUST_USE_RESULT std::string* release_observation();
  void set_allocated_observation(std::string* observation);
  private:
  const std::string& _internal_observation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_observation(const std::string& value);
  std::string* _internal_mutable_observation();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr observation_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ResourceReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference) */ {
 public:
  inline ResourceReference() : ResourceReference(nullptr) {}
  ~ResourceReference() override;
  explicit constexpr ResourceReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceReference(const ResourceReference& from);
  ResourceReference(ResourceReference&& from) noexcept
    : ResourceReference() {
    *this = ::std::move(from);
  }

  inline ResourceReference& operator=(const ResourceReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceReference& operator=(ResourceReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceReference* internal_default_instance() {
    return reinterpret_cast<const ResourceReference*>(
               &_ResourceReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(ResourceReference& a, ResourceReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceReference* New() const final {
    return new ResourceReference();
  }

  ResourceReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference";
  }
  protected:
  explicit ResourceReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectReferenceFieldNumber = 1,
    kContrailFqNameFieldNumber = 2,
  };
  // optional .k8s.io.api.core.v1.ObjectReference objectReference = 1;
  bool has_objectreference() const;
  private:
  bool _internal_has_objectreference() const;
  public:
  void clear_objectreference();
  const ::k8s::io::api::core::v1::ObjectReference& objectreference() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::api::core::v1::ObjectReference* release_objectreference();
  ::k8s::io::api::core::v1::ObjectReference* mutable_objectreference();
  void set_allocated_objectreference(::k8s::io::api::core::v1::ObjectReference* objectreference);
  private:
  const ::k8s::io::api::core::v1::ObjectReference& _internal_objectreference() const;
  ::k8s::io::api::core::v1::ObjectReference* _internal_mutable_objectreference();
  public:
  void unsafe_arena_set_allocated_objectreference(
      ::k8s::io::api::core::v1::ObjectReference* objectreference);
  ::k8s::io::api::core::v1::ObjectReference* unsafe_arena_release_objectreference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName contrailFqName = 2;
  bool has_contrailfqname() const;
  private:
  bool _internal_has_contrailfqname() const;
  public:
  void clear_contrailfqname();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName& contrailfqname() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* release_contrailfqname();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* mutable_contrailfqname();
  void set_allocated_contrailfqname(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName& _internal_contrailfqname() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* _internal_mutable_contrailfqname();
  public:
  void unsafe_arena_set_allocated_contrailfqname(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* unsafe_arena_release_contrailfqname();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::api::core::v1::ObjectReference* objectreference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RouteOriginOverride final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride) */ {
 public:
  inline RouteOriginOverride() : RouteOriginOverride(nullptr) {}
  ~RouteOriginOverride() override;
  explicit constexpr RouteOriginOverride(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteOriginOverride(const RouteOriginOverride& from);
  RouteOriginOverride(RouteOriginOverride&& from) noexcept
    : RouteOriginOverride() {
    *this = ::std::move(from);
  }

  inline RouteOriginOverride& operator=(const RouteOriginOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteOriginOverride& operator=(RouteOriginOverride&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteOriginOverride& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteOriginOverride* internal_default_instance() {
    return reinterpret_cast<const RouteOriginOverride*>(
               &_RouteOriginOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(RouteOriginOverride& a, RouteOriginOverride& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteOriginOverride* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteOriginOverride* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteOriginOverride* New() const final {
    return new RouteOriginOverride();
  }

  RouteOriginOverride* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteOriginOverride>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteOriginOverride& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteOriginOverride& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteOriginOverride* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride";
  }
  protected:
  explicit RouteOriginOverride(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 2,
    kOriginOverrideFieldNumber = 1,
  };
  // optional string origin = 2;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const std::string& origin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_origin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_origin();
  PROTOBUF_MUST_USE_RESULT std::string* release_origin();
  void set_allocated_origin(std::string* origin);
  private:
  const std::string& _internal_origin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin(const std::string& value);
  std::string* _internal_mutable_origin();
  public:

  // optional bool originOverride = 1;
  bool has_originoverride() const;
  private:
  bool _internal_has_originoverride() const;
  public:
  void clear_originoverride();
  bool originoverride() const;
  void set_originoverride(bool value);
  private:
  bool _internal_originoverride() const;
  void _internal_set_originoverride(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr origin_;
  bool originoverride_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RouteTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget) */ {
 public:
  inline RouteTarget() : RouteTarget(nullptr) {}
  ~RouteTarget() override;
  explicit constexpr RouteTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTarget(const RouteTarget& from);
  RouteTarget(RouteTarget&& from) noexcept
    : RouteTarget() {
    *this = ::std::move(from);
  }

  inline RouteTarget& operator=(const RouteTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTarget& operator=(RouteTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTarget* internal_default_instance() {
    return reinterpret_cast<const RouteTarget*>(
               &_RouteTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(RouteTarget& a, RouteTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTarget* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteTarget* New() const final {
    return new RouteTarget();
  }

  RouteTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTarget& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTarget* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget";
  }
  protected:
  explicit RouteTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RouteTargetList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList) */ {
 public:
  inline RouteTargetList() : RouteTargetList(nullptr) {}
  ~RouteTargetList() override;
  explicit constexpr RouteTargetList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTargetList(const RouteTargetList& from);
  RouteTargetList(RouteTargetList&& from) noexcept
    : RouteTargetList() {
    *this = ::std::move(from);
  }

  inline RouteTargetList& operator=(const RouteTargetList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTargetList& operator=(RouteTargetList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTargetList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTargetList* internal_default_instance() {
    return reinterpret_cast<const RouteTargetList*>(
               &_RouteTargetList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(RouteTargetList& a, RouteTargetList& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTargetList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTargetList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteTargetList* New() const final {
    return new RouteTargetList();
  }

  RouteTargetList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteTargetList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTargetList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTargetList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTargetList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList";
  }
  protected:
  explicit RouteTargetList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RouteTargetReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference) */ {
 public:
  inline RouteTargetReference() : RouteTargetReference(nullptr) {}
  ~RouteTargetReference() override;
  explicit constexpr RouteTargetReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTargetReference(const RouteTargetReference& from);
  RouteTargetReference(RouteTargetReference&& from) noexcept
    : RouteTargetReference() {
    *this = ::std::move(from);
  }

  inline RouteTargetReference& operator=(const RouteTargetReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTargetReference& operator=(RouteTargetReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTargetReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTargetReference* internal_default_instance() {
    return reinterpret_cast<const RouteTargetReference*>(
               &_RouteTargetReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(RouteTargetReference& a, RouteTargetReference& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTargetReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTargetReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteTargetReference* New() const final {
    return new RouteTargetReference();
  }

  RouteTargetReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteTargetReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTargetReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTargetReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTargetReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference";
  }
  protected:
  explicit RouteTargetReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceReferenceFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
  bool has_resourcereference() const;
  private:
  bool _internal_has_resourcereference() const;
  public:
  void clear_resourcereference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& resourcereference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_resourcereference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_resourcereference();
  void set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_resourcereference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_resourcereference();
  public:
  void unsafe_arena_set_allocated_resourcereference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_resourcereference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes attributes = 2;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes& attributes() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* release_attributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* mutable_attributes();
  void set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* attributes);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes& _internal_attributes() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* attributes);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* attributes_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RouteTargetReferenceAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes) */ {
 public:
  inline RouteTargetReferenceAttributes() : RouteTargetReferenceAttributes(nullptr) {}
  ~RouteTargetReferenceAttributes() override;
  explicit constexpr RouteTargetReferenceAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTargetReferenceAttributes(const RouteTargetReferenceAttributes& from);
  RouteTargetReferenceAttributes(RouteTargetReferenceAttributes&& from) noexcept
    : RouteTargetReferenceAttributes() {
    *this = ::std::move(from);
  }

  inline RouteTargetReferenceAttributes& operator=(const RouteTargetReferenceAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTargetReferenceAttributes& operator=(RouteTargetReferenceAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTargetReferenceAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTargetReferenceAttributes* internal_default_instance() {
    return reinterpret_cast<const RouteTargetReferenceAttributes*>(
               &_RouteTargetReferenceAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(RouteTargetReferenceAttributes& a, RouteTargetReferenceAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTargetReferenceAttributes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTargetReferenceAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteTargetReferenceAttributes* New() const final {
    return new RouteTargetReferenceAttributes();
  }

  RouteTargetReferenceAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteTargetReferenceAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTargetReferenceAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTargetReferenceAttributes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTargetReferenceAttributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes";
  }
  protected:
  explicit RouteTargetReferenceAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImportExportFieldNumber = 1,
  };
  // optional string importExport = 1;
  bool has_importexport() const;
  private:
  bool _internal_has_importexport() const;
  public:
  void clear_importexport();
  const std::string& importexport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_importexport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_importexport();
  PROTOBUF_MUST_USE_RESULT std::string* release_importexport();
  void set_allocated_importexport(std::string* importexport);
  private:
  const std::string& _internal_importexport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_importexport(const std::string& value);
  std::string* _internal_mutable_importexport();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr importexport_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RouteTargetSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec) */ {
 public:
  inline RouteTargetSpec() : RouteTargetSpec(nullptr) {}
  ~RouteTargetSpec() override;
  explicit constexpr RouteTargetSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTargetSpec(const RouteTargetSpec& from);
  RouteTargetSpec(RouteTargetSpec&& from) noexcept
    : RouteTargetSpec() {
    *this = ::std::move(from);
  }

  inline RouteTargetSpec& operator=(const RouteTargetSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTargetSpec& operator=(RouteTargetSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTargetSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTargetSpec* internal_default_instance() {
    return reinterpret_cast<const RouteTargetSpec*>(
               &_RouteTargetSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(RouteTargetSpec& a, RouteTargetSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTargetSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTargetSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteTargetSpec* New() const final {
    return new RouteTargetSpec();
  }

  RouteTargetSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteTargetSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTargetSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTargetSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTargetSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec";
  }
  protected:
  explicit RouteTargetSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonSpecFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RouteTargetStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus) */ {
 public:
  inline RouteTargetStatus() : RouteTargetStatus(nullptr) {}
  ~RouteTargetStatus() override;
  explicit constexpr RouteTargetStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTargetStatus(const RouteTargetStatus& from);
  RouteTargetStatus(RouteTargetStatus&& from) noexcept
    : RouteTargetStatus() {
    *this = ::std::move(from);
  }

  inline RouteTargetStatus& operator=(const RouteTargetStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTargetStatus& operator=(RouteTargetStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTargetStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTargetStatus* internal_default_instance() {
    return reinterpret_cast<const RouteTargetStatus*>(
               &_RouteTargetStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(RouteTargetStatus& a, RouteTargetStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTargetStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTargetStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteTargetStatus* New() const final {
    return new RouteTargetStatus();
  }

  RouteTargetStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteTargetStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTargetStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTargetStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTargetStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus";
  }
  protected:
  explicit RouteTargetStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RoutingInstance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance) */ {
 public:
  inline RoutingInstance() : RoutingInstance(nullptr) {}
  ~RoutingInstance() override;
  explicit constexpr RoutingInstance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInstance(const RoutingInstance& from);
  RoutingInstance(RoutingInstance&& from) noexcept
    : RoutingInstance() {
    *this = ::std::move(from);
  }

  inline RoutingInstance& operator=(const RoutingInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInstance& operator=(RoutingInstance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInstance& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInstance* internal_default_instance() {
    return reinterpret_cast<const RoutingInstance*>(
               &_RoutingInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(RoutingInstance& a, RoutingInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInstance* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInstance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoutingInstance* New() const final {
    return new RoutingInstance();
  }

  RoutingInstance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutingInstance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInstance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingInstance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInstance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance";
  }
  protected:
  explicit RoutingInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RoutingInstanceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList) */ {
 public:
  inline RoutingInstanceList() : RoutingInstanceList(nullptr) {}
  ~RoutingInstanceList() override;
  explicit constexpr RoutingInstanceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInstanceList(const RoutingInstanceList& from);
  RoutingInstanceList(RoutingInstanceList&& from) noexcept
    : RoutingInstanceList() {
    *this = ::std::move(from);
  }

  inline RoutingInstanceList& operator=(const RoutingInstanceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInstanceList& operator=(RoutingInstanceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInstanceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInstanceList* internal_default_instance() {
    return reinterpret_cast<const RoutingInstanceList*>(
               &_RoutingInstanceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(RoutingInstanceList& a, RoutingInstanceList& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInstanceList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInstanceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoutingInstanceList* New() const final {
    return new RoutingInstanceList();
  }

  RoutingInstanceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutingInstanceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInstanceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingInstanceList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInstanceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList";
  }
  protected:
  explicit RoutingInstanceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RoutingInstanceReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference) */ {
 public:
  inline RoutingInstanceReference() : RoutingInstanceReference(nullptr) {}
  ~RoutingInstanceReference() override;
  explicit constexpr RoutingInstanceReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInstanceReference(const RoutingInstanceReference& from);
  RoutingInstanceReference(RoutingInstanceReference&& from) noexcept
    : RoutingInstanceReference() {
    *this = ::std::move(from);
  }

  inline RoutingInstanceReference& operator=(const RoutingInstanceReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInstanceReference& operator=(RoutingInstanceReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInstanceReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInstanceReference* internal_default_instance() {
    return reinterpret_cast<const RoutingInstanceReference*>(
               &_RoutingInstanceReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(RoutingInstanceReference& a, RoutingInstanceReference& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInstanceReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInstanceReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoutingInstanceReference* New() const final {
    return new RoutingInstanceReference();
  }

  RoutingInstanceReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutingInstanceReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInstanceReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingInstanceReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInstanceReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference";
  }
  protected:
  explicit RoutingInstanceReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceReferenceFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
  bool has_resourcereference() const;
  private:
  bool _internal_has_resourcereference() const;
  public:
  void clear_resourcereference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& resourcereference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_resourcereference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_resourcereference();
  void set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_resourcereference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_resourcereference();
  public:
  void unsafe_arena_set_allocated_resourcereference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_resourcereference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule attributes = 2;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule& attributes() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* release_attributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* mutable_attributes();
  void set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* attributes);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule& _internal_attributes() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* attributes);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* attributes_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RoutingInstanceSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec) */ {
 public:
  inline RoutingInstanceSpec() : RoutingInstanceSpec(nullptr) {}
  ~RoutingInstanceSpec() override;
  explicit constexpr RoutingInstanceSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInstanceSpec(const RoutingInstanceSpec& from);
  RoutingInstanceSpec(RoutingInstanceSpec&& from) noexcept
    : RoutingInstanceSpec() {
    *this = ::std::move(from);
  }

  inline RoutingInstanceSpec& operator=(const RoutingInstanceSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInstanceSpec& operator=(RoutingInstanceSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInstanceSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInstanceSpec* internal_default_instance() {
    return reinterpret_cast<const RoutingInstanceSpec*>(
               &_RoutingInstanceSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(RoutingInstanceSpec& a, RoutingInstanceSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInstanceSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInstanceSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoutingInstanceSpec* New() const final {
    return new RoutingInstanceSpec();
  }

  RoutingInstanceSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutingInstanceSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInstanceSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingInstanceSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInstanceSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec";
  }
  protected:
  explicit RoutingInstanceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteTargetReferencesFieldNumber = 3,
    kCommonSpecFieldNumber = 1,
    kParentFieldNumber = 2,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference routeTargetReferences = 3;
  int routetargetreferences_size() const;
  private:
  int _internal_routetargetreferences_size() const;
  public:
  void clear_routetargetreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* mutable_routetargetreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference >*
      mutable_routetargetreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& _internal_routetargetreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* _internal_add_routetargetreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& routetargetreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* add_routetargetreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference >&
      routetargetreferences() const;

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .k8s.io.api.core.v1.ObjectReference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::k8s::io::api::core::v1::ObjectReference& parent() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::api::core::v1::ObjectReference* release_parent();
  ::k8s::io::api::core::v1::ObjectReference* mutable_parent();
  void set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent);
  private:
  const ::k8s::io::api::core::v1::ObjectReference& _internal_parent() const;
  ::k8s::io::api::core::v1::ObjectReference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::k8s::io::api::core::v1::ObjectReference* parent);
  ::k8s::io::api::core::v1::ObjectReference* unsafe_arena_release_parent();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference > routetargetreferences_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::k8s::io::api::core::v1::ObjectReference* parent_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse, 
    std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse, 
    std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse();
  explicit constexpr RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse& other);
  static const RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse*>(&_RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.VirtualNetworkRouterRouteTargetReferencesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class RoutingInstanceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus) */ {
 public:
  inline RoutingInstanceStatus() : RoutingInstanceStatus(nullptr) {}
  ~RoutingInstanceStatus() override;
  explicit constexpr RoutingInstanceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInstanceStatus(const RoutingInstanceStatus& from);
  RoutingInstanceStatus(RoutingInstanceStatus&& from) noexcept
    : RoutingInstanceStatus() {
    *this = ::std::move(from);
  }

  inline RoutingInstanceStatus& operator=(const RoutingInstanceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInstanceStatus& operator=(RoutingInstanceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInstanceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInstanceStatus* internal_default_instance() {
    return reinterpret_cast<const RoutingInstanceStatus*>(
               &_RoutingInstanceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(RoutingInstanceStatus& a, RoutingInstanceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInstanceStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInstanceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoutingInstanceStatus* New() const final {
    return new RoutingInstanceStatus();
  }

  RoutingInstanceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutingInstanceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInstanceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingInstanceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInstanceStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus";
  }
  protected:
  explicit RoutingInstanceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVirtualNetworkRouterRouteTargetReferencesFieldNumber = 5,
    kCommonStatusFieldNumber = 1,
    kDefaultRouteTargetReferenceFieldNumber = 4,
    kIsDefaultFieldNumber = 2,
    kRoutingInstanceFabricSNATFieldNumber = 3,
  };
  // map<string, .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList> virtualNetworkRouterRouteTargetReferences = 5;
  int virtualnetworkrouterroutetargetreferences_size() const;
  private:
  int _internal_virtualnetworkrouterroutetargetreferences_size() const;
  public:
  void clear_virtualnetworkrouterroutetargetreferences();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList >&
      _internal_virtualnetworkrouterroutetargetreferences() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList >*
      _internal_mutable_virtualnetworkrouterroutetargetreferences();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList >&
      virtualnetworkrouterroutetargetreferences() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList >*
      mutable_virtualnetworkrouterroutetargetreferences();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference defaultRouteTargetReference = 4;
  bool has_defaultroutetargetreference() const;
  private:
  bool _internal_has_defaultroutetargetreference() const;
  public:
  void clear_defaultroutetargetreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& defaultroutetargetreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* release_defaultroutetargetreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* mutable_defaultroutetargetreference();
  void set_allocated_defaultroutetargetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* defaultroutetargetreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& _internal_defaultroutetargetreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* _internal_mutable_defaultroutetargetreference();
  public:
  void unsafe_arena_set_allocated_defaultroutetargetreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* defaultroutetargetreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* unsafe_arena_release_defaultroutetargetreference();

  // optional bool isDefault = 2;
  bool has_isdefault() const;
  private:
  bool _internal_has_isdefault() const;
  public:
  void clear_isdefault();
  bool isdefault() const;
  void set_isdefault(bool value);
  private:
  bool _internal_isdefault() const;
  void _internal_set_isdefault(bool value);
  public:

  // optional bool routingInstanceFabricSNAT = 3;
  bool has_routinginstancefabricsnat() const;
  private:
  bool _internal_has_routinginstancefabricsnat() const;
  public:
  void clear_routinginstancefabricsnat();
  bool routinginstancefabricsnat() const;
  void set_routinginstancefabricsnat(bool value);
  private:
  bool _internal_routinginstancefabricsnat() const;
  void _internal_set_routinginstancefabricsnat(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      RoutingInstanceStatus_VirtualNetworkRouterRouteTargetReferencesEntry_DoNotUse,
      std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> virtualnetworkrouterroutetargetreferences_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* defaultroutetargetreference_;
  bool isdefault_;
  bool routinginstancefabricsnat_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Subnet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet) */ {
 public:
  inline Subnet() : Subnet(nullptr) {}
  ~Subnet() override;
  explicit constexpr Subnet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subnet(const Subnet& from);
  Subnet(Subnet&& from) noexcept
    : Subnet() {
    *this = ::std::move(from);
  }

  inline Subnet& operator=(const Subnet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subnet& operator=(Subnet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subnet& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subnet* internal_default_instance() {
    return reinterpret_cast<const Subnet*>(
               &_Subnet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(Subnet& a, Subnet& b) {
    a.Swap(&b);
  }
  inline void Swap(Subnet* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subnet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Subnet* New() const final {
    return new Subnet();
  }

  Subnet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Subnet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subnet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Subnet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subnet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet";
  }
  protected:
  explicit Subnet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class SubnetList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList) */ {
 public:
  inline SubnetList() : SubnetList(nullptr) {}
  ~SubnetList() override;
  explicit constexpr SubnetList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubnetList(const SubnetList& from);
  SubnetList(SubnetList&& from) noexcept
    : SubnetList() {
    *this = ::std::move(from);
  }

  inline SubnetList& operator=(const SubnetList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubnetList& operator=(SubnetList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubnetList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubnetList* internal_default_instance() {
    return reinterpret_cast<const SubnetList*>(
               &_SubnetList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(SubnetList& a, SubnetList& b) {
    a.Swap(&b);
  }
  inline void Swap(SubnetList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubnetList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubnetList* New() const final {
    return new SubnetList();
  }

  SubnetList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubnetList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubnetList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubnetList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubnetList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList";
  }
  protected:
  explicit SubnetList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class SubnetReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference) */ {
 public:
  inline SubnetReference() : SubnetReference(nullptr) {}
  ~SubnetReference() override;
  explicit constexpr SubnetReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubnetReference(const SubnetReference& from);
  SubnetReference(SubnetReference&& from) noexcept
    : SubnetReference() {
    *this = ::std::move(from);
  }

  inline SubnetReference& operator=(const SubnetReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubnetReference& operator=(SubnetReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubnetReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubnetReference* internal_default_instance() {
    return reinterpret_cast<const SubnetReference*>(
               &_SubnetReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(SubnetReference& a, SubnetReference& b) {
    a.Swap(&b);
  }
  inline void Swap(SubnetReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubnetReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubnetReference* New() const final {
    return new SubnetReference();
  }

  SubnetReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubnetReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubnetReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubnetReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubnetReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference";
  }
  protected:
  explicit SubnetReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceReferenceFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
  bool has_resourcereference() const;
  private:
  bool _internal_has_resourcereference() const;
  public:
  void clear_resourcereference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& resourcereference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_resourcereference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_resourcereference();
  void set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_resourcereference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_resourcereference();
  public:
  void unsafe_arena_set_allocated_resourcereference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_resourcereference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes attributes = 2;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes& attributes() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* release_attributes();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* mutable_attributes();
  void set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* attributes);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes& _internal_attributes() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* attributes);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* attributes_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class SubnetSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec) */ {
 public:
  inline SubnetSpec() : SubnetSpec(nullptr) {}
  ~SubnetSpec() override;
  explicit constexpr SubnetSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubnetSpec(const SubnetSpec& from);
  SubnetSpec(SubnetSpec&& from) noexcept
    : SubnetSpec() {
    *this = ::std::move(from);
  }

  inline SubnetSpec& operator=(const SubnetSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubnetSpec& operator=(SubnetSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubnetSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubnetSpec* internal_default_instance() {
    return reinterpret_cast<const SubnetSpec*>(
               &_SubnetSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(SubnetSpec& a, SubnetSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(SubnetSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubnetSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubnetSpec* New() const final {
    return new SubnetSpec();
  }

  SubnetSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubnetSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubnetSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubnetSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubnetSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec";
  }
  protected:
  explicit SubnetSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDnsNameserversFieldNumber = 5,
    kRangesFieldNumber = 6,
    kCidrFieldNumber = 3,
    kDefaultGatewayFieldNumber = 4,
    kBgpaasPrimaryIPFieldNumber = 8,
    kBgpaasSecondaryIPFieldNumber = 9,
    kCommonSpecFieldNumber = 1,
    kDisableBGPaaSIPAutoAllocationFieldNumber = 7,
  };
  // repeated string dnsNameservers = 5;
  int dnsnameservers_size() const;
  private:
  int _internal_dnsnameservers_size() const;
  public:
  void clear_dnsnameservers();
  const std::string& dnsnameservers(int index) const;
  std::string* mutable_dnsnameservers(int index);
  void set_dnsnameservers(int index, const std::string& value);
  void set_dnsnameservers(int index, std::string&& value);
  void set_dnsnameservers(int index, const char* value);
  void set_dnsnameservers(int index, const char* value, size_t size);
  std::string* add_dnsnameservers();
  void add_dnsnameservers(const std::string& value);
  void add_dnsnameservers(std::string&& value);
  void add_dnsnameservers(const char* value);
  void add_dnsnameservers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dnsnameservers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dnsnameservers();
  private:
  const std::string& _internal_dnsnameservers(int index) const;
  std::string* _internal_add_dnsnameservers();
  public:

  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range ranges = 6;
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;
  public:
  void clear_ranges();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range* mutable_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range >*
      mutable_ranges();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range& _internal_ranges(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range* _internal_add_ranges();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range& ranges(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range* add_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range >&
      ranges() const;

  // optional string cidr = 3;
  bool has_cidr() const;
  private:
  bool _internal_has_cidr() const;
  public:
  void clear_cidr();
  const std::string& cidr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cidr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cidr();
  PROTOBUF_MUST_USE_RESULT std::string* release_cidr();
  void set_allocated_cidr(std::string* cidr);
  private:
  const std::string& _internal_cidr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cidr(const std::string& value);
  std::string* _internal_mutable_cidr();
  public:

  // optional string defaultGateway = 4;
  bool has_defaultgateway() const;
  private:
  bool _internal_has_defaultgateway() const;
  public:
  void clear_defaultgateway();
  const std::string& defaultgateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_defaultgateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_defaultgateway();
  PROTOBUF_MUST_USE_RESULT std::string* release_defaultgateway();
  void set_allocated_defaultgateway(std::string* defaultgateway);
  private:
  const std::string& _internal_defaultgateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_defaultgateway(const std::string& value);
  std::string* _internal_mutable_defaultgateway();
  public:

  // optional string bgpaasPrimaryIP = 8;
  bool has_bgpaasprimaryip() const;
  private:
  bool _internal_has_bgpaasprimaryip() const;
  public:
  void clear_bgpaasprimaryip();
  const std::string& bgpaasprimaryip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bgpaasprimaryip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bgpaasprimaryip();
  PROTOBUF_MUST_USE_RESULT std::string* release_bgpaasprimaryip();
  void set_allocated_bgpaasprimaryip(std::string* bgpaasprimaryip);
  private:
  const std::string& _internal_bgpaasprimaryip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bgpaasprimaryip(const std::string& value);
  std::string* _internal_mutable_bgpaasprimaryip();
  public:

  // optional string bgpaasSecondaryIP = 9;
  bool has_bgpaassecondaryip() const;
  private:
  bool _internal_has_bgpaassecondaryip() const;
  public:
  void clear_bgpaassecondaryip();
  const std::string& bgpaassecondaryip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bgpaassecondaryip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bgpaassecondaryip();
  PROTOBUF_MUST_USE_RESULT std::string* release_bgpaassecondaryip();
  void set_allocated_bgpaassecondaryip(std::string* bgpaassecondaryip);
  private:
  const std::string& _internal_bgpaassecondaryip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bgpaassecondaryip(const std::string& value);
  std::string* _internal_mutable_bgpaassecondaryip();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional bool disableBGPaaSIPAutoAllocation = 7;
  bool has_disablebgpaasipautoallocation() const;
  private:
  bool _internal_has_disablebgpaasipautoallocation() const;
  public:
  void clear_disablebgpaasipautoallocation();
  bool disablebgpaasipautoallocation() const;
  void set_disablebgpaasipautoallocation(bool value);
  private:
  bool _internal_disablebgpaasipautoallocation() const;
  void _internal_set_disablebgpaasipautoallocation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dnsnameservers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range > ranges_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cidr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr defaultgateway_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bgpaasprimaryip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bgpaassecondaryip_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  bool disablebgpaasipautoallocation_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class SubnetStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus) */ {
 public:
  inline SubnetStatus() : SubnetStatus(nullptr) {}
  ~SubnetStatus() override;
  explicit constexpr SubnetStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubnetStatus(const SubnetStatus& from);
  SubnetStatus(SubnetStatus&& from) noexcept
    : SubnetStatus() {
    *this = ::std::move(from);
  }

  inline SubnetStatus& operator=(const SubnetStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubnetStatus& operator=(SubnetStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubnetStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubnetStatus* internal_default_instance() {
    return reinterpret_cast<const SubnetStatus*>(
               &_SubnetStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(SubnetStatus& a, SubnetStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SubnetStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubnetStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubnetStatus* New() const final {
    return new SubnetStatus();
  }

  SubnetStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubnetStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubnetStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubnetStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubnetStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus";
  }
  protected:
  explicit SubnetStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocationUsageFieldNumber = 3,
    kCommonStatusFieldNumber = 1,
    kIpCountFieldNumber = 2,
  };
  // optional string allocationUsage = 3;
  bool has_allocationusage() const;
  private:
  bool _internal_has_allocationusage() const;
  public:
  void clear_allocationusage();
  const std::string& allocationusage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_allocationusage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_allocationusage();
  PROTOBUF_MUST_USE_RESULT std::string* release_allocationusage();
  void set_allocated_allocationusage(std::string* allocationusage);
  private:
  const std::string& _internal_allocationusage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_allocationusage(const std::string& value);
  std::string* _internal_mutable_allocationusage();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // optional int64 ipCount = 2;
  bool has_ipcount() const;
  private:
  bool _internal_has_ipcount() const;
  public:
  void clear_ipcount();
  ::PROTOBUF_NAMESPACE_ID::int64 ipcount() const;
  void set_ipcount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ipcount() const;
  void _internal_set_ipcount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allocationusage_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  ::PROTOBUF_NAMESPACE_ID::int64 ipcount_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Tag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag) */ {
 public:
  inline Tag() : Tag(nullptr) {}
  ~Tag() override;
  explicit constexpr Tag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tag(const Tag& from);
  Tag(Tag&& from) noexcept
    : Tag() {
    *this = ::std::move(from);
  }

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tag& operator=(Tag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tag* internal_default_instance() {
    return reinterpret_cast<const Tag*>(
               &_Tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(Tag& a, Tag& b) {
    a.Swap(&b);
  }
  inline void Swap(Tag* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tag* New() const final {
    return new Tag();
  }

  Tag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Tag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag";
  }
  protected:
  explicit Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TagList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList) */ {
 public:
  inline TagList() : TagList(nullptr) {}
  ~TagList() override;
  explicit constexpr TagList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagList(const TagList& from);
  TagList(TagList&& from) noexcept
    : TagList() {
    *this = ::std::move(from);
  }

  inline TagList& operator=(const TagList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagList& operator=(TagList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagList* internal_default_instance() {
    return reinterpret_cast<const TagList*>(
               &_TagList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(TagList& a, TagList& b) {
    a.Swap(&b);
  }
  inline void Swap(TagList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagList* New() const final {
    return new TagList();
  }

  TagList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList";
  }
  protected:
  explicit TagList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TagSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec) */ {
 public:
  inline TagSpec() : TagSpec(nullptr) {}
  ~TagSpec() override;
  explicit constexpr TagSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagSpec(const TagSpec& from);
  TagSpec(TagSpec&& from) noexcept
    : TagSpec() {
    *this = ::std::move(from);
  }

  inline TagSpec& operator=(const TagSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagSpec& operator=(TagSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagSpec* internal_default_instance() {
    return reinterpret_cast<const TagSpec*>(
               &_TagSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(TagSpec& a, TagSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(TagSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagSpec* New() const final {
    return new TagSpec();
  }

  TagSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec";
  }
  protected:
  explicit TagSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagTypeNameFieldNumber = 2,
    kTagValueFieldNumber = 3,
    kCommonSpecFieldNumber = 1,
    kTagTypeReferenceFieldNumber = 4,
  };
  // optional string tagTypeName = 2;
  bool has_tagtypename() const;
  private:
  bool _internal_has_tagtypename() const;
  public:
  void clear_tagtypename();
  const std::string& tagtypename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagtypename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagtypename();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagtypename();
  void set_allocated_tagtypename(std::string* tagtypename);
  private:
  const std::string& _internal_tagtypename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagtypename(const std::string& value);
  std::string* _internal_mutable_tagtypename();
  public:

  // optional string tagValue = 3;
  bool has_tagvalue() const;
  private:
  bool _internal_has_tagvalue() const;
  public:
  void clear_tagvalue();
  const std::string& tagvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagvalue();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagvalue();
  void set_allocated_tagvalue(std::string* tagvalue);
  private:
  const std::string& _internal_tagvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagvalue(const std::string& value);
  std::string* _internal_mutable_tagvalue();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagTypeReference = 4;
  bool has_tagtypereference() const;
  private:
  bool _internal_has_tagtypereference() const;
  public:
  void clear_tagtypereference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& tagtypereference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_tagtypereference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_tagtypereference();
  void set_allocated_tagtypereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* tagtypereference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_tagtypereference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_tagtypereference();
  public:
  void unsafe_arena_set_allocated_tagtypereference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* tagtypereference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_tagtypereference();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagtypename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagvalue_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* tagtypereference_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TagStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus) */ {
 public:
  inline TagStatus() : TagStatus(nullptr) {}
  ~TagStatus() override;
  explicit constexpr TagStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagStatus(const TagStatus& from);
  TagStatus(TagStatus&& from) noexcept
    : TagStatus() {
    *this = ::std::move(from);
  }

  inline TagStatus& operator=(const TagStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagStatus& operator=(TagStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagStatus* internal_default_instance() {
    return reinterpret_cast<const TagStatus*>(
               &_TagStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(TagStatus& a, TagStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TagStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagStatus* New() const final {
    return new TagStatus();
  }

  TagStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus";
  }
  protected:
  explicit TagStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagIdFieldNumber = 2,
    kCommonStatusFieldNumber = 1,
  };
  // optional string tagId = 2;
  bool has_tagid() const;
  private:
  bool _internal_has_tagid() const;
  public:
  void clear_tagid();
  const std::string& tagid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagid();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagid();
  void set_allocated_tagid(std::string* tagid);
  private:
  const std::string& _internal_tagid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagid(const std::string& value);
  std::string* _internal_mutable_tagid();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagid_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TagType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType) */ {
 public:
  inline TagType() : TagType(nullptr) {}
  ~TagType() override;
  explicit constexpr TagType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagType(const TagType& from);
  TagType(TagType&& from) noexcept
    : TagType() {
    *this = ::std::move(from);
  }

  inline TagType& operator=(const TagType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagType& operator=(TagType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagType& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagType* internal_default_instance() {
    return reinterpret_cast<const TagType*>(
               &_TagType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(TagType& a, TagType& b) {
    a.Swap(&b);
  }
  inline void Swap(TagType* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagType* New() const final {
    return new TagType();
  }

  TagType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType";
  }
  protected:
  explicit TagType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TagTypeList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList) */ {
 public:
  inline TagTypeList() : TagTypeList(nullptr) {}
  ~TagTypeList() override;
  explicit constexpr TagTypeList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagTypeList(const TagTypeList& from);
  TagTypeList(TagTypeList&& from) noexcept
    : TagTypeList() {
    *this = ::std::move(from);
  }

  inline TagTypeList& operator=(const TagTypeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTypeList& operator=(TagTypeList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTypeList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTypeList* internal_default_instance() {
    return reinterpret_cast<const TagTypeList*>(
               &_TagTypeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(TagTypeList& a, TagTypeList& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTypeList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTypeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagTypeList* New() const final {
    return new TagTypeList();
  }

  TagTypeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagTypeList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagTypeList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagTypeList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTypeList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList";
  }
  protected:
  explicit TagTypeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TagTypeSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec) */ {
 public:
  inline TagTypeSpec() : TagTypeSpec(nullptr) {}
  ~TagTypeSpec() override;
  explicit constexpr TagTypeSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagTypeSpec(const TagTypeSpec& from);
  TagTypeSpec(TagTypeSpec&& from) noexcept
    : TagTypeSpec() {
    *this = ::std::move(from);
  }

  inline TagTypeSpec& operator=(const TagTypeSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTypeSpec& operator=(TagTypeSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTypeSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTypeSpec* internal_default_instance() {
    return reinterpret_cast<const TagTypeSpec*>(
               &_TagTypeSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(TagTypeSpec& a, TagTypeSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTypeSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTypeSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagTypeSpec* New() const final {
    return new TagTypeSpec();
  }

  TagTypeSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagTypeSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagTypeSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagTypeSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTypeSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec";
  }
  protected:
  explicit TagTypeSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonSpecFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TagTypeStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus) */ {
 public:
  inline TagTypeStatus() : TagTypeStatus(nullptr) {}
  ~TagTypeStatus() override;
  explicit constexpr TagTypeStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagTypeStatus(const TagTypeStatus& from);
  TagTypeStatus(TagTypeStatus&& from) noexcept
    : TagTypeStatus() {
    *this = ::std::move(from);
  }

  inline TagTypeStatus& operator=(const TagTypeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTypeStatus& operator=(TagTypeStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTypeStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTypeStatus* internal_default_instance() {
    return reinterpret_cast<const TagTypeStatus*>(
               &_TagTypeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(TagTypeStatus& a, TagTypeStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTypeStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTypeStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagTypeStatus* New() const final {
    return new TagTypeStatus();
  }

  TagTypeStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagTypeStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagTypeStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagTypeStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTypeStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus";
  }
  protected:
  explicit TagTypeStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagTypeIdFieldNumber = 2,
    kCommonStatusFieldNumber = 1,
  };
  // optional string tagTypeId = 2;
  bool has_tagtypeid() const;
  private:
  bool _internal_has_tagtypeid() const;
  public:
  void clear_tagtypeid();
  const std::string& tagtypeid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagtypeid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagtypeid();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagtypeid();
  void set_allocated_tagtypeid(std::string* tagtypeid);
  private:
  const std::string& _internal_tagtypeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagtypeid(const std::string& value);
  std::string* _internal_mutable_tagtypeid();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagtypeid_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine) */ {
 public:
  inline VirtualMachine() : VirtualMachine(nullptr) {}
  ~VirtualMachine() override;
  explicit constexpr VirtualMachine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachine(const VirtualMachine& from);
  VirtualMachine(VirtualMachine&& from) noexcept
    : VirtualMachine() {
    *this = ::std::move(from);
  }

  inline VirtualMachine& operator=(const VirtualMachine& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachine& operator=(VirtualMachine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachine& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachine* internal_default_instance() {
    return reinterpret_cast<const VirtualMachine*>(
               &_VirtualMachine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(VirtualMachine& a, VirtualMachine& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachine* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachine* New() const final {
    return new VirtualMachine();
  }

  VirtualMachine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachine& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine";
  }
  protected:
  explicit VirtualMachine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachineInterface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface) */ {
 public:
  inline VirtualMachineInterface() : VirtualMachineInterface(nullptr) {}
  ~VirtualMachineInterface() override;
  explicit constexpr VirtualMachineInterface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachineInterface(const VirtualMachineInterface& from);
  VirtualMachineInterface(VirtualMachineInterface&& from) noexcept
    : VirtualMachineInterface() {
    *this = ::std::move(from);
  }

  inline VirtualMachineInterface& operator=(const VirtualMachineInterface& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachineInterface& operator=(VirtualMachineInterface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachineInterface& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachineInterface* internal_default_instance() {
    return reinterpret_cast<const VirtualMachineInterface*>(
               &_VirtualMachineInterface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(VirtualMachineInterface& a, VirtualMachineInterface& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachineInterface* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachineInterface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachineInterface* New() const final {
    return new VirtualMachineInterface();
  }

  VirtualMachineInterface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachineInterface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachineInterface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachineInterface& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachineInterface* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface";
  }
  protected:
  explicit VirtualMachineInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachineInterfaceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList) */ {
 public:
  inline VirtualMachineInterfaceList() : VirtualMachineInterfaceList(nullptr) {}
  ~VirtualMachineInterfaceList() override;
  explicit constexpr VirtualMachineInterfaceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachineInterfaceList(const VirtualMachineInterfaceList& from);
  VirtualMachineInterfaceList(VirtualMachineInterfaceList&& from) noexcept
    : VirtualMachineInterfaceList() {
    *this = ::std::move(from);
  }

  inline VirtualMachineInterfaceList& operator=(const VirtualMachineInterfaceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachineInterfaceList& operator=(VirtualMachineInterfaceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachineInterfaceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachineInterfaceList* internal_default_instance() {
    return reinterpret_cast<const VirtualMachineInterfaceList*>(
               &_VirtualMachineInterfaceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(VirtualMachineInterfaceList& a, VirtualMachineInterfaceList& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachineInterfaceList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachineInterfaceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachineInterfaceList* New() const final {
    return new VirtualMachineInterfaceList();
  }

  VirtualMachineInterfaceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachineInterfaceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachineInterfaceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachineInterfaceList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachineInterfaceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList";
  }
  protected:
  explicit VirtualMachineInterfaceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachineInterfaceProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProperties) */ {
 public:
  inline VirtualMachineInterfaceProperties() : VirtualMachineInterfaceProperties(nullptr) {}
  ~VirtualMachineInterfaceProperties() override;
  explicit constexpr VirtualMachineInterfaceProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachineInterfaceProperties(const VirtualMachineInterfaceProperties& from);
  VirtualMachineInterfaceProperties(VirtualMachineInterfaceProperties&& from) noexcept
    : VirtualMachineInterfaceProperties() {
    *this = ::std::move(from);
  }

  inline VirtualMachineInterfaceProperties& operator=(const VirtualMachineInterfaceProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachineInterfaceProperties& operator=(VirtualMachineInterfaceProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachineInterfaceProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachineInterfaceProperties* internal_default_instance() {
    return reinterpret_cast<const VirtualMachineInterfaceProperties*>(
               &_VirtualMachineInterfaceProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(VirtualMachineInterfaceProperties& a, VirtualMachineInterfaceProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachineInterfaceProperties* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachineInterfaceProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachineInterfaceProperties* New() const final {
    return new VirtualMachineInterfaceProperties();
  }

  VirtualMachineInterfaceProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachineInterfaceProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachineInterfaceProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachineInterfaceProperties& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachineInterfaceProperties* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProperties";
  }
  protected:
  explicit VirtualMachineInterfaceProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubInterfaceVlanTagFieldNumber = 1,
  };
  // optional uint32 subInterfaceVlanTag = 1;
  bool has_subinterfacevlantag() const;
  private:
  bool _internal_has_subinterfacevlantag() const;
  public:
  void clear_subinterfacevlantag();
  ::PROTOBUF_NAMESPACE_ID::uint32 subinterfacevlantag() const;
  void set_subinterfacevlantag(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_subinterfacevlantag() const;
  void _internal_set_subinterfacevlantag(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 subinterfacevlantag_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachineInterfaceSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec) */ {
 public:
  inline VirtualMachineInterfaceSpec() : VirtualMachineInterfaceSpec(nullptr) {}
  ~VirtualMachineInterfaceSpec() override;
  explicit constexpr VirtualMachineInterfaceSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachineInterfaceSpec(const VirtualMachineInterfaceSpec& from);
  VirtualMachineInterfaceSpec(VirtualMachineInterfaceSpec&& from) noexcept
    : VirtualMachineInterfaceSpec() {
    *this = ::std::move(from);
  }

  inline VirtualMachineInterfaceSpec& operator=(const VirtualMachineInterfaceSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachineInterfaceSpec& operator=(VirtualMachineInterfaceSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachineInterfaceSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachineInterfaceSpec* internal_default_instance() {
    return reinterpret_cast<const VirtualMachineInterfaceSpec*>(
               &_VirtualMachineInterfaceSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(VirtualMachineInterfaceSpec& a, VirtualMachineInterfaceSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachineInterfaceSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachineInterfaceSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachineInterfaceSpec* New() const final {
    return new VirtualMachineInterfaceSpec();
  }

  VirtualMachineInterfaceSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachineInterfaceSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachineInterfaceSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachineInterfaceSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachineInterfaceSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec";
  }
  protected:
  explicit VirtualMachineInterfaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualMachineReferencesFieldNumber = 5,
    kVirtualMachineInterfaceReferencesFieldNumber = 9,
    kTagReferencesFieldNumber = 11,
    kCommonSpecFieldNumber = 1,
    kParentFieldNumber = 2,
    kVirtualMachineInterfaceMacAddressesFieldNumber = 3,
    kVirtualNetworkReferenceFieldNumber = 4,
    kAllowedAddressPairsFieldNumber = 7,
    kPropertiesFieldNumber = 10,
    kVirtualMachineInterfaceDisablePolicyFieldNumber = 6,
    kPortSecurityEnabledFieldNumber = 8,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineReferences = 5;
  int virtualmachinereferences_size() const;
  private:
  int _internal_virtualmachinereferences_size() const;
  public:
  void clear_virtualmachinereferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_virtualmachinereferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_virtualmachinereferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_virtualmachinereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_virtualmachinereferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& virtualmachinereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_virtualmachinereferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      virtualmachinereferences() const;

  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 9;
  int virtualmachineinterfacereferences_size() const;
  private:
  int _internal_virtualmachineinterfacereferences_size() const;
  public:
  void clear_virtualmachineinterfacereferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_virtualmachineinterfacereferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_virtualmachineinterfacereferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_virtualmachineinterfacereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_virtualmachineinterfacereferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& virtualmachineinterfacereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_virtualmachineinterfacereferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      virtualmachineinterfacereferences() const;

  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 11;
  int tagreferences_size() const;
  private:
  int _internal_tagreferences_size() const;
  public:
  void clear_tagreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_tagreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_tagreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_tagreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_tagreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& tagreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_tagreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      tagreferences() const;

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .k8s.io.api.core.v1.ObjectReference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::k8s::io::api::core::v1::ObjectReference& parent() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::api::core::v1::ObjectReference* release_parent();
  ::k8s::io::api::core::v1::ObjectReference* mutable_parent();
  void set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent);
  private:
  const ::k8s::io::api::core::v1::ObjectReference& _internal_parent() const;
  ::k8s::io::api::core::v1::ObjectReference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::k8s::io::api::core::v1::ObjectReference* parent);
  ::k8s::io::api::core::v1::ObjectReference* unsafe_arena_release_parent();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses virtualMachineInterfaceMacAddresses = 3;
  bool has_virtualmachineinterfacemacaddresses() const;
  private:
  bool _internal_has_virtualmachineinterfacemacaddresses() const;
  public:
  void clear_virtualmachineinterfacemacaddresses();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses& virtualmachineinterfacemacaddresses() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* release_virtualmachineinterfacemacaddresses();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* mutable_virtualmachineinterfacemacaddresses();
  void set_allocated_virtualmachineinterfacemacaddresses(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* virtualmachineinterfacemacaddresses);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses& _internal_virtualmachineinterfacemacaddresses() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* _internal_mutable_virtualmachineinterfacemacaddresses();
  public:
  void unsafe_arena_set_allocated_virtualmachineinterfacemacaddresses(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* virtualmachineinterfacemacaddresses);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* unsafe_arena_release_virtualmachineinterfacemacaddresses();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualNetworkReference = 4;
  bool has_virtualnetworkreference() const;
  private:
  bool _internal_has_virtualnetworkreference() const;
  public:
  void clear_virtualnetworkreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& virtualnetworkreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_virtualnetworkreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_virtualnetworkreference();
  void set_allocated_virtualnetworkreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_virtualnetworkreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_virtualnetworkreference();
  public:
  void unsafe_arena_set_allocated_virtualnetworkreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_virtualnetworkreference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs allowedAddressPairs = 7;
  bool has_allowedaddresspairs() const;
  private:
  bool _internal_has_allowedaddresspairs() const;
  public:
  void clear_allowedaddresspairs();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs& allowedaddresspairs() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* release_allowedaddresspairs();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* mutable_allowedaddresspairs();
  void set_allocated_allowedaddresspairs(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* allowedaddresspairs);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs& _internal_allowedaddresspairs() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* _internal_mutable_allowedaddresspairs();
  public:
  void unsafe_arena_set_allocated_allowedaddresspairs(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* allowedaddresspairs);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* unsafe_arena_release_allowedaddresspairs();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProperties properties = 10;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties& properties() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* release_properties();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* mutable_properties();
  void set_allocated_properties(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* properties);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties& _internal_properties() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* properties);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* unsafe_arena_release_properties();

  // optional bool virtualMachineInterfaceDisablePolicy = 6;
  bool has_virtualmachineinterfacedisablepolicy() const;
  private:
  bool _internal_has_virtualmachineinterfacedisablepolicy() const;
  public:
  void clear_virtualmachineinterfacedisablepolicy();
  bool virtualmachineinterfacedisablepolicy() const;
  void set_virtualmachineinterfacedisablepolicy(bool value);
  private:
  bool _internal_virtualmachineinterfacedisablepolicy() const;
  void _internal_set_virtualmachineinterfacedisablepolicy(bool value);
  public:

  // optional bool portSecurityEnabled = 8;
  bool has_portsecurityenabled() const;
  private:
  bool _internal_has_portsecurityenabled() const;
  public:
  void clear_portsecurityenabled();
  bool portsecurityenabled() const;
  void set_portsecurityenabled(bool value);
  private:
  bool _internal_portsecurityenabled() const;
  void _internal_set_portsecurityenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > virtualmachinereferences_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > virtualmachineinterfacereferences_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > tagreferences_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::k8s::io::api::core::v1::ObjectReference* parent_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* virtualmachineinterfacemacaddresses_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* allowedaddresspairs_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* properties_;
  bool virtualmachineinterfacedisablepolicy_;
  bool portsecurityenabled_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachineInterfaceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus) */ {
 public:
  inline VirtualMachineInterfaceStatus() : VirtualMachineInterfaceStatus(nullptr) {}
  ~VirtualMachineInterfaceStatus() override;
  explicit constexpr VirtualMachineInterfaceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachineInterfaceStatus(const VirtualMachineInterfaceStatus& from);
  VirtualMachineInterfaceStatus(VirtualMachineInterfaceStatus&& from) noexcept
    : VirtualMachineInterfaceStatus() {
    *this = ::std::move(from);
  }

  inline VirtualMachineInterfaceStatus& operator=(const VirtualMachineInterfaceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachineInterfaceStatus& operator=(VirtualMachineInterfaceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachineInterfaceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachineInterfaceStatus* internal_default_instance() {
    return reinterpret_cast<const VirtualMachineInterfaceStatus*>(
               &_VirtualMachineInterfaceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(VirtualMachineInterfaceStatus& a, VirtualMachineInterfaceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachineInterfaceStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachineInterfaceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachineInterfaceStatus* New() const final {
    return new VirtualMachineInterfaceStatus();
  }

  VirtualMachineInterfaceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachineInterfaceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachineInterfaceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachineInterfaceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachineInterfaceStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus";
  }
  protected:
  explicit VirtualMachineInterfaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutingInstanceReferencesFieldNumber = 3,
    kCommonStatusFieldNumber = 1,
    kBgpRouterReferenceFieldNumber = 4,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference routingInstanceReferences = 3;
  int routinginstancereferences_size() const;
  private:
  int _internal_routinginstancereferences_size() const;
  public:
  void clear_routinginstancereferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference* mutable_routinginstancereferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference >*
      mutable_routinginstancereferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference& _internal_routinginstancereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference* _internal_add_routinginstancereferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference& routinginstancereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference* add_routinginstancereferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference >&
      routinginstancereferences() const;

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference bgpRouterReference = 4;
  bool has_bgprouterreference() const;
  private:
  bool _internal_has_bgprouterreference() const;
  public:
  void clear_bgprouterreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& bgprouterreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_bgprouterreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_bgprouterreference();
  void set_allocated_bgprouterreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* bgprouterreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_bgprouterreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_bgprouterreference();
  public:
  void unsafe_arena_set_allocated_bgprouterreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* bgprouterreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_bgprouterreference();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference > routinginstancereferences_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* bgprouterreference_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachineList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList) */ {
 public:
  inline VirtualMachineList() : VirtualMachineList(nullptr) {}
  ~VirtualMachineList() override;
  explicit constexpr VirtualMachineList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachineList(const VirtualMachineList& from);
  VirtualMachineList(VirtualMachineList&& from) noexcept
    : VirtualMachineList() {
    *this = ::std::move(from);
  }

  inline VirtualMachineList& operator=(const VirtualMachineList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachineList& operator=(VirtualMachineList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachineList& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachineList* internal_default_instance() {
    return reinterpret_cast<const VirtualMachineList*>(
               &_VirtualMachineList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(VirtualMachineList& a, VirtualMachineList& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachineList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachineList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachineList* New() const final {
    return new VirtualMachineList();
  }

  VirtualMachineList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachineList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachineList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachineList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachineList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList";
  }
  protected:
  explicit VirtualMachineList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachineSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec) */ {
 public:
  inline VirtualMachineSpec() : VirtualMachineSpec(nullptr) {}
  ~VirtualMachineSpec() override;
  explicit constexpr VirtualMachineSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachineSpec(const VirtualMachineSpec& from);
  VirtualMachineSpec(VirtualMachineSpec&& from) noexcept
    : VirtualMachineSpec() {
    *this = ::std::move(from);
  }

  inline VirtualMachineSpec& operator=(const VirtualMachineSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachineSpec& operator=(VirtualMachineSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachineSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachineSpec* internal_default_instance() {
    return reinterpret_cast<const VirtualMachineSpec*>(
               &_VirtualMachineSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(VirtualMachineSpec& a, VirtualMachineSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachineSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachineSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachineSpec* New() const final {
    return new VirtualMachineSpec();
  }

  VirtualMachineSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachineSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachineSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachineSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachineSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec";
  }
  protected:
  explicit VirtualMachineSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerTypeFieldNumber = 2,
    kServerNameFieldNumber = 3,
    kServerNamespaceFieldNumber = 4,
    kServerClusterNameFieldNumber = 5,
    kCommonSpecFieldNumber = 1,
  };
  // optional string serverType = 2;
  bool has_servertype() const;
  private:
  bool _internal_has_servertype() const;
  public:
  void clear_servertype();
  const std::string& servertype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servertype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servertype();
  PROTOBUF_MUST_USE_RESULT std::string* release_servertype();
  void set_allocated_servertype(std::string* servertype);
  private:
  const std::string& _internal_servertype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servertype(const std::string& value);
  std::string* _internal_mutable_servertype();
  public:

  // optional string serverName = 3;
  bool has_servername() const;
  private:
  bool _internal_has_servername() const;
  public:
  void clear_servername();
  const std::string& servername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servername();
  PROTOBUF_MUST_USE_RESULT std::string* release_servername();
  void set_allocated_servername(std::string* servername);
  private:
  const std::string& _internal_servername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servername(const std::string& value);
  std::string* _internal_mutable_servername();
  public:

  // optional string serverNamespace = 4;
  bool has_servernamespace() const;
  private:
  bool _internal_has_servernamespace() const;
  public:
  void clear_servernamespace();
  const std::string& servernamespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servernamespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servernamespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_servernamespace();
  void set_allocated_servernamespace(std::string* servernamespace);
  private:
  const std::string& _internal_servernamespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servernamespace(const std::string& value);
  std::string* _internal_mutable_servernamespace();
  public:

  // optional string serverClusterName = 5;
  bool has_serverclustername() const;
  private:
  bool _internal_has_serverclustername() const;
  public:
  void clear_serverclustername();
  const std::string& serverclustername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverclustername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverclustername();
  PROTOBUF_MUST_USE_RESULT std::string* release_serverclustername();
  void set_allocated_serverclustername(std::string* serverclustername);
  private:
  const std::string& _internal_serverclustername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverclustername(const std::string& value);
  std::string* _internal_mutable_serverclustername();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servertype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servername_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servernamespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverclustername_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualMachineStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus) */ {
 public:
  inline VirtualMachineStatus() : VirtualMachineStatus(nullptr) {}
  ~VirtualMachineStatus() override;
  explicit constexpr VirtualMachineStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualMachineStatus(const VirtualMachineStatus& from);
  VirtualMachineStatus(VirtualMachineStatus&& from) noexcept
    : VirtualMachineStatus() {
    *this = ::std::move(from);
  }

  inline VirtualMachineStatus& operator=(const VirtualMachineStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualMachineStatus& operator=(VirtualMachineStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualMachineStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualMachineStatus* internal_default_instance() {
    return reinterpret_cast<const VirtualMachineStatus*>(
               &_VirtualMachineStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(VirtualMachineStatus& a, VirtualMachineStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualMachineStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualMachineStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualMachineStatus* New() const final {
    return new VirtualMachineStatus();
  }

  VirtualMachineStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualMachineStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualMachineStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualMachineStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualMachineStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus";
  }
  protected:
  explicit VirtualMachineStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetwork final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork) */ {
 public:
  inline VirtualNetwork() : VirtualNetwork(nullptr) {}
  ~VirtualNetwork() override;
  explicit constexpr VirtualNetwork(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetwork(const VirtualNetwork& from);
  VirtualNetwork(VirtualNetwork&& from) noexcept
    : VirtualNetwork() {
    *this = ::std::move(from);
  }

  inline VirtualNetwork& operator=(const VirtualNetwork& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetwork& operator=(VirtualNetwork&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetwork& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetwork* internal_default_instance() {
    return reinterpret_cast<const VirtualNetwork*>(
               &_VirtualNetwork_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(VirtualNetwork& a, VirtualNetwork& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetwork* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetwork* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetwork* New() const final {
    return new VirtualNetwork();
  }

  VirtualNetwork* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetwork>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetwork& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetwork& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetwork* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork";
  }
  protected:
  explicit VirtualNetwork(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList) */ {
 public:
  inline VirtualNetworkList() : VirtualNetworkList(nullptr) {}
  ~VirtualNetworkList() override;
  explicit constexpr VirtualNetworkList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkList(const VirtualNetworkList& from);
  VirtualNetworkList(VirtualNetworkList&& from) noexcept
    : VirtualNetworkList() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkList& operator=(const VirtualNetworkList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkList& operator=(VirtualNetworkList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkList& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkList* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkList*>(
               &_VirtualNetworkList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(VirtualNetworkList& a, VirtualNetworkList& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkList* New() const final {
    return new VirtualNetworkList();
  }

  VirtualNetworkList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList";
  }
  protected:
  explicit VirtualNetworkList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkRouteTargetReferenceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList) */ {
 public:
  inline VirtualNetworkRouteTargetReferenceList() : VirtualNetworkRouteTargetReferenceList(nullptr) {}
  ~VirtualNetworkRouteTargetReferenceList() override;
  explicit constexpr VirtualNetworkRouteTargetReferenceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkRouteTargetReferenceList(const VirtualNetworkRouteTargetReferenceList& from);
  VirtualNetworkRouteTargetReferenceList(VirtualNetworkRouteTargetReferenceList&& from) noexcept
    : VirtualNetworkRouteTargetReferenceList() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkRouteTargetReferenceList& operator=(const VirtualNetworkRouteTargetReferenceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkRouteTargetReferenceList& operator=(VirtualNetworkRouteTargetReferenceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkRouteTargetReferenceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkRouteTargetReferenceList* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkRouteTargetReferenceList*>(
               &_VirtualNetworkRouteTargetReferenceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(VirtualNetworkRouteTargetReferenceList& a, VirtualNetworkRouteTargetReferenceList& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkRouteTargetReferenceList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkRouteTargetReferenceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkRouteTargetReferenceList* New() const final {
    return new VirtualNetworkRouteTargetReferenceList();
  }

  VirtualNetworkRouteTargetReferenceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkRouteTargetReferenceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkRouteTargetReferenceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkRouteTargetReferenceList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkRouteTargetReferenceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList";
  }
  protected:
  explicit VirtualNetworkRouteTargetReferenceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteTargetReferencesFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference routeTargetReferences = 1;
  int routetargetreferences_size() const;
  private:
  int _internal_routetargetreferences_size() const;
  public:
  void clear_routetargetreferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* mutable_routetargetreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference >*
      mutable_routetargetreferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& _internal_routetargetreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* _internal_add_routetargetreferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& routetargetreferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* add_routetargetreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference >&
      routetargetreferences() const;

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference > routetargetreferences_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkRouter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter) */ {
 public:
  inline VirtualNetworkRouter() : VirtualNetworkRouter(nullptr) {}
  ~VirtualNetworkRouter() override;
  explicit constexpr VirtualNetworkRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkRouter(const VirtualNetworkRouter& from);
  VirtualNetworkRouter(VirtualNetworkRouter&& from) noexcept
    : VirtualNetworkRouter() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkRouter& operator=(const VirtualNetworkRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkRouter& operator=(VirtualNetworkRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkRouter* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkRouter*>(
               &_VirtualNetworkRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(VirtualNetworkRouter& a, VirtualNetworkRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkRouter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkRouter* New() const final {
    return new VirtualNetworkRouter();
  }

  VirtualNetworkRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkRouter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkRouter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkRouter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkRouter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter";
  }
  protected:
  explicit VirtualNetworkRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkRouterEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry) */ {
 public:
  inline VirtualNetworkRouterEntry() : VirtualNetworkRouterEntry(nullptr) {}
  ~VirtualNetworkRouterEntry() override;
  explicit constexpr VirtualNetworkRouterEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkRouterEntry(const VirtualNetworkRouterEntry& from);
  VirtualNetworkRouterEntry(VirtualNetworkRouterEntry&& from) noexcept
    : VirtualNetworkRouterEntry() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkRouterEntry& operator=(const VirtualNetworkRouterEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkRouterEntry& operator=(VirtualNetworkRouterEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkRouterEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkRouterEntry* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkRouterEntry*>(
               &_VirtualNetworkRouterEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(VirtualNetworkRouterEntry& a, VirtualNetworkRouterEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkRouterEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkRouterEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkRouterEntry* New() const final {
    return new VirtualNetworkRouterEntry();
  }

  VirtualNetworkRouterEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkRouterEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkRouterEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkRouterEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkRouterEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry";
  }
  protected:
  explicit VirtualNetworkRouterEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualNetworkRouterSelectorFieldNumber = 1,
    kNamespaceSelectorFieldNumber = 2,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualNetworkRouterSelector = 1;
  bool has_virtualnetworkrouterselector() const;
  private:
  bool _internal_has_virtualnetworkrouterselector() const;
  public:
  void clear_virtualnetworkrouterselector();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& virtualnetworkrouterselector() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* release_virtualnetworkrouterselector();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* mutable_virtualnetworkrouterselector();
  void set_allocated_virtualnetworkrouterselector(::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkrouterselector);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& _internal_virtualnetworkrouterselector() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* _internal_mutable_virtualnetworkrouterselector();
  public:
  void unsafe_arena_set_allocated_virtualnetworkrouterselector(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkrouterselector);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* unsafe_arena_release_virtualnetworkrouterselector();

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
  bool has_namespaceselector() const;
  private:
  bool _internal_has_namespaceselector() const;
  public:
  void clear_namespaceselector();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& namespaceselector() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* release_namespaceselector();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* mutable_namespaceselector();
  void set_allocated_namespaceselector(::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* namespaceselector);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& _internal_namespaceselector() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* _internal_mutable_namespaceselector();
  public:
  void unsafe_arena_set_allocated_namespaceselector(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* namespaceselector);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* unsafe_arena_release_namespaceselector();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkrouterselector_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* namespaceselector_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkRouterList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList) */ {
 public:
  inline VirtualNetworkRouterList() : VirtualNetworkRouterList(nullptr) {}
  ~VirtualNetworkRouterList() override;
  explicit constexpr VirtualNetworkRouterList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkRouterList(const VirtualNetworkRouterList& from);
  VirtualNetworkRouterList(VirtualNetworkRouterList&& from) noexcept
    : VirtualNetworkRouterList() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkRouterList& operator=(const VirtualNetworkRouterList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkRouterList& operator=(VirtualNetworkRouterList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkRouterList& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkRouterList* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkRouterList*>(
               &_VirtualNetworkRouterList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(VirtualNetworkRouterList& a, VirtualNetworkRouterList& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkRouterList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkRouterList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkRouterList* New() const final {
    return new VirtualNetworkRouterList();
  }

  VirtualNetworkRouterList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkRouterList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkRouterList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkRouterList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkRouterList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList";
  }
  protected:
  explicit VirtualNetworkRouterList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkRouterSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec) */ {
 public:
  inline VirtualNetworkRouterSpec() : VirtualNetworkRouterSpec(nullptr) {}
  ~VirtualNetworkRouterSpec() override;
  explicit constexpr VirtualNetworkRouterSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkRouterSpec(const VirtualNetworkRouterSpec& from);
  VirtualNetworkRouterSpec(VirtualNetworkRouterSpec&& from) noexcept
    : VirtualNetworkRouterSpec() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkRouterSpec& operator=(const VirtualNetworkRouterSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkRouterSpec& operator=(VirtualNetworkRouterSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkRouterSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkRouterSpec* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkRouterSpec*>(
               &_VirtualNetworkRouterSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(VirtualNetworkRouterSpec& a, VirtualNetworkRouterSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkRouterSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkRouterSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkRouterSpec* New() const final {
    return new VirtualNetworkRouterSpec();
  }

  VirtualNetworkRouterSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkRouterSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkRouterSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkRouterSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkRouterSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec";
  }
  protected:
  explicit VirtualNetworkRouterSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
    kCommonSpecFieldNumber = 1,
    kVirtualNetworkSelectorFieldNumber = 3,
    kImportFieldNumber = 4,
  };
  // optional string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualNetworkSelector = 3;
  bool has_virtualnetworkselector() const;
  private:
  bool _internal_has_virtualnetworkselector() const;
  public:
  void clear_virtualnetworkselector();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& virtualnetworkselector() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* release_virtualnetworkselector();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* mutable_virtualnetworkselector();
  void set_allocated_virtualnetworkselector(::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkselector);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& _internal_virtualnetworkselector() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* _internal_mutable_virtualnetworkselector();
  public:
  void unsafe_arena_set_allocated_virtualnetworkselector(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkselector);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* unsafe_arena_release_virtualnetworkselector();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter import = 4;
  bool has_import() const;
  private:
  bool _internal_has_import() const;
  public:
  void clear_import();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter& import() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* release_import();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* mutable_import();
  void set_allocated_import(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* import);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter& _internal_import() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* _internal_mutable_import();
  public:
  void unsafe_arena_set_allocated_import(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* import);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* unsafe_arena_release_import();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkselector_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* import_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkRouterStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus) */ {
 public:
  inline VirtualNetworkRouterStatus() : VirtualNetworkRouterStatus(nullptr) {}
  ~VirtualNetworkRouterStatus() override;
  explicit constexpr VirtualNetworkRouterStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkRouterStatus(const VirtualNetworkRouterStatus& from);
  VirtualNetworkRouterStatus(VirtualNetworkRouterStatus&& from) noexcept
    : VirtualNetworkRouterStatus() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkRouterStatus& operator=(const VirtualNetworkRouterStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkRouterStatus& operator=(VirtualNetworkRouterStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkRouterStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkRouterStatus* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkRouterStatus*>(
               &_VirtualNetworkRouterStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(VirtualNetworkRouterStatus& a, VirtualNetworkRouterStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkRouterStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkRouterStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkRouterStatus* New() const final {
    return new VirtualNetworkRouterStatus();
  }

  VirtualNetworkRouterStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkRouterStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkRouterStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkRouterStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkRouterStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus";
  }
  protected:
  explicit VirtualNetworkRouterStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec) */ {
 public:
  inline VirtualNetworkSpec() : VirtualNetworkSpec(nullptr) {}
  ~VirtualNetworkSpec() override;
  explicit constexpr VirtualNetworkSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkSpec(const VirtualNetworkSpec& from);
  VirtualNetworkSpec(VirtualNetworkSpec&& from) noexcept
    : VirtualNetworkSpec() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkSpec& operator=(const VirtualNetworkSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkSpec& operator=(VirtualNetworkSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkSpec* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkSpec*>(
               &_VirtualNetworkSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(VirtualNetworkSpec& a, VirtualNetworkSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkSpec* New() const final {
    return new VirtualNetworkSpec();
  }

  VirtualNetworkSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec";
  }
  protected:
  explicit VirtualNetworkSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteTargetListFieldNumber = 5,
    kImportRouteTargetListFieldNumber = 6,
    kExportRouteTargetListFieldNumber = 7,
    kCommonSpecFieldNumber = 1,
    kV4SubnetReferenceFieldNumber = 3,
    kV6SubnetReferenceFieldNumber = 4,
    kVirtualNetworkPropertiesFieldNumber = 8,
    kProviderNetworkReferenceFieldNumber = 9,
    kFabricSNATFieldNumber = 2,
    kIsProviderNetworkFieldNumber = 10,
    kFabricForwardingFieldNumber = 11,
  };
  // repeated string routeTargetList = 5;
  int routetargetlist_size() const;
  private:
  int _internal_routetargetlist_size() const;
  public:
  void clear_routetargetlist();
  const std::string& routetargetlist(int index) const;
  std::string* mutable_routetargetlist(int index);
  void set_routetargetlist(int index, const std::string& value);
  void set_routetargetlist(int index, std::string&& value);
  void set_routetargetlist(int index, const char* value);
  void set_routetargetlist(int index, const char* value, size_t size);
  std::string* add_routetargetlist();
  void add_routetargetlist(const std::string& value);
  void add_routetargetlist(std::string&& value);
  void add_routetargetlist(const char* value);
  void add_routetargetlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& routetargetlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_routetargetlist();
  private:
  const std::string& _internal_routetargetlist(int index) const;
  std::string* _internal_add_routetargetlist();
  public:

  // repeated string importRouteTargetList = 6;
  int importroutetargetlist_size() const;
  private:
  int _internal_importroutetargetlist_size() const;
  public:
  void clear_importroutetargetlist();
  const std::string& importroutetargetlist(int index) const;
  std::string* mutable_importroutetargetlist(int index);
  void set_importroutetargetlist(int index, const std::string& value);
  void set_importroutetargetlist(int index, std::string&& value);
  void set_importroutetargetlist(int index, const char* value);
  void set_importroutetargetlist(int index, const char* value, size_t size);
  std::string* add_importroutetargetlist();
  void add_importroutetargetlist(const std::string& value);
  void add_importroutetargetlist(std::string&& value);
  void add_importroutetargetlist(const char* value);
  void add_importroutetargetlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& importroutetargetlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_importroutetargetlist();
  private:
  const std::string& _internal_importroutetargetlist(int index) const;
  std::string* _internal_add_importroutetargetlist();
  public:

  // repeated string exportRouteTargetList = 7;
  int exportroutetargetlist_size() const;
  private:
  int _internal_exportroutetargetlist_size() const;
  public:
  void clear_exportroutetargetlist();
  const std::string& exportroutetargetlist(int index) const;
  std::string* mutable_exportroutetargetlist(int index);
  void set_exportroutetargetlist(int index, const std::string& value);
  void set_exportroutetargetlist(int index, std::string&& value);
  void set_exportroutetargetlist(int index, const char* value);
  void set_exportroutetargetlist(int index, const char* value, size_t size);
  std::string* add_exportroutetargetlist();
  void add_exportroutetargetlist(const std::string& value);
  void add_exportroutetargetlist(std::string&& value);
  void add_exportroutetargetlist(const char* value);
  void add_exportroutetargetlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exportroutetargetlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exportroutetargetlist();
  private:
  const std::string& _internal_exportroutetargetlist(int index) const;
  std::string* _internal_add_exportroutetargetlist();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference v4SubnetReference = 3;
  bool has_v4subnetreference() const;
  private:
  bool _internal_has_v4subnetreference() const;
  public:
  void clear_v4subnetreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& v4subnetreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_v4subnetreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_v4subnetreference();
  void set_allocated_v4subnetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v4subnetreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_v4subnetreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_v4subnetreference();
  public:
  void unsafe_arena_set_allocated_v4subnetreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v4subnetreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_v4subnetreference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference v6SubnetReference = 4;
  bool has_v6subnetreference() const;
  private:
  bool _internal_has_v6subnetreference() const;
  public:
  void clear_v6subnetreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& v6subnetreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_v6subnetreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_v6subnetreference();
  void set_allocated_v6subnetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v6subnetreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_v6subnetreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_v6subnetreference();
  public:
  void unsafe_arena_set_allocated_v6subnetreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v6subnetreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_v6subnetreference();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType virtualNetworkProperties = 8;
  bool has_virtualnetworkproperties() const;
  private:
  bool _internal_has_virtualnetworkproperties() const;
  public:
  void clear_virtualnetworkproperties();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType& virtualnetworkproperties() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* release_virtualnetworkproperties();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* mutable_virtualnetworkproperties();
  void set_allocated_virtualnetworkproperties(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* virtualnetworkproperties);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType& _internal_virtualnetworkproperties() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* _internal_mutable_virtualnetworkproperties();
  public:
  void unsafe_arena_set_allocated_virtualnetworkproperties(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* virtualnetworkproperties);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* unsafe_arena_release_virtualnetworkproperties();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference providerNetworkReference = 9;
  bool has_providernetworkreference() const;
  private:
  bool _internal_has_providernetworkreference() const;
  public:
  void clear_providernetworkreference();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& providernetworkreference() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* release_providernetworkreference();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_providernetworkreference();
  void set_allocated_providernetworkreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* providernetworkreference);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_providernetworkreference() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_mutable_providernetworkreference();
  public:
  void unsafe_arena_set_allocated_providernetworkreference(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* providernetworkreference);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* unsafe_arena_release_providernetworkreference();

  // optional bool fabricSNAT = 2;
  bool has_fabricsnat() const;
  private:
  bool _internal_has_fabricsnat() const;
  public:
  void clear_fabricsnat();
  bool fabricsnat() const;
  void set_fabricsnat(bool value);
  private:
  bool _internal_fabricsnat() const;
  void _internal_set_fabricsnat(bool value);
  public:

  // optional bool isProviderNetwork = 10;
  bool has_isprovidernetwork() const;
  private:
  bool _internal_has_isprovidernetwork() const;
  public:
  void clear_isprovidernetwork();
  bool isprovidernetwork() const;
  void set_isprovidernetwork(bool value);
  private:
  bool _internal_isprovidernetwork() const;
  void _internal_set_isprovidernetwork(bool value);
  public:

  // optional bool fabricForwarding = 11;
  bool has_fabricforwarding() const;
  private:
  bool _internal_has_fabricforwarding() const;
  public:
  void clear_fabricforwarding();
  bool fabricforwarding() const;
  void set_fabricforwarding(bool value);
  private:
  bool _internal_fabricforwarding() const;
  void _internal_set_fabricforwarding(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> routetargetlist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> importroutetargetlist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exportroutetargetlist_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v4subnetreference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v6subnetreference_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* virtualnetworkproperties_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* providernetworkreference_;
  bool fabricsnat_;
  bool isprovidernetwork_;
  bool fabricforwarding_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus) */ {
 public:
  inline VirtualNetworkStatus() : VirtualNetworkStatus(nullptr) {}
  ~VirtualNetworkStatus() override;
  explicit constexpr VirtualNetworkStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkStatus(const VirtualNetworkStatus& from);
  VirtualNetworkStatus(VirtualNetworkStatus&& from) noexcept
    : VirtualNetworkStatus() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkStatus& operator=(const VirtualNetworkStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkStatus& operator=(VirtualNetworkStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkStatus* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkStatus*>(
               &_VirtualNetworkStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(VirtualNetworkStatus& a, VirtualNetworkStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkStatus* New() const final {
    return new VirtualNetworkStatus();
  }

  VirtualNetworkStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus";
  }
  protected:
  explicit VirtualNetworkStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
    kVirtualNetworkNetworkIdFieldNumber = 2,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // optional int64 virtualNetworkNetworkId = 2;
  bool has_virtualnetworknetworkid() const;
  private:
  bool _internal_has_virtualnetworknetworkid() const;
  public:
  void clear_virtualnetworknetworkid();
  ::PROTOBUF_NAMESPACE_ID::int64 virtualnetworknetworkid() const;
  void set_virtualnetworknetworkid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_virtualnetworknetworkid() const;
  void _internal_set_virtualnetworknetworkid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  ::PROTOBUF_NAMESPACE_ID::int64 virtualnetworknetworkid_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualNetworkType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType) */ {
 public:
  inline VirtualNetworkType() : VirtualNetworkType(nullptr) {}
  ~VirtualNetworkType() override;
  explicit constexpr VirtualNetworkType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualNetworkType(const VirtualNetworkType& from);
  VirtualNetworkType(VirtualNetworkType&& from) noexcept
    : VirtualNetworkType() {
    *this = ::std::move(from);
  }

  inline VirtualNetworkType& operator=(const VirtualNetworkType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualNetworkType& operator=(VirtualNetworkType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualNetworkType& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualNetworkType* internal_default_instance() {
    return reinterpret_cast<const VirtualNetworkType*>(
               &_VirtualNetworkType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(VirtualNetworkType& a, VirtualNetworkType& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualNetworkType* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualNetworkType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualNetworkType* New() const final {
    return new VirtualNetworkType();
  }

  VirtualNetworkType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualNetworkType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualNetworkType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualNetworkType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualNetworkType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType";
  }
  protected:
  explicit VirtualNetworkType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpfFieldNumber = 1,
    kForwardingModeFieldNumber = 2,
  };
  // optional string rpf = 1;
  bool has_rpf() const;
  private:
  bool _internal_has_rpf() const;
  public:
  void clear_rpf();
  const std::string& rpf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rpf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rpf();
  PROTOBUF_MUST_USE_RESULT std::string* release_rpf();
  void set_allocated_rpf(std::string* rpf);
  private:
  const std::string& _internal_rpf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rpf(const std::string& value);
  std::string* _internal_mutable_rpf();
  public:

  // optional string forwardingMode = 2;
  bool has_forwardingmode() const;
  private:
  bool _internal_has_forwardingmode() const;
  public:
  void clear_forwardingmode();
  const std::string& forwardingmode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_forwardingmode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_forwardingmode();
  PROTOBUF_MUST_USE_RESULT std::string* release_forwardingmode();
  void set_allocated_forwardingmode(std::string* forwardingmode);
  private:
  const std::string& _internal_forwardingmode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_forwardingmode(const std::string& value);
  std::string* _internal_mutable_forwardingmode();
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpf_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr forwardingmode_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualRouter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter) */ {
 public:
  inline VirtualRouter() : VirtualRouter(nullptr) {}
  ~VirtualRouter() override;
  explicit constexpr VirtualRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualRouter(const VirtualRouter& from);
  VirtualRouter(VirtualRouter&& from) noexcept
    : VirtualRouter() {
    *this = ::std::move(from);
  }

  inline VirtualRouter& operator=(const VirtualRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualRouter& operator=(VirtualRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualRouter* internal_default_instance() {
    return reinterpret_cast<const VirtualRouter*>(
               &_VirtualRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(VirtualRouter& a, VirtualRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualRouter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualRouter* New() const final {
    return new VirtualRouter();
  }

  VirtualRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualRouter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualRouter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualRouter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualRouter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter";
  }
  protected:
  explicit VirtualRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec& spec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* release_spec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* mutable_spec();
  void set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* spec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec& _internal_spec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* spec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* unsafe_arena_release_spec();

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* release_status();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* mutable_status();
  void set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* status);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus& _internal_status() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* status);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* spec_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* status_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualRouterList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList) */ {
 public:
  inline VirtualRouterList() : VirtualRouterList(nullptr) {}
  ~VirtualRouterList() override;
  explicit constexpr VirtualRouterList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualRouterList(const VirtualRouterList& from);
  VirtualRouterList(VirtualRouterList&& from) noexcept
    : VirtualRouterList() {
    *this = ::std::move(from);
  }

  inline VirtualRouterList& operator=(const VirtualRouterList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualRouterList& operator=(VirtualRouterList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualRouterList& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualRouterList* internal_default_instance() {
    return reinterpret_cast<const VirtualRouterList*>(
               &_VirtualRouterList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(VirtualRouterList& a, VirtualRouterList& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualRouterList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualRouterList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualRouterList* New() const final {
    return new VirtualRouterList();
  }

  VirtualRouterList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualRouterList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualRouterList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualRouterList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualRouterList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList";
  }
  protected:
  explicit VirtualRouterList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter >*
      mutable_items();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter& _internal_items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter* _internal_add_items();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter& items(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter > items_;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualRouterSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec) */ {
 public:
  inline VirtualRouterSpec() : VirtualRouterSpec(nullptr) {}
  ~VirtualRouterSpec() override;
  explicit constexpr VirtualRouterSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualRouterSpec(const VirtualRouterSpec& from);
  VirtualRouterSpec(VirtualRouterSpec&& from) noexcept
    : VirtualRouterSpec() {
    *this = ::std::move(from);
  }

  inline VirtualRouterSpec& operator=(const VirtualRouterSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualRouterSpec& operator=(VirtualRouterSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualRouterSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualRouterSpec* internal_default_instance() {
    return reinterpret_cast<const VirtualRouterSpec*>(
               &_VirtualRouterSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(VirtualRouterSpec& a, VirtualRouterSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualRouterSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualRouterSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualRouterSpec* New() const final {
    return new VirtualRouterSpec();
  }

  VirtualRouterSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualRouterSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualRouterSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualRouterSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualRouterSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec";
  }
  protected:
  explicit VirtualRouterSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualMachineReferencesFieldNumber = 6,
    kVirtualRouterIPAddressFieldNumber = 4,
    kVirtualRouterTypeFieldNumber = 5,
    kCommonSpecFieldNumber = 1,
    kParentFieldNumber = 2,
    kVirtualRouterDpdkEnabledFieldNumber = 3,
  };
  // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineReferences = 6;
  int virtualmachinereferences_size() const;
  private:
  int _internal_virtualmachinereferences_size() const;
  public:
  void clear_virtualmachinereferences();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* mutable_virtualmachinereferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
      mutable_virtualmachinereferences();
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& _internal_virtualmachinereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _internal_add_virtualmachinereferences();
  public:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& virtualmachinereferences(int index) const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* add_virtualmachinereferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
      virtualmachinereferences() const;

  // optional string virtualRouterIPAddress = 4;
  bool has_virtualrouteripaddress() const;
  private:
  bool _internal_has_virtualrouteripaddress() const;
  public:
  void clear_virtualrouteripaddress();
  const std::string& virtualrouteripaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_virtualrouteripaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_virtualrouteripaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_virtualrouteripaddress();
  void set_allocated_virtualrouteripaddress(std::string* virtualrouteripaddress);
  private:
  const std::string& _internal_virtualrouteripaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_virtualrouteripaddress(const std::string& value);
  std::string* _internal_mutable_virtualrouteripaddress();
  public:

  // optional string virtualRouterType = 5;
  bool has_virtualroutertype() const;
  private:
  bool _internal_has_virtualroutertype() const;
  public:
  void clear_virtualroutertype();
  const std::string& virtualroutertype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_virtualroutertype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_virtualroutertype();
  PROTOBUF_MUST_USE_RESULT std::string* release_virtualroutertype();
  void set_allocated_virtualroutertype(std::string* virtualroutertype);
  private:
  const std::string& _internal_virtualroutertype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_virtualroutertype(const std::string& value);
  std::string* _internal_mutable_virtualroutertype();
  public:

  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
  bool has_commonspec() const;
  private:
  bool _internal_has_commonspec() const;
  public:
  void clear_commonspec();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& commonspec() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* release_commonspec();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* mutable_commonspec();
  void set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& _internal_commonspec() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _internal_mutable_commonspec();
  public:
  void unsafe_arena_set_allocated_commonspec(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* unsafe_arena_release_commonspec();

  // optional .k8s.io.api.core.v1.ObjectReference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::k8s::io::api::core::v1::ObjectReference& parent() const;
  PROTOBUF_MUST_USE_RESULT ::k8s::io::api::core::v1::ObjectReference* release_parent();
  ::k8s::io::api::core::v1::ObjectReference* mutable_parent();
  void set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent);
  private:
  const ::k8s::io::api::core::v1::ObjectReference& _internal_parent() const;
  ::k8s::io::api::core::v1::ObjectReference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::k8s::io::api::core::v1::ObjectReference* parent);
  ::k8s::io::api::core::v1::ObjectReference* unsafe_arena_release_parent();

  // optional bool virtualRouterDpdkEnabled = 3;
  bool has_virtualrouterdpdkenabled() const;
  private:
  bool _internal_has_virtualrouterdpdkenabled() const;
  public:
  void clear_virtualrouterdpdkenabled();
  bool virtualrouterdpdkenabled() const;
  void set_virtualrouterdpdkenabled(bool value);
  private:
  bool _internal_virtualrouterdpdkenabled() const;
  void _internal_set_virtualrouterdpdkenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference > virtualmachinereferences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr virtualrouteripaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr virtualroutertype_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec_;
  ::k8s::io::api::core::v1::ObjectReference* parent_;
  bool virtualrouterdpdkenabled_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// -------------------------------------------------------------------

class VirtualRouterStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus) */ {
 public:
  inline VirtualRouterStatus() : VirtualRouterStatus(nullptr) {}
  ~VirtualRouterStatus() override;
  explicit constexpr VirtualRouterStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualRouterStatus(const VirtualRouterStatus& from);
  VirtualRouterStatus(VirtualRouterStatus&& from) noexcept
    : VirtualRouterStatus() {
    *this = ::std::move(from);
  }

  inline VirtualRouterStatus& operator=(const VirtualRouterStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualRouterStatus& operator=(VirtualRouterStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualRouterStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualRouterStatus* internal_default_instance() {
    return reinterpret_cast<const VirtualRouterStatus*>(
               &_VirtualRouterStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(VirtualRouterStatus& a, VirtualRouterStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualRouterStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualRouterStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualRouterStatus* New() const final {
    return new VirtualRouterStatus();
  }

  VirtualRouterStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualRouterStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualRouterStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualRouterStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualRouterStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus";
  }
  protected:
  explicit VirtualRouterStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonStatusFieldNumber = 1,
  };
  // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
  bool has_commonstatus() const;
  private:
  bool _internal_has_commonstatus() const;
  public:
  void clear_commonstatus();
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& commonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* release_commonstatus();
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* mutable_commonstatus();
  void set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  private:
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& _internal_commonstatus() const;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _internal_mutable_commonstatus();
  public:
  void unsafe_arena_set_allocated_commonstatus(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus);
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* unsafe_arena_release_commonstatus();

  // @@protoc_insertion_point(class_scope:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus_;
  friend struct ::TableStruct_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// APSAttribute

// optional string sequence = 1;
inline bool APSAttribute::_internal_has_sequence() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool APSAttribute::has_sequence() const {
  return _internal_has_sequence();
}
inline void APSAttribute::clear_sequence() {
  sequence_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& APSAttribute::sequence() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute.sequence)
  return _internal_sequence();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APSAttribute::set_sequence(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sequence_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute.sequence)
}
inline std::string* APSAttribute::mutable_sequence() {
  std::string* _s = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute.sequence)
  return _s;
}
inline const std::string& APSAttribute::_internal_sequence() const {
  return sequence_.Get();
}
inline void APSAttribute::_internal_set_sequence(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sequence_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* APSAttribute::_internal_mutable_sequence() {
  _has_bits_[0] |= 0x00000001u;
  return sequence_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* APSAttribute::release_sequence() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute.sequence)
  if (!_internal_has_sequence()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sequence_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void APSAttribute::set_allocated_sequence(std::string* sequence) {
  if (sequence != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sequence_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sequence,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute.sequence)
}

// -------------------------------------------------------------------

// AddressFamilies

// repeated string family = 1;
inline int AddressFamilies::_internal_family_size() const {
  return family_.size();
}
inline int AddressFamilies::family_size() const {
  return _internal_family_size();
}
inline void AddressFamilies::clear_family() {
  family_.Clear();
}
inline std::string* AddressFamilies::add_family() {
  std::string* _s = _internal_add_family();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
  return _s;
}
inline const std::string& AddressFamilies::_internal_family(int index) const {
  return family_.Get(index);
}
inline const std::string& AddressFamilies::family(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
  return _internal_family(index);
}
inline std::string* AddressFamilies::mutable_family(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
  return family_.Mutable(index);
}
inline void AddressFamilies::set_family(int index, const std::string& value) {
  family_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
}
inline void AddressFamilies::set_family(int index, std::string&& value) {
  family_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
}
inline void AddressFamilies::set_family(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  family_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
}
inline void AddressFamilies::set_family(int index, const char* value, size_t size) {
  family_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
}
inline std::string* AddressFamilies::_internal_add_family() {
  return family_.Add();
}
inline void AddressFamilies::add_family(const std::string& value) {
  family_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
}
inline void AddressFamilies::add_family(std::string&& value) {
  family_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
}
inline void AddressFamilies::add_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  family_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
}
inline void AddressFamilies::add_family(const char* value, size_t size) {
  family_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AddressFamilies::family() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
  return family_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AddressFamilies::mutable_family() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies.family)
  return &family_;
}

// -------------------------------------------------------------------

// AddressGroup

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool AddressGroup::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool AddressGroup::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& AddressGroup::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& AddressGroup::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.metadata)
  return _internal_metadata();
}
inline void AddressGroup::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* AddressGroup::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* AddressGroup::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* AddressGroup::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* AddressGroup::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.metadata)
  return _msg;
}
inline void AddressGroup::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec spec = 2;
inline bool AddressGroup::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool AddressGroup::has_spec() const {
  return _internal_has_spec();
}
inline void AddressGroup::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec& AddressGroup::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AddressGroupSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec& AddressGroup::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.spec)
  return _internal_spec();
}
inline void AddressGroup::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* AddressGroup::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* AddressGroup::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* AddressGroup::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* AddressGroup::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.spec)
  return _msg;
}
inline void AddressGroup::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus status = 3;
inline bool AddressGroup::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool AddressGroup::has_status() const {
  return _internal_has_status();
}
inline void AddressGroup::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus& AddressGroup::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AddressGroupStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus& AddressGroup::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.status)
  return _internal_status();
}
inline void AddressGroup::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* AddressGroup::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* AddressGroup::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* AddressGroup::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* AddressGroup::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.status)
  return _msg;
}
inline void AddressGroup::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup.status)
}

// -------------------------------------------------------------------

// AddressGroupList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool AddressGroupList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool AddressGroupList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& AddressGroupList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& AddressGroupList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.metadata)
  return _internal_metadata();
}
inline void AddressGroupList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* AddressGroupList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* AddressGroupList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* AddressGroupList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* AddressGroupList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.metadata)
  return _msg;
}
inline void AddressGroupList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup items = 2;
inline int AddressGroupList::_internal_items_size() const {
  return items_.size();
}
inline int AddressGroupList::items_size() const {
  return _internal_items_size();
}
inline void AddressGroupList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup* AddressGroupList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup >*
AddressGroupList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup& AddressGroupList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup& AddressGroupList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup* AddressGroupList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup* AddressGroupList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroup >&
AddressGroupList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupList.items)
  return items_;
}

// -------------------------------------------------------------------

// AddressGroupPrefix

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet subnet = 1;
inline int AddressGroupPrefix::_internal_subnet_size() const {
  return subnet_.size();
}
inline int AddressGroupPrefix::subnet_size() const {
  return _internal_subnet_size();
}
inline void AddressGroupPrefix::clear_subnet() {
  subnet_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* AddressGroupPrefix::mutable_subnet(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix.subnet)
  return subnet_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet >*
AddressGroupPrefix::mutable_subnet() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix.subnet)
  return &subnet_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet& AddressGroupPrefix::_internal_subnet(int index) const {
  return subnet_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet& AddressGroupPrefix::subnet(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix.subnet)
  return _internal_subnet(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* AddressGroupPrefix::_internal_add_subnet() {
  return subnet_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* AddressGroupPrefix::add_subnet() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* _add = _internal_add_subnet();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix.subnet)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet >&
AddressGroupPrefix::subnet() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix.subnet)
  return subnet_;
}

// -------------------------------------------------------------------

// AddressGroupSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool AddressGroupSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool AddressGroupSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void AddressGroupSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& AddressGroupSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& AddressGroupSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.commonSpec)
  return _internal_commonspec();
}
inline void AddressGroupSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* AddressGroupSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* AddressGroupSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* AddressGroupSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* AddressGroupSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.commonSpec)
  return _msg;
}
inline void AddressGroupSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.commonSpec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix addressGroupPrefixes = 2;
inline bool AddressGroupSpec::_internal_has_addressgroupprefixes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || addressgroupprefixes_ != nullptr);
  return value;
}
inline bool AddressGroupSpec::has_addressgroupprefixes() const {
  return _internal_has_addressgroupprefixes();
}
inline void AddressGroupSpec::clear_addressgroupprefixes() {
  if (addressgroupprefixes_ != nullptr) addressgroupprefixes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix& AddressGroupSpec::_internal_addressgroupprefixes() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* p = addressgroupprefixes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AddressGroupPrefix_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix& AddressGroupSpec::addressgroupprefixes() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.addressGroupPrefixes)
  return _internal_addressgroupprefixes();
}
inline void AddressGroupSpec::unsafe_arena_set_allocated_addressgroupprefixes(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* addressgroupprefixes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addressgroupprefixes_);
  }
  addressgroupprefixes_ = addressgroupprefixes;
  if (addressgroupprefixes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.addressGroupPrefixes)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* AddressGroupSpec::release_addressgroupprefixes() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* temp = addressgroupprefixes_;
  addressgroupprefixes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* AddressGroupSpec::unsafe_arena_release_addressgroupprefixes() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.addressGroupPrefixes)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* temp = addressgroupprefixes_;
  addressgroupprefixes_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* AddressGroupSpec::_internal_mutable_addressgroupprefixes() {
  _has_bits_[0] |= 0x00000002u;
  if (addressgroupprefixes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix>(GetArenaForAllocation());
    addressgroupprefixes_ = p;
  }
  return addressgroupprefixes_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* AddressGroupSpec::mutable_addressgroupprefixes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* _msg = _internal_mutable_addressgroupprefixes();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.addressGroupPrefixes)
  return _msg;
}
inline void AddressGroupSpec::set_allocated_addressgroupprefixes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix* addressgroupprefixes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addressgroupprefixes_;
  }
  if (addressgroupprefixes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressGroupPrefix>::GetOwningArena(addressgroupprefixes);
    if (message_arena != submessage_arena) {
      addressgroupprefixes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addressgroupprefixes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  addressgroupprefixes_ = addressgroupprefixes;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec.addressGroupPrefixes)
}

// -------------------------------------------------------------------

// AddressGroupStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool AddressGroupStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool AddressGroupStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void AddressGroupStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& AddressGroupStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& AddressGroupStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus.commonStatus)
  return _internal_commonstatus();
}
inline void AddressGroupStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* AddressGroupStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* AddressGroupStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* AddressGroupStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* AddressGroupStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus.commonStatus)
  return _msg;
}
inline void AddressGroupStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus.commonStatus)
}

// -------------------------------------------------------------------

// AllowedAddressPair

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet ip = 1;
inline bool AllowedAddressPair::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || ip_ != nullptr);
  return value;
}
inline bool AllowedAddressPair::has_ip() const {
  return _internal_has_ip();
}
inline void AllowedAddressPair::clear_ip() {
  if (ip_ != nullptr) ip_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet& AllowedAddressPair::_internal_ip() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* p = ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AllowedAddressPairSubnet_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet& AllowedAddressPair::ip() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.ip)
  return _internal_ip();
}
inline void AllowedAddressPair::unsafe_arena_set_allocated_ip(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_);
  }
  ip_ = ip;
  if (ip) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.ip)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* AllowedAddressPair::release_ip() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* temp = ip_;
  ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* AllowedAddressPair::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.ip)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* temp = ip_;
  ip_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* AllowedAddressPair::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000004u;
  if (ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet>(GetArenaForAllocation());
    ip_ = p;
  }
  return ip_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* AllowedAddressPair::mutable_ip() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* _msg = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.ip)
  return _msg;
}
inline void AllowedAddressPair::set_allocated_ip(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet* ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ip_;
  }
  if (ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairSubnet>::GetOwningArena(ip);
    if (message_arena != submessage_arena) {
      ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ip_ = ip;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.ip)
}

// optional string mac = 2;
inline bool AllowedAddressPair::_internal_has_mac() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllowedAddressPair::has_mac() const {
  return _internal_has_mac();
}
inline void AllowedAddressPair::clear_mac() {
  mac_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllowedAddressPair::mac() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllowedAddressPair::set_mac(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.mac)
}
inline std::string* AllowedAddressPair::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.mac)
  return _s;
}
inline const std::string& AllowedAddressPair::_internal_mac() const {
  return mac_.Get();
}
inline void AllowedAddressPair::_internal_set_mac(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AllowedAddressPair::_internal_mutable_mac() {
  _has_bits_[0] |= 0x00000001u;
  return mac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AllowedAddressPair::release_mac() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.mac)
  if (!_internal_has_mac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return mac_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AllowedAddressPair::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.mac)
}

// optional string addressMode = 3;
inline bool AllowedAddressPair::_internal_has_addressmode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AllowedAddressPair::has_addressmode() const {
  return _internal_has_addressmode();
}
inline void AllowedAddressPair::clear_addressmode() {
  addressmode_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AllowedAddressPair::addressmode() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.addressMode)
  return _internal_addressmode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllowedAddressPair::set_addressmode(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 addressmode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.addressMode)
}
inline std::string* AllowedAddressPair::mutable_addressmode() {
  std::string* _s = _internal_mutable_addressmode();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.addressMode)
  return _s;
}
inline const std::string& AllowedAddressPair::_internal_addressmode() const {
  return addressmode_.Get();
}
inline void AllowedAddressPair::_internal_set_addressmode(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  addressmode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AllowedAddressPair::_internal_mutable_addressmode() {
  _has_bits_[0] |= 0x00000002u;
  return addressmode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AllowedAddressPair::release_addressmode() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.addressMode)
  if (!_internal_has_addressmode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return addressmode_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AllowedAddressPair::set_allocated_addressmode(std::string* addressmode) {
  if (addressmode != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  addressmode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addressmode,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair.addressMode)
}

// -------------------------------------------------------------------

// AllowedAddressPairSubnet

// optional string ipPrefix = 1;
inline bool AllowedAddressPairSubnet::_internal_has_ipprefix() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllowedAddressPairSubnet::has_ipprefix() const {
  return _internal_has_ipprefix();
}
inline void AllowedAddressPairSubnet::clear_ipprefix() {
  ipprefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllowedAddressPairSubnet::ipprefix() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefix)
  return _internal_ipprefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllowedAddressPairSubnet::set_ipprefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ipprefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefix)
}
inline std::string* AllowedAddressPairSubnet::mutable_ipprefix() {
  std::string* _s = _internal_mutable_ipprefix();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefix)
  return _s;
}
inline const std::string& AllowedAddressPairSubnet::_internal_ipprefix() const {
  return ipprefix_.Get();
}
inline void AllowedAddressPairSubnet::_internal_set_ipprefix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ipprefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AllowedAddressPairSubnet::_internal_mutable_ipprefix() {
  _has_bits_[0] |= 0x00000001u;
  return ipprefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AllowedAddressPairSubnet::release_ipprefix() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefix)
  if (!_internal_has_ipprefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ipprefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AllowedAddressPairSubnet::set_allocated_ipprefix(std::string* ipprefix) {
  if (ipprefix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ipprefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipprefix,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefix)
}

// optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString ipPrefixLen = 2;
inline bool AllowedAddressPairSubnet::_internal_has_ipprefixlen() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || ipprefixlen_ != nullptr);
  return value;
}
inline bool AllowedAddressPairSubnet::has_ipprefixlen() const {
  return _internal_has_ipprefixlen();
}
inline const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& AllowedAddressPairSubnet::_internal_ipprefixlen() const {
  const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* p = ipprefixlen_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString&>(
      ::k8s::io::apimachinery::pkg::util::intstr::_IntOrString_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& AllowedAddressPairSubnet::ipprefixlen() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefixLen)
  return _internal_ipprefixlen();
}
inline void AllowedAddressPairSubnet::unsafe_arena_set_allocated_ipprefixlen(
    ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipprefixlen_);
  }
  ipprefixlen_ = ipprefixlen;
  if (ipprefixlen) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefixLen)
}
inline ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* AllowedAddressPairSubnet::release_ipprefixlen() {
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* temp = ipprefixlen_;
  ipprefixlen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* AllowedAddressPairSubnet::unsafe_arena_release_ipprefixlen() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefixLen)
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* temp = ipprefixlen_;
  ipprefixlen_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* AllowedAddressPairSubnet::_internal_mutable_ipprefixlen() {
  _has_bits_[0] |= 0x00000002u;
  if (ipprefixlen_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::util::intstr::IntOrString>(GetArenaForAllocation());
    ipprefixlen_ = p;
  }
  return ipprefixlen_;
}
inline ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* AllowedAddressPairSubnet::mutable_ipprefixlen() {
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* _msg = _internal_mutable_ipprefixlen();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefixLen)
  return _msg;
}
inline void AllowedAddressPairSubnet::set_allocated_ipprefixlen(::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipprefixlen_);
  }
  if (ipprefixlen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipprefixlen));
    if (message_arena != submessage_arena) {
      ipprefixlen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipprefixlen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ipprefixlen_ = ipprefixlen;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet.ipPrefixLen)
}

// -------------------------------------------------------------------

// AllowedAddressPairs

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair allowedAddressPair = 1;
inline int AllowedAddressPairs::_internal_allowedaddresspair_size() const {
  return allowedaddresspair_.size();
}
inline int AllowedAddressPairs::allowedaddresspair_size() const {
  return _internal_allowedaddresspair_size();
}
inline void AllowedAddressPairs::clear_allowedaddresspair() {
  allowedaddresspair_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair* AllowedAddressPairs::mutable_allowedaddresspair(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs.allowedAddressPair)
  return allowedaddresspair_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair >*
AllowedAddressPairs::mutable_allowedaddresspair() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs.allowedAddressPair)
  return &allowedaddresspair_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair& AllowedAddressPairs::_internal_allowedaddresspair(int index) const {
  return allowedaddresspair_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair& AllowedAddressPairs::allowedaddresspair(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs.allowedAddressPair)
  return _internal_allowedaddresspair(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair* AllowedAddressPairs::_internal_add_allowedaddresspair() {
  return allowedaddresspair_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair* AllowedAddressPairs::add_allowedaddresspair() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair* _add = _internal_add_allowedaddresspair();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs.allowedAddressPair)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPair >&
AllowedAddressPairs::allowedaddresspair() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs.allowedAddressPair)
  return allowedaddresspair_;
}

// -------------------------------------------------------------------

// ApplicationPolicySet

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool ApplicationPolicySet::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool ApplicationPolicySet::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& ApplicationPolicySet::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& ApplicationPolicySet::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.metadata)
  return _internal_metadata();
}
inline void ApplicationPolicySet::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* ApplicationPolicySet::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* ApplicationPolicySet::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* ApplicationPolicySet::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* ApplicationPolicySet::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.metadata)
  return _msg;
}
inline void ApplicationPolicySet::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec spec = 2;
inline bool ApplicationPolicySet::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool ApplicationPolicySet::has_spec() const {
  return _internal_has_spec();
}
inline void ApplicationPolicySet::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec& ApplicationPolicySet::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ApplicationPolicySetSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec& ApplicationPolicySet::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.spec)
  return _internal_spec();
}
inline void ApplicationPolicySet::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* ApplicationPolicySet::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* ApplicationPolicySet::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* ApplicationPolicySet::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* ApplicationPolicySet::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.spec)
  return _msg;
}
inline void ApplicationPolicySet::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus status = 3;
inline bool ApplicationPolicySet::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool ApplicationPolicySet::has_status() const {
  return _internal_has_status();
}
inline void ApplicationPolicySet::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus& ApplicationPolicySet::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ApplicationPolicySetStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus& ApplicationPolicySet::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.status)
  return _internal_status();
}
inline void ApplicationPolicySet::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* ApplicationPolicySet::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* ApplicationPolicySet::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* ApplicationPolicySet::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* ApplicationPolicySet::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.status)
  return _msg;
}
inline void ApplicationPolicySet::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySetStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet.status)
}

// -------------------------------------------------------------------

// ApplicationPolicySetList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool ApplicationPolicySetList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool ApplicationPolicySetList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& ApplicationPolicySetList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& ApplicationPolicySetList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.metadata)
  return _internal_metadata();
}
inline void ApplicationPolicySetList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* ApplicationPolicySetList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* ApplicationPolicySetList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* ApplicationPolicySetList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* ApplicationPolicySetList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.metadata)
  return _msg;
}
inline void ApplicationPolicySetList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet items = 2;
inline int ApplicationPolicySetList::_internal_items_size() const {
  return items_.size();
}
inline int ApplicationPolicySetList::items_size() const {
  return _internal_items_size();
}
inline void ApplicationPolicySetList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet* ApplicationPolicySetList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet >*
ApplicationPolicySetList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet& ApplicationPolicySetList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet& ApplicationPolicySetList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet* ApplicationPolicySetList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet* ApplicationPolicySetList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ApplicationPolicySet >&
ApplicationPolicySetList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetList.items)
  return items_;
}

// -------------------------------------------------------------------

// ApplicationPolicySetSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool ApplicationPolicySetSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool ApplicationPolicySetSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void ApplicationPolicySetSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& ApplicationPolicySetSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& ApplicationPolicySetSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.commonSpec)
  return _internal_commonspec();
}
inline void ApplicationPolicySetSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* ApplicationPolicySetSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* ApplicationPolicySetSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* ApplicationPolicySetSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* ApplicationPolicySetSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.commonSpec)
  return _msg;
}
inline void ApplicationPolicySetSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.commonSpec)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference firewallPolicyReferences = 2;
inline int ApplicationPolicySetSpec::_internal_firewallpolicyreferences_size() const {
  return firewallpolicyreferences_.size();
}
inline int ApplicationPolicySetSpec::firewallpolicyreferences_size() const {
  return _internal_firewallpolicyreferences_size();
}
inline void ApplicationPolicySetSpec::clear_firewallpolicyreferences() {
  firewallpolicyreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference* ApplicationPolicySetSpec::mutable_firewallpolicyreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.firewallPolicyReferences)
  return firewallpolicyreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference >*
ApplicationPolicySetSpec::mutable_firewallpolicyreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.firewallPolicyReferences)
  return &firewallpolicyreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference& ApplicationPolicySetSpec::_internal_firewallpolicyreferences(int index) const {
  return firewallpolicyreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference& ApplicationPolicySetSpec::firewallpolicyreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.firewallPolicyReferences)
  return _internal_firewallpolicyreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference* ApplicationPolicySetSpec::_internal_add_firewallpolicyreferences() {
  return firewallpolicyreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference* ApplicationPolicySetSpec::add_firewallpolicyreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference* _add = _internal_add_firewallpolicyreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.firewallPolicyReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyReference >&
ApplicationPolicySetSpec::firewallpolicyreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.firewallPolicyReferences)
  return firewallpolicyreferences_;
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 3;
inline int ApplicationPolicySetSpec::_internal_tagreferences_size() const {
  return tagreferences_.size();
}
inline int ApplicationPolicySetSpec::tagreferences_size() const {
  return _internal_tagreferences_size();
}
inline void ApplicationPolicySetSpec::clear_tagreferences() {
  tagreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* ApplicationPolicySetSpec::mutable_tagreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.tagReferences)
  return tagreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
ApplicationPolicySetSpec::mutable_tagreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.tagReferences)
  return &tagreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& ApplicationPolicySetSpec::_internal_tagreferences(int index) const {
  return tagreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& ApplicationPolicySetSpec::tagreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.tagReferences)
  return _internal_tagreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* ApplicationPolicySetSpec::_internal_add_tagreferences() {
  return tagreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* ApplicationPolicySetSpec::add_tagreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_tagreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.tagReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
ApplicationPolicySetSpec::tagreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec.tagReferences)
  return tagreferences_;
}

// -------------------------------------------------------------------

// ApplicationPolicySetStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool ApplicationPolicySetStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool ApplicationPolicySetStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void ApplicationPolicySetStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& ApplicationPolicySetStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& ApplicationPolicySetStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus.commonStatus)
  return _internal_commonstatus();
}
inline void ApplicationPolicySetStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* ApplicationPolicySetStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* ApplicationPolicySetStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* ApplicationPolicySetStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* ApplicationPolicySetStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus.commonStatus)
  return _msg;
}
inline void ApplicationPolicySetStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus.commonStatus)
}

// optional bool allApplications = 3;
inline bool ApplicationPolicySetStatus::_internal_has_allapplications() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApplicationPolicySetStatus::has_allapplications() const {
  return _internal_has_allapplications();
}
inline void ApplicationPolicySetStatus::clear_allapplications() {
  allapplications_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ApplicationPolicySetStatus::_internal_allapplications() const {
  return allapplications_;
}
inline bool ApplicationPolicySetStatus::allapplications() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus.allApplications)
  return _internal_allapplications();
}
inline void ApplicationPolicySetStatus::_internal_set_allapplications(bool value) {
  _has_bits_[0] |= 0x00000002u;
  allapplications_ = value;
}
inline void ApplicationPolicySetStatus::set_allapplications(bool value) {
  _internal_set_allapplications(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus.allApplications)
}

// -------------------------------------------------------------------

// AuthenticationData

// optional string keyType = 1;
inline bool AuthenticationData::_internal_has_keytype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticationData::has_keytype() const {
  return _internal_has_keytype();
}
inline void AuthenticationData::clear_keytype() {
  keytype_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticationData::keytype() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyType)
  return _internal_keytype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticationData::set_keytype(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 keytype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyType)
}
inline std::string* AuthenticationData::mutable_keytype() {
  std::string* _s = _internal_mutable_keytype();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyType)
  return _s;
}
inline const std::string& AuthenticationData::_internal_keytype() const {
  return keytype_.Get();
}
inline void AuthenticationData::_internal_set_keytype(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  keytype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticationData::_internal_mutable_keytype() {
  _has_bits_[0] |= 0x00000001u;
  return keytype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticationData::release_keytype() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyType)
  if (!_internal_has_keytype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return keytype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticationData::set_allocated_keytype(std::string* keytype) {
  if (keytype != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  keytype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keytype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyType)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem keyItems = 2;
inline int AuthenticationData::_internal_keyitems_size() const {
  return keyitems_.size();
}
inline int AuthenticationData::keyitems_size() const {
  return _internal_keyitems_size();
}
inline void AuthenticationData::clear_keyitems() {
  keyitems_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem* AuthenticationData::mutable_keyitems(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyItems)
  return keyitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem >*
AuthenticationData::mutable_keyitems() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyItems)
  return &keyitems_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem& AuthenticationData::_internal_keyitems(int index) const {
  return keyitems_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem& AuthenticationData::keyitems(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyItems)
  return _internal_keyitems(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem* AuthenticationData::_internal_add_keyitems() {
  return keyitems_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem* AuthenticationData::add_keyitems() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem* _add = _internal_add_keyitems();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationKeyItem >&
AuthenticationData::keyitems() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData.keyItems)
  return keyitems_;
}

// -------------------------------------------------------------------

// AuthenticationKeyItem

// optional int32 keyId = 1;
inline bool AuthenticationKeyItem::_internal_has_keyid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AuthenticationKeyItem::has_keyid() const {
  return _internal_has_keyid();
}
inline void AuthenticationKeyItem::clear_keyid() {
  keyid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AuthenticationKeyItem::_internal_keyid() const {
  return keyid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AuthenticationKeyItem::keyid() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem.keyId)
  return _internal_keyid();
}
inline void AuthenticationKeyItem::_internal_set_keyid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  keyid_ = value;
}
inline void AuthenticationKeyItem::set_keyid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_keyid(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem.keyId)
}

// optional string key = 2;
inline bool AuthenticationKeyItem::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticationKeyItem::has_key() const {
  return _internal_has_key();
}
inline void AuthenticationKeyItem::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticationKeyItem::key() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticationKeyItem::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem.key)
}
inline std::string* AuthenticationKeyItem::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem.key)
  return _s;
}
inline const std::string& AuthenticationKeyItem::_internal_key() const {
  return key_.Get();
}
inline void AuthenticationKeyItem::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticationKeyItem::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticationKeyItem::release_key() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticationKeyItem::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem.key)
}

// -------------------------------------------------------------------

// BGPAsAService

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool BGPAsAService::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool BGPAsAService::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& BGPAsAService::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& BGPAsAService::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.metadata)
  return _internal_metadata();
}
inline void BGPAsAService::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* BGPAsAService::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* BGPAsAService::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* BGPAsAService::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* BGPAsAService::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.metadata)
  return _msg;
}
inline void BGPAsAService::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec spec = 2;
inline bool BGPAsAService::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool BGPAsAService::has_spec() const {
  return _internal_has_spec();
}
inline void BGPAsAService::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec& BGPAsAService::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPAsAServiceSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec& BGPAsAService::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.spec)
  return _internal_spec();
}
inline void BGPAsAService::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* BGPAsAService::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* BGPAsAService::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* BGPAsAService::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* BGPAsAService::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.spec)
  return _msg;
}
inline void BGPAsAService::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus status = 3;
inline bool BGPAsAService::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool BGPAsAService::has_status() const {
  return _internal_has_status();
}
inline void BGPAsAService::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus& BGPAsAService::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPAsAServiceStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus& BGPAsAService::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.status)
  return _internal_status();
}
inline void BGPAsAService::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* BGPAsAService::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* BGPAsAService::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* BGPAsAService::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* BGPAsAService::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.status)
  return _msg;
}
inline void BGPAsAService::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAServiceStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService.status)
}

// -------------------------------------------------------------------

// BGPAsAServiceList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool BGPAsAServiceList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool BGPAsAServiceList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& BGPAsAServiceList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& BGPAsAServiceList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.metadata)
  return _internal_metadata();
}
inline void BGPAsAServiceList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* BGPAsAServiceList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* BGPAsAServiceList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* BGPAsAServiceList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* BGPAsAServiceList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.metadata)
  return _msg;
}
inline void BGPAsAServiceList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService items = 2;
inline int BGPAsAServiceList::_internal_items_size() const {
  return items_.size();
}
inline int BGPAsAServiceList::items_size() const {
  return _internal_items_size();
}
inline void BGPAsAServiceList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService* BGPAsAServiceList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService >*
BGPAsAServiceList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService& BGPAsAServiceList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService& BGPAsAServiceList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService* BGPAsAServiceList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService* BGPAsAServiceList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPAsAService >&
BGPAsAServiceList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceList.items)
  return items_;
}

// -------------------------------------------------------------------

// BGPAsAServiceSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool BGPAsAServiceSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool BGPAsAServiceSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void BGPAsAServiceSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& BGPAsAServiceSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& BGPAsAServiceSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.commonSpec)
  return _internal_commonspec();
}
inline void BGPAsAServiceSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* BGPAsAServiceSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* BGPAsAServiceSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.commonSpec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* BGPAsAServiceSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000002u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* BGPAsAServiceSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.commonSpec)
  return _msg;
}
inline void BGPAsAServiceSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.commonSpec)
}

// optional bool shared = 2;
inline bool BGPAsAServiceSpec::_internal_has_shared() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BGPAsAServiceSpec::has_shared() const {
  return _internal_has_shared();
}
inline void BGPAsAServiceSpec::clear_shared() {
  shared_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool BGPAsAServiceSpec::_internal_shared() const {
  return shared_;
}
inline bool BGPAsAServiceSpec::shared() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.shared)
  return _internal_shared();
}
inline void BGPAsAServiceSpec::_internal_set_shared(bool value) {
  _has_bits_[0] |= 0x00000010u;
  shared_ = value;
}
inline void BGPAsAServiceSpec::set_shared(bool value) {
  _internal_set_shared(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.shared)
}

// optional string ipAddress = 3;
inline bool BGPAsAServiceSpec::_internal_has_ipaddress() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BGPAsAServiceSpec::has_ipaddress() const {
  return _internal_has_ipaddress();
}
inline void BGPAsAServiceSpec::clear_ipaddress() {
  ipaddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BGPAsAServiceSpec::ipaddress() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.ipAddress)
  return _internal_ipaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPAsAServiceSpec::set_ipaddress(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.ipAddress)
}
inline std::string* BGPAsAServiceSpec::mutable_ipaddress() {
  std::string* _s = _internal_mutable_ipaddress();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.ipAddress)
  return _s;
}
inline const std::string& BGPAsAServiceSpec::_internal_ipaddress() const {
  return ipaddress_.Get();
}
inline void BGPAsAServiceSpec::_internal_set_ipaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPAsAServiceSpec::_internal_mutable_ipaddress() {
  _has_bits_[0] |= 0x00000001u;
  return ipaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPAsAServiceSpec::release_ipaddress() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.ipAddress)
  if (!_internal_has_ipaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ipaddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPAsAServiceSpec::set_allocated_ipaddress(std::string* ipaddress) {
  if (ipaddress != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ipaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.ipAddress)
}

// optional int32 autonomousSystem = 4;
inline bool BGPAsAServiceSpec::_internal_has_autonomoussystem() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BGPAsAServiceSpec::has_autonomoussystem() const {
  return _internal_has_autonomoussystem();
}
inline void BGPAsAServiceSpec::clear_autonomoussystem() {
  autonomoussystem_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPAsAServiceSpec::_internal_autonomoussystem() const {
  return autonomoussystem_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPAsAServiceSpec::autonomoussystem() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.autonomousSystem)
  return _internal_autonomoussystem();
}
inline void BGPAsAServiceSpec::_internal_set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  autonomoussystem_ = value;
}
inline void BGPAsAServiceSpec::set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_autonomoussystem(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.autonomousSystem)
}

// optional bool suppressRouteAdvertisement = 5;
inline bool BGPAsAServiceSpec::_internal_has_suppressrouteadvertisement() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BGPAsAServiceSpec::has_suppressrouteadvertisement() const {
  return _internal_has_suppressrouteadvertisement();
}
inline void BGPAsAServiceSpec::clear_suppressrouteadvertisement() {
  suppressrouteadvertisement_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool BGPAsAServiceSpec::_internal_suppressrouteadvertisement() const {
  return suppressrouteadvertisement_;
}
inline bool BGPAsAServiceSpec::suppressrouteadvertisement() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.suppressRouteAdvertisement)
  return _internal_suppressrouteadvertisement();
}
inline void BGPAsAServiceSpec::_internal_set_suppressrouteadvertisement(bool value) {
  _has_bits_[0] |= 0x00000020u;
  suppressrouteadvertisement_ = value;
}
inline void BGPAsAServiceSpec::set_suppressrouteadvertisement(bool value) {
  _internal_set_suppressrouteadvertisement(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.suppressRouteAdvertisement)
}

// optional bool ipv4MappedIPv6NextHop = 6;
inline bool BGPAsAServiceSpec::_internal_has_ipv4mappedipv6nexthop() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BGPAsAServiceSpec::has_ipv4mappedipv6nexthop() const {
  return _internal_has_ipv4mappedipv6nexthop();
}
inline void BGPAsAServiceSpec::clear_ipv4mappedipv6nexthop() {
  ipv4mappedipv6nexthop_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool BGPAsAServiceSpec::_internal_ipv4mappedipv6nexthop() const {
  return ipv4mappedipv6nexthop_;
}
inline bool BGPAsAServiceSpec::ipv4mappedipv6nexthop() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.ipv4MappedIPv6NextHop)
  return _internal_ipv4mappedipv6nexthop();
}
inline void BGPAsAServiceSpec::_internal_set_ipv4mappedipv6nexthop(bool value) {
  _has_bits_[0] |= 0x00000040u;
  ipv4mappedipv6nexthop_ = value;
}
inline void BGPAsAServiceSpec::set_ipv4mappedipv6nexthop(bool value) {
  _internal_set_ipv4mappedipv6nexthop(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.ipv4MappedIPv6NextHop)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes bgpAsAServiceSessionAttributes = 7;
inline bool BGPAsAServiceSpec::_internal_has_bgpasaservicesessionattributes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || bgpasaservicesessionattributes_ != nullptr);
  return value;
}
inline bool BGPAsAServiceSpec::has_bgpasaservicesessionattributes() const {
  return _internal_has_bgpasaservicesessionattributes();
}
inline void BGPAsAServiceSpec::clear_bgpasaservicesessionattributes() {
  if (bgpasaservicesessionattributes_ != nullptr) bgpasaservicesessionattributes_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes& BGPAsAServiceSpec::_internal_bgpasaservicesessionattributes() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* p = bgpasaservicesessionattributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPSessionAttributes_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes& BGPAsAServiceSpec::bgpasaservicesessionattributes() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.bgpAsAServiceSessionAttributes)
  return _internal_bgpasaservicesessionattributes();
}
inline void BGPAsAServiceSpec::unsafe_arena_set_allocated_bgpasaservicesessionattributes(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* bgpasaservicesessionattributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bgpasaservicesessionattributes_);
  }
  bgpasaservicesessionattributes_ = bgpasaservicesessionattributes;
  if (bgpasaservicesessionattributes) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.bgpAsAServiceSessionAttributes)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* BGPAsAServiceSpec::release_bgpasaservicesessionattributes() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* temp = bgpasaservicesessionattributes_;
  bgpasaservicesessionattributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* BGPAsAServiceSpec::unsafe_arena_release_bgpasaservicesessionattributes() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.bgpAsAServiceSessionAttributes)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* temp = bgpasaservicesessionattributes_;
  bgpasaservicesessionattributes_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* BGPAsAServiceSpec::_internal_mutable_bgpasaservicesessionattributes() {
  _has_bits_[0] |= 0x00000004u;
  if (bgpasaservicesessionattributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes>(GetArenaForAllocation());
    bgpasaservicesessionattributes_ = p;
  }
  return bgpasaservicesessionattributes_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* BGPAsAServiceSpec::mutable_bgpasaservicesessionattributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* _msg = _internal_mutable_bgpasaservicesessionattributes();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.bgpAsAServiceSessionAttributes)
  return _msg;
}
inline void BGPAsAServiceSpec::set_allocated_bgpasaservicesessionattributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* bgpasaservicesessionattributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bgpasaservicesessionattributes_;
  }
  if (bgpasaservicesessionattributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes>::GetOwningArena(bgpasaservicesessionattributes);
    if (message_arena != submessage_arena) {
      bgpasaservicesessionattributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bgpasaservicesessionattributes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  bgpasaservicesessionattributes_ = bgpasaservicesessionattributes;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.bgpAsAServiceSessionAttributes)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 8;
inline int BGPAsAServiceSpec::_internal_virtualmachineinterfacereferences_size() const {
  return virtualmachineinterfacereferences_.size();
}
inline int BGPAsAServiceSpec::virtualmachineinterfacereferences_size() const {
  return _internal_virtualmachineinterfacereferences_size();
}
inline void BGPAsAServiceSpec::clear_virtualmachineinterfacereferences() {
  virtualmachineinterfacereferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* BGPAsAServiceSpec::mutable_virtualmachineinterfacereferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfaceReferences)
  return virtualmachineinterfacereferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
BGPAsAServiceSpec::mutable_virtualmachineinterfacereferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfaceReferences)
  return &virtualmachineinterfacereferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& BGPAsAServiceSpec::_internal_virtualmachineinterfacereferences(int index) const {
  return virtualmachineinterfacereferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& BGPAsAServiceSpec::virtualmachineinterfacereferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfaceReferences)
  return _internal_virtualmachineinterfacereferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* BGPAsAServiceSpec::_internal_add_virtualmachineinterfacereferences() {
  return virtualmachineinterfacereferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* BGPAsAServiceSpec::add_virtualmachineinterfacereferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_virtualmachineinterfacereferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfaceReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
BGPAsAServiceSpec::virtualmachineinterfacereferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfaceReferences)
  return virtualmachineinterfacereferences_;
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualMachineInterfacesSelector = 9;
inline int BGPAsAServiceSpec::_internal_virtualmachineinterfacesselector_size() const {
  return virtualmachineinterfacesselector_.size();
}
inline int BGPAsAServiceSpec::virtualmachineinterfacesselector_size() const {
  return _internal_virtualmachineinterfacesselector_size();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* BGPAsAServiceSpec::mutable_virtualmachineinterfacesselector(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfacesSelector)
  return virtualmachineinterfacesselector_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector >*
BGPAsAServiceSpec::mutable_virtualmachineinterfacesselector() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfacesSelector)
  return &virtualmachineinterfacesselector_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& BGPAsAServiceSpec::_internal_virtualmachineinterfacesselector(int index) const {
  return virtualmachineinterfacesselector_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& BGPAsAServiceSpec::virtualmachineinterfacesselector(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfacesSelector)
  return _internal_virtualmachineinterfacesselector(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* BGPAsAServiceSpec::_internal_add_virtualmachineinterfacesselector() {
  return virtualmachineinterfacesselector_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* BGPAsAServiceSpec::add_virtualmachineinterfacesselector() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* _add = _internal_add_virtualmachineinterfacesselector();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfacesSelector)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector >&
BGPAsAServiceSpec::virtualmachineinterfacesselector() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec.virtualMachineInterfacesSelector)
  return virtualmachineinterfacesselector_;
}

// -------------------------------------------------------------------

// BGPAsAServiceStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool BGPAsAServiceStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool BGPAsAServiceStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void BGPAsAServiceStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& BGPAsAServiceStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& BGPAsAServiceStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.commonStatus)
  return _internal_commonstatus();
}
inline void BGPAsAServiceStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* BGPAsAServiceStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* BGPAsAServiceStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* BGPAsAServiceStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* BGPAsAServiceStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.commonStatus)
  return _msg;
}
inline void BGPAsAServiceStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.commonStatus)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference bgpRouterReferences = 2;
inline int BGPAsAServiceStatus::_internal_bgprouterreferences_size() const {
  return bgprouterreferences_.size();
}
inline int BGPAsAServiceStatus::bgprouterreferences_size() const {
  return _internal_bgprouterreferences_size();
}
inline void BGPAsAServiceStatus::clear_bgprouterreferences() {
  bgprouterreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* BGPAsAServiceStatus::mutable_bgprouterreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.bgpRouterReferences)
  return bgprouterreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference >*
BGPAsAServiceStatus::mutable_bgprouterreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.bgpRouterReferences)
  return &bgprouterreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference& BGPAsAServiceStatus::_internal_bgprouterreferences(int index) const {
  return bgprouterreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference& BGPAsAServiceStatus::bgprouterreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.bgpRouterReferences)
  return _internal_bgprouterreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* BGPAsAServiceStatus::_internal_add_bgprouterreferences() {
  return bgprouterreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* BGPAsAServiceStatus::add_bgprouterreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* _add = _internal_add_bgprouterreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.bgpRouterReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference >&
BGPAsAServiceStatus::bgprouterreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.bgpRouterReferences)
  return bgprouterreferences_;
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference subnetReferences = 3;
inline int BGPAsAServiceStatus::_internal_subnetreferences_size() const {
  return subnetreferences_.size();
}
inline int BGPAsAServiceStatus::subnetreferences_size() const {
  return _internal_subnetreferences_size();
}
inline void BGPAsAServiceStatus::clear_subnetreferences() {
  subnetreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference* BGPAsAServiceStatus::mutable_subnetreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.subnetReferences)
  return subnetreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference >*
BGPAsAServiceStatus::mutable_subnetreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.subnetReferences)
  return &subnetreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference& BGPAsAServiceStatus::_internal_subnetreferences(int index) const {
  return subnetreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference& BGPAsAServiceStatus::subnetreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.subnetReferences)
  return _internal_subnetreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference* BGPAsAServiceStatus::_internal_add_subnetreferences() {
  return subnetreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference* BGPAsAServiceStatus::add_subnetreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference* _add = _internal_add_subnetreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.subnetReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetReference >&
BGPAsAServiceStatus::subnetreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus.subnetReferences)
  return subnetreferences_;
}

// -------------------------------------------------------------------

// BGPFamilyAttributes

// optional string addressFamily = 1;
inline bool BGPFamilyAttributes::_internal_has_addressfamily() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BGPFamilyAttributes::has_addressfamily() const {
  return _internal_has_addressfamily();
}
inline void BGPFamilyAttributes::clear_addressfamily() {
  addressfamily_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BGPFamilyAttributes::addressfamily() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.addressFamily)
  return _internal_addressfamily();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPFamilyAttributes::set_addressfamily(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 addressfamily_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.addressFamily)
}
inline std::string* BGPFamilyAttributes::mutable_addressfamily() {
  std::string* _s = _internal_mutable_addressfamily();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.addressFamily)
  return _s;
}
inline const std::string& BGPFamilyAttributes::_internal_addressfamily() const {
  return addressfamily_.Get();
}
inline void BGPFamilyAttributes::_internal_set_addressfamily(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  addressfamily_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPFamilyAttributes::_internal_mutable_addressfamily() {
  _has_bits_[0] |= 0x00000001u;
  return addressfamily_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPFamilyAttributes::release_addressfamily() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.addressFamily)
  if (!_internal_has_addressfamily()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return addressfamily_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPFamilyAttributes::set_allocated_addressfamily(std::string* addressfamily) {
  if (addressfamily != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  addressfamily_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addressfamily,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.addressFamily)
}

// optional int32 loopCount = 2;
inline bool BGPFamilyAttributes::_internal_has_loopcount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BGPFamilyAttributes::has_loopcount() const {
  return _internal_has_loopcount();
}
inline void BGPFamilyAttributes::clear_loopcount() {
  loopcount_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPFamilyAttributes::_internal_loopcount() const {
  return loopcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPFamilyAttributes::loopcount() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.loopCount)
  return _internal_loopcount();
}
inline void BGPFamilyAttributes::_internal_set_loopcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  loopcount_ = value;
}
inline void BGPFamilyAttributes::set_loopcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_loopcount(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.loopCount)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit prefixLimit = 3;
inline bool BGPFamilyAttributes::_internal_has_prefixlimit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || prefixlimit_ != nullptr);
  return value;
}
inline bool BGPFamilyAttributes::has_prefixlimit() const {
  return _internal_has_prefixlimit();
}
inline void BGPFamilyAttributes::clear_prefixlimit() {
  if (prefixlimit_ != nullptr) prefixlimit_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit& BGPFamilyAttributes::_internal_prefixlimit() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* p = prefixlimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPPrefixLimit_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit& BGPFamilyAttributes::prefixlimit() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.prefixLimit)
  return _internal_prefixlimit();
}
inline void BGPFamilyAttributes::unsafe_arena_set_allocated_prefixlimit(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* prefixlimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefixlimit_);
  }
  prefixlimit_ = prefixlimit;
  if (prefixlimit) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.prefixLimit)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* BGPFamilyAttributes::release_prefixlimit() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* temp = prefixlimit_;
  prefixlimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* BGPFamilyAttributes::unsafe_arena_release_prefixlimit() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.prefixLimit)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* temp = prefixlimit_;
  prefixlimit_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* BGPFamilyAttributes::_internal_mutable_prefixlimit() {
  _has_bits_[0] |= 0x00000002u;
  if (prefixlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit>(GetArenaForAllocation());
    prefixlimit_ = p;
  }
  return prefixlimit_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* BGPFamilyAttributes::mutable_prefixlimit() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* _msg = _internal_mutable_prefixlimit();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.prefixLimit)
  return _msg;
}
inline void BGPFamilyAttributes::set_allocated_prefixlimit(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit* prefixlimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete prefixlimit_;
  }
  if (prefixlimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPPrefixLimit>::GetOwningArena(prefixlimit);
    if (message_arena != submessage_arena) {
      prefixlimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prefixlimit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  prefixlimit_ = prefixlimit;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.prefixLimit)
}

// repeated string defaultTunnelEncap = 4;
inline int BGPFamilyAttributes::_internal_defaulttunnelencap_size() const {
  return defaulttunnelencap_.size();
}
inline int BGPFamilyAttributes::defaulttunnelencap_size() const {
  return _internal_defaulttunnelencap_size();
}
inline void BGPFamilyAttributes::clear_defaulttunnelencap() {
  defaulttunnelencap_.Clear();
}
inline std::string* BGPFamilyAttributes::add_defaulttunnelencap() {
  std::string* _s = _internal_add_defaulttunnelencap();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
  return _s;
}
inline const std::string& BGPFamilyAttributes::_internal_defaulttunnelencap(int index) const {
  return defaulttunnelencap_.Get(index);
}
inline const std::string& BGPFamilyAttributes::defaulttunnelencap(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
  return _internal_defaulttunnelencap(index);
}
inline std::string* BGPFamilyAttributes::mutable_defaulttunnelencap(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
  return defaulttunnelencap_.Mutable(index);
}
inline void BGPFamilyAttributes::set_defaulttunnelencap(int index, const std::string& value) {
  defaulttunnelencap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
}
inline void BGPFamilyAttributes::set_defaulttunnelencap(int index, std::string&& value) {
  defaulttunnelencap_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
}
inline void BGPFamilyAttributes::set_defaulttunnelencap(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  defaulttunnelencap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
}
inline void BGPFamilyAttributes::set_defaulttunnelencap(int index, const char* value, size_t size) {
  defaulttunnelencap_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
}
inline std::string* BGPFamilyAttributes::_internal_add_defaulttunnelencap() {
  return defaulttunnelencap_.Add();
}
inline void BGPFamilyAttributes::add_defaulttunnelencap(const std::string& value) {
  defaulttunnelencap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
}
inline void BGPFamilyAttributes::add_defaulttunnelencap(std::string&& value) {
  defaulttunnelencap_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
}
inline void BGPFamilyAttributes::add_defaulttunnelencap(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  defaulttunnelencap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
}
inline void BGPFamilyAttributes::add_defaulttunnelencap(const char* value, size_t size) {
  defaulttunnelencap_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BGPFamilyAttributes::defaulttunnelencap() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
  return defaulttunnelencap_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BGPFamilyAttributes::mutable_defaulttunnelencap() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes.defaultTunnelEncap)
  return &defaulttunnelencap_;
}

// -------------------------------------------------------------------

// BGPPrefixLimit

// optional int32 idleTimeout = 1;
inline bool BGPPrefixLimit::_internal_has_idletimeout() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BGPPrefixLimit::has_idletimeout() const {
  return _internal_has_idletimeout();
}
inline void BGPPrefixLimit::clear_idletimeout() {
  idletimeout_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPPrefixLimit::_internal_idletimeout() const {
  return idletimeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPPrefixLimit::idletimeout() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit.idleTimeout)
  return _internal_idletimeout();
}
inline void BGPPrefixLimit::_internal_set_idletimeout(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  idletimeout_ = value;
}
inline void BGPPrefixLimit::set_idletimeout(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_idletimeout(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit.idleTimeout)
}

// optional int32 maximum = 2;
inline bool BGPPrefixLimit::_internal_has_maximum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BGPPrefixLimit::has_maximum() const {
  return _internal_has_maximum();
}
inline void BGPPrefixLimit::clear_maximum() {
  maximum_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPPrefixLimit::_internal_maximum() const {
  return maximum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPPrefixLimit::maximum() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit.maximum)
  return _internal_maximum();
}
inline void BGPPrefixLimit::_internal_set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  maximum_ = value;
}
inline void BGPPrefixLimit::set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit.maximum)
}

// -------------------------------------------------------------------

// BGPRouter

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool BGPRouter::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool BGPRouter::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& BGPRouter::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& BGPRouter::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.metadata)
  return _internal_metadata();
}
inline void BGPRouter::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* BGPRouter::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* BGPRouter::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* BGPRouter::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* BGPRouter::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.metadata)
  return _msg;
}
inline void BGPRouter::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec spec = 2;
inline bool BGPRouter::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool BGPRouter::has_spec() const {
  return _internal_has_spec();
}
inline void BGPRouter::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec& BGPRouter::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPRouterSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec& BGPRouter::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.spec)
  return _internal_spec();
}
inline void BGPRouter::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* BGPRouter::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* BGPRouter::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* BGPRouter::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* BGPRouter::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.spec)
  return _msg;
}
inline void BGPRouter::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus status = 3;
inline bool BGPRouter::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool BGPRouter::has_status() const {
  return _internal_has_status();
}
inline void BGPRouter::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus& BGPRouter::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPRouterStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus& BGPRouter::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.status)
  return _internal_status();
}
inline void BGPRouter::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* BGPRouter::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* BGPRouter::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* BGPRouter::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* BGPRouter::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.status)
  return _msg;
}
inline void BGPRouter::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter.status)
}

// -------------------------------------------------------------------

// BGPRouterList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool BGPRouterList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool BGPRouterList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& BGPRouterList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& BGPRouterList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.metadata)
  return _internal_metadata();
}
inline void BGPRouterList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* BGPRouterList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* BGPRouterList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* BGPRouterList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* BGPRouterList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.metadata)
  return _msg;
}
inline void BGPRouterList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter items = 2;
inline int BGPRouterList::_internal_items_size() const {
  return items_.size();
}
inline int BGPRouterList::items_size() const {
  return _internal_items_size();
}
inline void BGPRouterList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter* BGPRouterList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter >*
BGPRouterList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter& BGPRouterList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter& BGPRouterList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter* BGPRouterList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter* BGPRouterList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouter >&
BGPRouterList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterList.items)
  return items_;
}

// -------------------------------------------------------------------

// BGPRouterParameters

// optional bool adminDown = 1;
inline bool BGPRouterParameters::_internal_has_admindown() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_admindown() const {
  return _internal_has_admindown();
}
inline void BGPRouterParameters::clear_admindown() {
  admindown_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool BGPRouterParameters::_internal_admindown() const {
  return admindown_;
}
inline bool BGPRouterParameters::admindown() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.adminDown)
  return _internal_admindown();
}
inline void BGPRouterParameters::_internal_set_admindown(bool value) {
  _has_bits_[0] |= 0x00000100u;
  admindown_ = value;
}
inline void BGPRouterParameters::set_admindown(bool value) {
  _internal_set_admindown(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.adminDown)
}

// optional string vendor = 2;
inline bool BGPRouterParameters::_internal_has_vendor() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_vendor() const {
  return _internal_has_vendor();
}
inline void BGPRouterParameters::clear_vendor() {
  vendor_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BGPRouterParameters::vendor() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPRouterParameters::set_vendor(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 vendor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.vendor)
}
inline std::string* BGPRouterParameters::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.vendor)
  return _s;
}
inline const std::string& BGPRouterParameters::_internal_vendor() const {
  return vendor_.Get();
}
inline void BGPRouterParameters::_internal_set_vendor(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vendor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::_internal_mutable_vendor() {
  _has_bits_[0] |= 0x00000001u;
  return vendor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::release_vendor() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.vendor)
  if (!_internal_has_vendor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vendor_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPRouterParameters::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vendor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vendor,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.vendor)
}

// optional int64 clusterID = 3;
inline bool BGPRouterParameters::_internal_has_clusterid() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_clusterid() const {
  return _internal_has_clusterid();
}
inline void BGPRouterParameters::clear_clusterid() {
  clusterid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BGPRouterParameters::_internal_clusterid() const {
  return clusterid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BGPRouterParameters::clusterid() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.clusterID)
  return _internal_clusterid();
}
inline void BGPRouterParameters::_internal_set_clusterid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  clusterid_ = value;
}
inline void BGPRouterParameters::set_clusterid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_clusterid(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.clusterID)
}

// optional int32 autonomousSystem = 4;
inline bool BGPRouterParameters::_internal_has_autonomoussystem() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_autonomoussystem() const {
  return _internal_has_autonomoussystem();
}
inline void BGPRouterParameters::clear_autonomoussystem() {
  autonomoussystem_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::_internal_autonomoussystem() const {
  return autonomoussystem_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::autonomoussystem() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.autonomousSystem)
  return _internal_autonomoussystem();
}
inline void BGPRouterParameters::_internal_set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  autonomoussystem_ = value;
}
inline void BGPRouterParameters::set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_autonomoussystem(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.autonomousSystem)
}

// optional string identifier = 5;
inline bool BGPRouterParameters::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_identifier() const {
  return _internal_has_identifier();
}
inline void BGPRouterParameters::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BGPRouterParameters::identifier() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPRouterParameters::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.identifier)
}
inline std::string* BGPRouterParameters::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.identifier)
  return _s;
}
inline const std::string& BGPRouterParameters::_internal_identifier() const {
  return identifier_.Get();
}
inline void BGPRouterParameters::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::release_identifier() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPRouterParameters::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.identifier)
}

// optional string address = 6;
inline bool BGPRouterParameters::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_address() const {
  return _internal_has_address();
}
inline void BGPRouterParameters::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BGPRouterParameters::address() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPRouterParameters::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.address)
}
inline std::string* BGPRouterParameters::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.address)
  return _s;
}
inline const std::string& BGPRouterParameters::_internal_address() const {
  return address_.Get();
}
inline void BGPRouterParameters::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000004u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::release_address() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPRouterParameters::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.address)
}

// optional int32 port = 7;
inline bool BGPRouterParameters::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_port() const {
  return _internal_has_port();
}
inline void BGPRouterParameters::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::port() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.port)
  return _internal_port();
}
inline void BGPRouterParameters::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  port_ = value;
}
inline void BGPRouterParameters::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.port)
}

// optional int32 sourcePort = 8;
inline bool BGPRouterParameters::_internal_has_sourceport() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void BGPRouterParameters::clear_sourceport() {
  sourceport_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::_internal_sourceport() const {
  return sourceport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::sourceport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.sourcePort)
  return _internal_sourceport();
}
inline void BGPRouterParameters::_internal_set_sourceport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  sourceport_ = value;
}
inline void BGPRouterParameters::set_sourceport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sourceport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.sourcePort)
}

// optional int32 holdTime = 9;
inline bool BGPRouterParameters::_internal_has_holdtime() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_holdtime() const {
  return _internal_has_holdtime();
}
inline void BGPRouterParameters::clear_holdtime() {
  holdtime_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::_internal_holdtime() const {
  return holdtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::holdtime() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.holdTime)
  return _internal_holdtime();
}
inline void BGPRouterParameters::_internal_set_holdtime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00002000u;
  holdtime_ = value;
}
inline void BGPRouterParameters::set_holdtime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_holdtime(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.holdTime)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies addressFamilies = 10;
inline bool BGPRouterParameters::_internal_has_addressfamilies() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || addressfamilies_ != nullptr);
  return value;
}
inline bool BGPRouterParameters::has_addressfamilies() const {
  return _internal_has_addressfamilies();
}
inline void BGPRouterParameters::clear_addressfamilies() {
  if (addressfamilies_ != nullptr) addressfamilies_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies& BGPRouterParameters::_internal_addressfamilies() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* p = addressfamilies_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AddressFamilies_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies& BGPRouterParameters::addressfamilies() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.addressFamilies)
  return _internal_addressfamilies();
}
inline void BGPRouterParameters::unsafe_arena_set_allocated_addressfamilies(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addressfamilies_);
  }
  addressfamilies_ = addressfamilies;
  if (addressfamilies) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.addressFamilies)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* BGPRouterParameters::release_addressfamilies() {
  _has_bits_[0] &= ~0x00000040u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* temp = addressfamilies_;
  addressfamilies_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* BGPRouterParameters::unsafe_arena_release_addressfamilies() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.addressFamilies)
  _has_bits_[0] &= ~0x00000040u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* temp = addressfamilies_;
  addressfamilies_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* BGPRouterParameters::_internal_mutable_addressfamilies() {
  _has_bits_[0] |= 0x00000040u;
  if (addressfamilies_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies>(GetArenaForAllocation());
    addressfamilies_ = p;
  }
  return addressfamilies_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* BGPRouterParameters::mutable_addressfamilies() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* _msg = _internal_mutable_addressfamilies();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.addressFamilies)
  return _msg;
}
inline void BGPRouterParameters::set_allocated_addressfamilies(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addressfamilies_;
  }
  if (addressfamilies) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies>::GetOwningArena(addressfamilies);
    if (message_arena != submessage_arena) {
      addressfamilies = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addressfamilies, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  addressfamilies_ = addressfamilies;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.addressFamilies)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData authData = 11;
inline bool BGPRouterParameters::_internal_has_authdata() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || authdata_ != nullptr);
  return value;
}
inline bool BGPRouterParameters::has_authdata() const {
  return _internal_has_authdata();
}
inline void BGPRouterParameters::clear_authdata() {
  if (authdata_ != nullptr) authdata_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData& BGPRouterParameters::_internal_authdata() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* p = authdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AuthenticationData_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData& BGPRouterParameters::authdata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.authData)
  return _internal_authdata();
}
inline void BGPRouterParameters::unsafe_arena_set_allocated_authdata(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authdata_);
  }
  authdata_ = authdata;
  if (authdata) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.authData)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* BGPRouterParameters::release_authdata() {
  _has_bits_[0] &= ~0x00000080u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* temp = authdata_;
  authdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* BGPRouterParameters::unsafe_arena_release_authdata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.authData)
  _has_bits_[0] &= ~0x00000080u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* temp = authdata_;
  authdata_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* BGPRouterParameters::_internal_mutable_authdata() {
  _has_bits_[0] |= 0x00000080u;
  if (authdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData>(GetArenaForAllocation());
    authdata_ = p;
  }
  return authdata_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* BGPRouterParameters::mutable_authdata() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* _msg = _internal_mutable_authdata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.authData)
  return _msg;
}
inline void BGPRouterParameters::set_allocated_authdata(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authdata_;
  }
  if (authdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData>::GetOwningArena(authdata);
    if (message_arena != submessage_arena) {
      authdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authdata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  authdata_ = authdata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.authData)
}

// optional int32 localAutonomousSystem = 12;
inline bool BGPRouterParameters::_internal_has_localautonomoussystem() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_localautonomoussystem() const {
  return _internal_has_localautonomoussystem();
}
inline void BGPRouterParameters::clear_localautonomoussystem() {
  localautonomoussystem_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::_internal_localautonomoussystem() const {
  return localautonomoussystem_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPRouterParameters::localautonomoussystem() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.localAutonomousSystem)
  return _internal_localautonomoussystem();
}
inline void BGPRouterParameters::_internal_set_localautonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  localautonomoussystem_ = value;
}
inline void BGPRouterParameters::set_localautonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_localautonomoussystem(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.localAutonomousSystem)
}

// optional string routerType = 13;
inline bool BGPRouterParameters::_internal_has_routertype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_routertype() const {
  return _internal_has_routertype();
}
inline void BGPRouterParameters::clear_routertype() {
  routertype_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BGPRouterParameters::routertype() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.routerType)
  return _internal_routertype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPRouterParameters::set_routertype(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 routertype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.routerType)
}
inline std::string* BGPRouterParameters::mutable_routertype() {
  std::string* _s = _internal_mutable_routertype();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.routerType)
  return _s;
}
inline const std::string& BGPRouterParameters::_internal_routertype() const {
  return routertype_.Get();
}
inline void BGPRouterParameters::_internal_set_routertype(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  routertype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::_internal_mutable_routertype() {
  _has_bits_[0] |= 0x00000008u;
  return routertype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::release_routertype() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.routerType)
  if (!_internal_has_routertype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return routertype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPRouterParameters::set_allocated_routertype(std::string* routertype) {
  if (routertype != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  routertype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), routertype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.routerType)
}

// optional string gatewayAddress = 14;
inline bool BGPRouterParameters::_internal_has_gatewayaddress() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_gatewayaddress() const {
  return _internal_has_gatewayaddress();
}
inline void BGPRouterParameters::clear_gatewayaddress() {
  gatewayaddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BGPRouterParameters::gatewayaddress() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.gatewayAddress)
  return _internal_gatewayaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPRouterParameters::set_gatewayaddress(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 gatewayaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.gatewayAddress)
}
inline std::string* BGPRouterParameters::mutable_gatewayaddress() {
  std::string* _s = _internal_mutable_gatewayaddress();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.gatewayAddress)
  return _s;
}
inline const std::string& BGPRouterParameters::_internal_gatewayaddress() const {
  return gatewayaddress_.Get();
}
inline void BGPRouterParameters::_internal_set_gatewayaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  gatewayaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::_internal_mutable_gatewayaddress() {
  _has_bits_[0] |= 0x00000010u;
  return gatewayaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::release_gatewayaddress() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.gatewayAddress)
  if (!_internal_has_gatewayaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return gatewayaddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPRouterParameters::set_allocated_gatewayaddress(std::string* gatewayaddress) {
  if (gatewayaddress != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  gatewayaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gatewayaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.gatewayAddress)
}

// optional string ipv6GatewayAddress = 15;
inline bool BGPRouterParameters::_internal_has_ipv6gatewayaddress() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BGPRouterParameters::has_ipv6gatewayaddress() const {
  return _internal_has_ipv6gatewayaddress();
}
inline void BGPRouterParameters::clear_ipv6gatewayaddress() {
  ipv6gatewayaddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& BGPRouterParameters::ipv6gatewayaddress() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.ipv6GatewayAddress)
  return _internal_ipv6gatewayaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPRouterParameters::set_ipv6gatewayaddress(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 ipv6gatewayaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.ipv6GatewayAddress)
}
inline std::string* BGPRouterParameters::mutable_ipv6gatewayaddress() {
  std::string* _s = _internal_mutable_ipv6gatewayaddress();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.ipv6GatewayAddress)
  return _s;
}
inline const std::string& BGPRouterParameters::_internal_ipv6gatewayaddress() const {
  return ipv6gatewayaddress_.Get();
}
inline void BGPRouterParameters::_internal_set_ipv6gatewayaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  ipv6gatewayaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::_internal_mutable_ipv6gatewayaddress() {
  _has_bits_[0] |= 0x00000020u;
  return ipv6gatewayaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPRouterParameters::release_ipv6gatewayaddress() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.ipv6GatewayAddress)
  if (!_internal_has_ipv6gatewayaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return ipv6gatewayaddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPRouterParameters::set_allocated_ipv6gatewayaddress(std::string* ipv6gatewayaddress) {
  if (ipv6gatewayaddress != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  ipv6gatewayaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipv6gatewayaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters.ipv6GatewayAddress)
}

// -------------------------------------------------------------------

// BGPRouterReference

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
inline bool BGPRouterReference::_internal_has_resourcereference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || resourcereference_ != nullptr);
  return value;
}
inline bool BGPRouterReference::has_resourcereference() const {
  return _internal_has_resourcereference();
}
inline void BGPRouterReference::clear_resourcereference() {
  if (resourcereference_ != nullptr) resourcereference_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& BGPRouterReference::_internal_resourcereference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = resourcereference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& BGPRouterReference::resourcereference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.resourceReference)
  return _internal_resourcereference();
}
inline void BGPRouterReference::unsafe_arena_set_allocated_resourcereference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resourcereference_);
  }
  resourcereference_ = resourcereference;
  if (resourcereference) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.resourceReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* BGPRouterReference::release_resourcereference() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* BGPRouterReference::unsafe_arena_release_resourcereference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.resourceReference)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* BGPRouterReference::_internal_mutable_resourcereference() {
  _has_bits_[0] |= 0x00000001u;
  if (resourcereference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    resourcereference_ = p;
  }
  return resourcereference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* BGPRouterReference::mutable_resourcereference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_resourcereference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.resourceReference)
  return _msg;
}
inline void BGPRouterReference::set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resourcereference_;
  }
  if (resourcereference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(resourcereference);
    if (message_arena != submessage_arena) {
      resourcereference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resourcereference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resourcereference_ = resourcereference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.resourceReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes attributes = 2;
inline bool BGPRouterReference::_internal_has_attributes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || attributes_ != nullptr);
  return value;
}
inline bool BGPRouterReference::has_attributes() const {
  return _internal_has_attributes();
}
inline void BGPRouterReference::clear_attributes() {
  if (attributes_ != nullptr) attributes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes& BGPRouterReference::_internal_attributes() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPRouterReferenceAttributes_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes& BGPRouterReference::attributes() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.attributes)
  return _internal_attributes();
}
inline void BGPRouterReference::unsafe_arena_set_allocated_attributes(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.attributes)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* BGPRouterReference::release_attributes() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* BGPRouterReference::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.attributes)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* BGPRouterReference::_internal_mutable_attributes() {
  _has_bits_[0] |= 0x00000002u;
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* BGPRouterReference::mutable_attributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.attributes)
  return _msg;
}
inline void BGPRouterReference::set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReferenceAttributes>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference.attributes)
}

// -------------------------------------------------------------------

// BGPRouterReferenceAttributes

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession session = 1;
inline int BGPRouterReferenceAttributes::_internal_session_size() const {
  return session_.size();
}
inline int BGPRouterReferenceAttributes::session_size() const {
  return _internal_session_size();
}
inline void BGPRouterReferenceAttributes::clear_session() {
  session_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession* BGPRouterReferenceAttributes::mutable_session(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes.session)
  return session_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession >*
BGPRouterReferenceAttributes::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes.session)
  return &session_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession& BGPRouterReferenceAttributes::_internal_session(int index) const {
  return session_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession& BGPRouterReferenceAttributes::session(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes.session)
  return _internal_session(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession* BGPRouterReferenceAttributes::_internal_add_session() {
  return session_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession* BGPRouterReferenceAttributes::add_session() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession* _add = _internal_add_session();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes.session)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSession >&
BGPRouterReferenceAttributes::session() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes.session)
  return session_;
}

// -------------------------------------------------------------------

// BGPRouterSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool BGPRouterSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool BGPRouterSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void BGPRouterSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& BGPRouterSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& BGPRouterSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.commonSpec)
  return _internal_commonspec();
}
inline void BGPRouterSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* BGPRouterSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* BGPRouterSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* BGPRouterSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* BGPRouterSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.commonSpec)
  return _msg;
}
inline void BGPRouterSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.commonSpec)
}

// optional .k8s.io.api.core.v1.ObjectReference parent = 2;
inline bool BGPRouterSpec::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || parent_ != nullptr);
  return value;
}
inline bool BGPRouterSpec::has_parent() const {
  return _internal_has_parent();
}
inline const ::k8s::io::api::core::v1::ObjectReference& BGPRouterSpec::_internal_parent() const {
  const ::k8s::io::api::core::v1::ObjectReference* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::api::core::v1::ObjectReference&>(
      ::k8s::io::api::core::v1::_ObjectReference_default_instance_);
}
inline const ::k8s::io::api::core::v1::ObjectReference& BGPRouterSpec::parent() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.parent)
  return _internal_parent();
}
inline void BGPRouterSpec::unsafe_arena_set_allocated_parent(
    ::k8s::io::api::core::v1::ObjectReference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.parent)
}
inline ::k8s::io::api::core::v1::ObjectReference* BGPRouterSpec::release_parent() {
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* BGPRouterSpec::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.parent)
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* BGPRouterSpec::_internal_mutable_parent() {
  _has_bits_[0] |= 0x00000002u;
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::api::core::v1::ObjectReference>(GetArenaForAllocation());
    parent_ = p;
  }
  return parent_;
}
inline ::k8s::io::api::core::v1::ObjectReference* BGPRouterSpec::mutable_parent() {
  ::k8s::io::api::core::v1::ObjectReference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.parent)
  return _msg;
}
inline void BGPRouterSpec::set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent));
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.parent)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference bgpRouterReferences = 4;
inline int BGPRouterSpec::_internal_bgprouterreferences_size() const {
  return bgprouterreferences_.size();
}
inline int BGPRouterSpec::bgprouterreferences_size() const {
  return _internal_bgprouterreferences_size();
}
inline void BGPRouterSpec::clear_bgprouterreferences() {
  bgprouterreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* BGPRouterSpec::mutable_bgprouterreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterReferences)
  return bgprouterreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference >*
BGPRouterSpec::mutable_bgprouterreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterReferences)
  return &bgprouterreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference& BGPRouterSpec::_internal_bgprouterreferences(int index) const {
  return bgprouterreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference& BGPRouterSpec::bgprouterreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterReferences)
  return _internal_bgprouterreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* BGPRouterSpec::_internal_add_bgprouterreferences() {
  return bgprouterreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* BGPRouterSpec::add_bgprouterreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference* _add = _internal_add_bgprouterreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterReference >&
BGPRouterSpec::bgprouterreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterReferences)
  return bgprouterreferences_;
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters bgpRouterParameters = 3;
inline bool BGPRouterSpec::_internal_has_bgprouterparameters() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || bgprouterparameters_ != nullptr);
  return value;
}
inline bool BGPRouterSpec::has_bgprouterparameters() const {
  return _internal_has_bgprouterparameters();
}
inline void BGPRouterSpec::clear_bgprouterparameters() {
  if (bgprouterparameters_ != nullptr) bgprouterparameters_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters& BGPRouterSpec::_internal_bgprouterparameters() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* p = bgprouterparameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPRouterParameters_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters& BGPRouterSpec::bgprouterparameters() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterParameters)
  return _internal_bgprouterparameters();
}
inline void BGPRouterSpec::unsafe_arena_set_allocated_bgprouterparameters(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* bgprouterparameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bgprouterparameters_);
  }
  bgprouterparameters_ = bgprouterparameters;
  if (bgprouterparameters) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterParameters)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* BGPRouterSpec::release_bgprouterparameters() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* temp = bgprouterparameters_;
  bgprouterparameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* BGPRouterSpec::unsafe_arena_release_bgprouterparameters() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterParameters)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* temp = bgprouterparameters_;
  bgprouterparameters_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* BGPRouterSpec::_internal_mutable_bgprouterparameters() {
  _has_bits_[0] |= 0x00000004u;
  if (bgprouterparameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters>(GetArenaForAllocation());
    bgprouterparameters_ = p;
  }
  return bgprouterparameters_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* BGPRouterSpec::mutable_bgprouterparameters() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* _msg = _internal_mutable_bgprouterparameters();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterParameters)
  return _msg;
}
inline void BGPRouterSpec::set_allocated_bgprouterparameters(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters* bgprouterparameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bgprouterparameters_;
  }
  if (bgprouterparameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPRouterParameters>::GetOwningArena(bgprouterparameters);
    if (message_arena != submessage_arena) {
      bgprouterparameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bgprouterparameters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  bgprouterparameters_ = bgprouterparameters;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec.bgpRouterParameters)
}

// -------------------------------------------------------------------

// BGPRouterStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool BGPRouterStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool BGPRouterStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void BGPRouterStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& BGPRouterStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& BGPRouterStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus.commonStatus)
  return _internal_commonstatus();
}
inline void BGPRouterStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* BGPRouterStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* BGPRouterStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* BGPRouterStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* BGPRouterStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus.commonStatus)
  return _msg;
}
inline void BGPRouterStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus.commonStatus)
}

// -------------------------------------------------------------------

// BGPSession

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes sessionAttributes = 1;
inline int BGPSession::_internal_sessionattributes_size() const {
  return sessionattributes_.size();
}
inline int BGPSession::sessionattributes_size() const {
  return _internal_sessionattributes_size();
}
inline void BGPSession::clear_sessionattributes() {
  sessionattributes_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* BGPSession::mutable_sessionattributes(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession.sessionAttributes)
  return sessionattributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes >*
BGPSession::mutable_sessionattributes() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession.sessionAttributes)
  return &sessionattributes_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes& BGPSession::_internal_sessionattributes(int index) const {
  return sessionattributes_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes& BGPSession::sessionattributes(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession.sessionAttributes)
  return _internal_sessionattributes(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* BGPSession::_internal_add_sessionattributes() {
  return sessionattributes_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* BGPSession::add_sessionattributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes* _add = _internal_add_sessionattributes();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession.sessionAttributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionAttributes >&
BGPSession::sessionattributes() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession.sessionAttributes)
  return sessionattributes_;
}

// -------------------------------------------------------------------

// BGPSessionAttributes

// optional string bgpRouter = 1;
inline bool BGPSessionAttributes::_internal_has_bgprouter() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BGPSessionAttributes::has_bgprouter() const {
  return _internal_has_bgprouter();
}
inline void BGPSessionAttributes::clear_bgprouter() {
  bgprouter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BGPSessionAttributes::bgprouter() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.bgpRouter)
  return _internal_bgprouter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPSessionAttributes::set_bgprouter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 bgprouter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.bgpRouter)
}
inline std::string* BGPSessionAttributes::mutable_bgprouter() {
  std::string* _s = _internal_mutable_bgprouter();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.bgpRouter)
  return _s;
}
inline const std::string& BGPSessionAttributes::_internal_bgprouter() const {
  return bgprouter_.Get();
}
inline void BGPSessionAttributes::_internal_set_bgprouter(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bgprouter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPSessionAttributes::_internal_mutable_bgprouter() {
  _has_bits_[0] |= 0x00000001u;
  return bgprouter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPSessionAttributes::release_bgprouter() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.bgpRouter)
  if (!_internal_has_bgprouter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return bgprouter_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPSessionAttributes::set_allocated_bgprouter(std::string* bgprouter) {
  if (bgprouter != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bgprouter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bgprouter,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.bgpRouter)
}

// optional bool adminDown = 2;
inline bool BGPSessionAttributes::_internal_has_admindown() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BGPSessionAttributes::has_admindown() const {
  return _internal_has_admindown();
}
inline void BGPSessionAttributes::clear_admindown() {
  admindown_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool BGPSessionAttributes::_internal_admindown() const {
  return admindown_;
}
inline bool BGPSessionAttributes::admindown() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.adminDown)
  return _internal_admindown();
}
inline void BGPSessionAttributes::_internal_set_admindown(bool value) {
  _has_bits_[0] |= 0x00000020u;
  admindown_ = value;
}
inline void BGPSessionAttributes::set_admindown(bool value) {
  _internal_set_admindown(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.adminDown)
}

// optional bool passive = 3;
inline bool BGPSessionAttributes::_internal_has_passive() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BGPSessionAttributes::has_passive() const {
  return _internal_has_passive();
}
inline void BGPSessionAttributes::clear_passive() {
  passive_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool BGPSessionAttributes::_internal_passive() const {
  return passive_;
}
inline bool BGPSessionAttributes::passive() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.passive)
  return _internal_passive();
}
inline void BGPSessionAttributes::_internal_set_passive(bool value) {
  _has_bits_[0] |= 0x00000040u;
  passive_ = value;
}
inline void BGPSessionAttributes::set_passive(bool value) {
  _internal_set_passive(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.passive)
}

// optional bool asOverride = 4;
inline bool BGPSessionAttributes::_internal_has_asoverride() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BGPSessionAttributes::has_asoverride() const {
  return _internal_has_asoverride();
}
inline void BGPSessionAttributes::clear_asoverride() {
  asoverride_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool BGPSessionAttributes::_internal_asoverride() const {
  return asoverride_;
}
inline bool BGPSessionAttributes::asoverride() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.asOverride)
  return _internal_asoverride();
}
inline void BGPSessionAttributes::_internal_set_asoverride(bool value) {
  _has_bits_[0] |= 0x00000080u;
  asoverride_ = value;
}
inline void BGPSessionAttributes::set_asoverride(bool value) {
  _internal_set_asoverride(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.asOverride)
}

// optional int32 holdTime = 5;
inline bool BGPSessionAttributes::_internal_has_holdtime() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BGPSessionAttributes::has_holdtime() const {
  return _internal_has_holdtime();
}
inline void BGPSessionAttributes::clear_holdtime() {
  holdtime_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPSessionAttributes::_internal_holdtime() const {
  return holdtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPSessionAttributes::holdtime() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.holdTime)
  return _internal_holdtime();
}
inline void BGPSessionAttributes::_internal_set_holdtime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  holdtime_ = value;
}
inline void BGPSessionAttributes::set_holdtime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_holdtime(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.holdTime)
}

// optional int32 loopCount = 6;
inline bool BGPSessionAttributes::_internal_has_loopcount() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool BGPSessionAttributes::has_loopcount() const {
  return _internal_has_loopcount();
}
inline void BGPSessionAttributes::clear_loopcount() {
  loopcount_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPSessionAttributes::_internal_loopcount() const {
  return loopcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPSessionAttributes::loopcount() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.loopCount)
  return _internal_loopcount();
}
inline void BGPSessionAttributes::_internal_set_loopcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  loopcount_ = value;
}
inline void BGPSessionAttributes::set_loopcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_loopcount(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.loopCount)
}

// optional int32 localAutonomousSystem = 7;
inline bool BGPSessionAttributes::_internal_has_localautonomoussystem() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool BGPSessionAttributes::has_localautonomoussystem() const {
  return _internal_has_localautonomoussystem();
}
inline void BGPSessionAttributes::clear_localautonomoussystem() {
  localautonomoussystem_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPSessionAttributes::_internal_localautonomoussystem() const {
  return localautonomoussystem_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGPSessionAttributes::localautonomoussystem() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.localAutonomousSystem)
  return _internal_localautonomoussystem();
}
inline void BGPSessionAttributes::_internal_set_localautonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  localautonomoussystem_ = value;
}
inline void BGPSessionAttributes::set_localautonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_localautonomoussystem(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.localAutonomousSystem)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies addressFamilies = 8;
inline bool BGPSessionAttributes::_internal_has_addressfamilies() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || addressfamilies_ != nullptr);
  return value;
}
inline bool BGPSessionAttributes::has_addressfamilies() const {
  return _internal_has_addressfamilies();
}
inline void BGPSessionAttributes::clear_addressfamilies() {
  if (addressfamilies_ != nullptr) addressfamilies_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies& BGPSessionAttributes::_internal_addressfamilies() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* p = addressfamilies_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AddressFamilies_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies& BGPSessionAttributes::addressfamilies() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.addressFamilies)
  return _internal_addressfamilies();
}
inline void BGPSessionAttributes::unsafe_arena_set_allocated_addressfamilies(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addressfamilies_);
  }
  addressfamilies_ = addressfamilies;
  if (addressfamilies) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.addressFamilies)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* BGPSessionAttributes::release_addressfamilies() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* temp = addressfamilies_;
  addressfamilies_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* BGPSessionAttributes::unsafe_arena_release_addressfamilies() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.addressFamilies)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* temp = addressfamilies_;
  addressfamilies_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* BGPSessionAttributes::_internal_mutable_addressfamilies() {
  _has_bits_[0] |= 0x00000004u;
  if (addressfamilies_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies>(GetArenaForAllocation());
    addressfamilies_ = p;
  }
  return addressfamilies_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* BGPSessionAttributes::mutable_addressfamilies() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* _msg = _internal_mutable_addressfamilies();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.addressFamilies)
  return _msg;
}
inline void BGPSessionAttributes::set_allocated_addressfamilies(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies* addressfamilies) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addressfamilies_;
  }
  if (addressfamilies) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AddressFamilies>::GetOwningArena(addressfamilies);
    if (message_arena != submessage_arena) {
      addressfamilies = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addressfamilies, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  addressfamilies_ = addressfamilies;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.addressFamilies)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData authData = 9;
inline bool BGPSessionAttributes::_internal_has_authdata() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || authdata_ != nullptr);
  return value;
}
inline bool BGPSessionAttributes::has_authdata() const {
  return _internal_has_authdata();
}
inline void BGPSessionAttributes::clear_authdata() {
  if (authdata_ != nullptr) authdata_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData& BGPSessionAttributes::_internal_authdata() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* p = authdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AuthenticationData_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData& BGPSessionAttributes::authdata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.authData)
  return _internal_authdata();
}
inline void BGPSessionAttributes::unsafe_arena_set_allocated_authdata(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authdata_);
  }
  authdata_ = authdata;
  if (authdata) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.authData)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* BGPSessionAttributes::release_authdata() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* temp = authdata_;
  authdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* BGPSessionAttributes::unsafe_arena_release_authdata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.authData)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* temp = authdata_;
  authdata_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* BGPSessionAttributes::_internal_mutable_authdata() {
  _has_bits_[0] |= 0x00000008u;
  if (authdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData>(GetArenaForAllocation());
    authdata_ = p;
  }
  return authdata_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* BGPSessionAttributes::mutable_authdata() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* _msg = _internal_mutable_authdata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.authData)
  return _msg;
}
inline void BGPSessionAttributes::set_allocated_authdata(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData* authdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authdata_;
  }
  if (authdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AuthenticationData>::GetOwningArena(authdata);
    if (message_arena != submessage_arena) {
      authdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authdata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  authdata_ = authdata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.authData)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes familyAttributes = 10;
inline int BGPSessionAttributes::_internal_familyattributes_size() const {
  return familyattributes_.size();
}
inline int BGPSessionAttributes::familyattributes_size() const {
  return _internal_familyattributes_size();
}
inline void BGPSessionAttributes::clear_familyattributes() {
  familyattributes_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes* BGPSessionAttributes::mutable_familyattributes(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.familyAttributes)
  return familyattributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes >*
BGPSessionAttributes::mutable_familyattributes() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.familyAttributes)
  return &familyattributes_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes& BGPSessionAttributes::_internal_familyattributes(int index) const {
  return familyattributes_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes& BGPSessionAttributes::familyattributes(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.familyAttributes)
  return _internal_familyattributes(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes* BGPSessionAttributes::_internal_add_familyattributes() {
  return familyattributes_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes* BGPSessionAttributes::add_familyattributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes* _add = _internal_add_familyattributes();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.familyAttributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPFamilyAttributes >&
BGPSessionAttributes::familyattributes() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.familyAttributes)
  return familyattributes_;
}

// optional string privateAsAction = 11;
inline bool BGPSessionAttributes::_internal_has_privateasaction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BGPSessionAttributes::has_privateasaction() const {
  return _internal_has_privateasaction();
}
inline void BGPSessionAttributes::clear_privateasaction() {
  privateasaction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BGPSessionAttributes::privateasaction() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.privateAsAction)
  return _internal_privateasaction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPSessionAttributes::set_privateasaction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 privateasaction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.privateAsAction)
}
inline std::string* BGPSessionAttributes::mutable_privateasaction() {
  std::string* _s = _internal_mutable_privateasaction();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.privateAsAction)
  return _s;
}
inline const std::string& BGPSessionAttributes::_internal_privateasaction() const {
  return privateasaction_.Get();
}
inline void BGPSessionAttributes::_internal_set_privateasaction(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  privateasaction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPSessionAttributes::_internal_mutable_privateasaction() {
  _has_bits_[0] |= 0x00000002u;
  return privateasaction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPSessionAttributes::release_privateasaction() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.privateAsAction)
  if (!_internal_has_privateasaction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return privateasaction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPSessionAttributes::set_allocated_privateasaction(std::string* privateasaction) {
  if (privateasaction != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  privateasaction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privateasaction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.privateAsAction)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride routeOriginOverride = 12;
inline bool BGPSessionAttributes::_internal_has_routeoriginoverride() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || routeoriginoverride_ != nullptr);
  return value;
}
inline bool BGPSessionAttributes::has_routeoriginoverride() const {
  return _internal_has_routeoriginoverride();
}
inline void BGPSessionAttributes::clear_routeoriginoverride() {
  if (routeoriginoverride_ != nullptr) routeoriginoverride_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride& BGPSessionAttributes::_internal_routeoriginoverride() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* p = routeoriginoverride_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_RouteOriginOverride_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride& BGPSessionAttributes::routeoriginoverride() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.routeOriginOverride)
  return _internal_routeoriginoverride();
}
inline void BGPSessionAttributes::unsafe_arena_set_allocated_routeoriginoverride(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* routeoriginoverride) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routeoriginoverride_);
  }
  routeoriginoverride_ = routeoriginoverride;
  if (routeoriginoverride) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.routeOriginOverride)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* BGPSessionAttributes::release_routeoriginoverride() {
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* temp = routeoriginoverride_;
  routeoriginoverride_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* BGPSessionAttributes::unsafe_arena_release_routeoriginoverride() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.routeOriginOverride)
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* temp = routeoriginoverride_;
  routeoriginoverride_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* BGPSessionAttributes::_internal_mutable_routeoriginoverride() {
  _has_bits_[0] |= 0x00000010u;
  if (routeoriginoverride_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride>(GetArenaForAllocation());
    routeoriginoverride_ = p;
  }
  return routeoriginoverride_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* BGPSessionAttributes::mutable_routeoriginoverride() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* _msg = _internal_mutable_routeoriginoverride();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.routeOriginOverride)
  return _msg;
}
inline void BGPSessionAttributes::set_allocated_routeoriginoverride(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride* routeoriginoverride) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete routeoriginoverride_;
  }
  if (routeoriginoverride) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteOriginOverride>::GetOwningArena(routeoriginoverride);
    if (message_arena != submessage_arena) {
      routeoriginoverride = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routeoriginoverride, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  routeoriginoverride_ = routeoriginoverride;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes.routeOriginOverride)
}

// -------------------------------------------------------------------

// BGPSessionIPAttributes

// optional string bgpaasPrimaryIP = 1;
inline bool BGPSessionIPAttributes::_internal_has_bgpaasprimaryip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BGPSessionIPAttributes::has_bgpaasprimaryip() const {
  return _internal_has_bgpaasprimaryip();
}
inline void BGPSessionIPAttributes::clear_bgpaasprimaryip() {
  bgpaasprimaryip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BGPSessionIPAttributes::bgpaasprimaryip() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasPrimaryIP)
  return _internal_bgpaasprimaryip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPSessionIPAttributes::set_bgpaasprimaryip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 bgpaasprimaryip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasPrimaryIP)
}
inline std::string* BGPSessionIPAttributes::mutable_bgpaasprimaryip() {
  std::string* _s = _internal_mutable_bgpaasprimaryip();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasPrimaryIP)
  return _s;
}
inline const std::string& BGPSessionIPAttributes::_internal_bgpaasprimaryip() const {
  return bgpaasprimaryip_.Get();
}
inline void BGPSessionIPAttributes::_internal_set_bgpaasprimaryip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bgpaasprimaryip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPSessionIPAttributes::_internal_mutable_bgpaasprimaryip() {
  _has_bits_[0] |= 0x00000001u;
  return bgpaasprimaryip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPSessionIPAttributes::release_bgpaasprimaryip() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasPrimaryIP)
  if (!_internal_has_bgpaasprimaryip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return bgpaasprimaryip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPSessionIPAttributes::set_allocated_bgpaasprimaryip(std::string* bgpaasprimaryip) {
  if (bgpaasprimaryip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bgpaasprimaryip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bgpaasprimaryip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasPrimaryIP)
}

// optional string bgpaasSecondaryIP = 2;
inline bool BGPSessionIPAttributes::_internal_has_bgpaassecondaryip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BGPSessionIPAttributes::has_bgpaassecondaryip() const {
  return _internal_has_bgpaassecondaryip();
}
inline void BGPSessionIPAttributes::clear_bgpaassecondaryip() {
  bgpaassecondaryip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BGPSessionIPAttributes::bgpaassecondaryip() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasSecondaryIP)
  return _internal_bgpaassecondaryip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BGPSessionIPAttributes::set_bgpaassecondaryip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 bgpaassecondaryip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasSecondaryIP)
}
inline std::string* BGPSessionIPAttributes::mutable_bgpaassecondaryip() {
  std::string* _s = _internal_mutable_bgpaassecondaryip();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasSecondaryIP)
  return _s;
}
inline const std::string& BGPSessionIPAttributes::_internal_bgpaassecondaryip() const {
  return bgpaassecondaryip_.Get();
}
inline void BGPSessionIPAttributes::_internal_set_bgpaassecondaryip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  bgpaassecondaryip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BGPSessionIPAttributes::_internal_mutable_bgpaassecondaryip() {
  _has_bits_[0] |= 0x00000002u;
  return bgpaassecondaryip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BGPSessionIPAttributes::release_bgpaassecondaryip() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasSecondaryIP)
  if (!_internal_has_bgpaassecondaryip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return bgpaassecondaryip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BGPSessionIPAttributes::set_allocated_bgpaassecondaryip(std::string* bgpaassecondaryip) {
  if (bgpaassecondaryip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  bgpaassecondaryip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bgpaassecondaryip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes.bgpaasSecondaryIP)
}

// -------------------------------------------------------------------

// CommonSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName contrailFqName = 1;
inline bool CommonSpec::_internal_has_contrailfqname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || contrailfqname_ != nullptr);
  return value;
}
inline bool CommonSpec::has_contrailfqname() const {
  return _internal_has_contrailfqname();
}
inline void CommonSpec::clear_contrailfqname() {
  if (contrailfqname_ != nullptr) contrailfqname_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName& CommonSpec::_internal_contrailfqname() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* p = contrailfqname_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ContrailFqName_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName& CommonSpec::contrailfqname() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec.contrailFqName)
  return _internal_contrailfqname();
}
inline void CommonSpec::unsafe_arena_set_allocated_contrailfqname(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contrailfqname_);
  }
  contrailfqname_ = contrailfqname;
  if (contrailfqname) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec.contrailFqName)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* CommonSpec::release_contrailfqname() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* temp = contrailfqname_;
  contrailfqname_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* CommonSpec::unsafe_arena_release_contrailfqname() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec.contrailFqName)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* temp = contrailfqname_;
  contrailfqname_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* CommonSpec::_internal_mutable_contrailfqname() {
  _has_bits_[0] |= 0x00000001u;
  if (contrailfqname_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName>(GetArenaForAllocation());
    contrailfqname_ = p;
  }
  return contrailfqname_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* CommonSpec::mutable_contrailfqname() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* _msg = _internal_mutable_contrailfqname();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec.contrailFqName)
  return _msg;
}
inline void CommonSpec::set_allocated_contrailfqname(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete contrailfqname_;
  }
  if (contrailfqname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName>::GetOwningArena(contrailfqname);
    if (message_arena != submessage_arena) {
      contrailfqname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contrailfqname, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contrailfqname_ = contrailfqname;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec.contrailFqName)
}

// -------------------------------------------------------------------

// CommonStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState reconcilerState = 1;
inline bool CommonStatus::_internal_has_reconcilerstate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || reconcilerstate_ != nullptr);
  return value;
}
inline bool CommonStatus::has_reconcilerstate() const {
  return _internal_has_reconcilerstate();
}
inline void CommonStatus::clear_reconcilerstate() {
  if (reconcilerstate_ != nullptr) reconcilerstate_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState& CommonStatus::_internal_reconcilerstate() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* p = reconcilerstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ReconcilerState_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState& CommonStatus::reconcilerstate() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus.reconcilerState)
  return _internal_reconcilerstate();
}
inline void CommonStatus::unsafe_arena_set_allocated_reconcilerstate(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* reconcilerstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reconcilerstate_);
  }
  reconcilerstate_ = reconcilerstate;
  if (reconcilerstate) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus.reconcilerState)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* CommonStatus::release_reconcilerstate() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* temp = reconcilerstate_;
  reconcilerstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* CommonStatus::unsafe_arena_release_reconcilerstate() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus.reconcilerState)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* temp = reconcilerstate_;
  reconcilerstate_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* CommonStatus::_internal_mutable_reconcilerstate() {
  _has_bits_[0] |= 0x00000001u;
  if (reconcilerstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState>(GetArenaForAllocation());
    reconcilerstate_ = p;
  }
  return reconcilerstate_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* CommonStatus::mutable_reconcilerstate() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* _msg = _internal_mutable_reconcilerstate();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus.reconcilerState)
  return _msg;
}
inline void CommonStatus::set_allocated_reconcilerstate(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState* reconcilerstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reconcilerstate_;
  }
  if (reconcilerstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ReconcilerState>::GetOwningArena(reconcilerstate);
    if (message_arena != submessage_arena) {
      reconcilerstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reconcilerstate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reconcilerstate_ = reconcilerstate;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus.reconcilerState)
}

// -------------------------------------------------------------------

// ContrailFqName

// repeated string fqName = 1;
inline int ContrailFqName::_internal_fqname_size() const {
  return fqname_.size();
}
inline int ContrailFqName::fqname_size() const {
  return _internal_fqname_size();
}
inline void ContrailFqName::clear_fqname() {
  fqname_.Clear();
}
inline std::string* ContrailFqName::add_fqname() {
  std::string* _s = _internal_add_fqname();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
  return _s;
}
inline const std::string& ContrailFqName::_internal_fqname(int index) const {
  return fqname_.Get(index);
}
inline const std::string& ContrailFqName::fqname(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
  return _internal_fqname(index);
}
inline std::string* ContrailFqName::mutable_fqname(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
  return fqname_.Mutable(index);
}
inline void ContrailFqName::set_fqname(int index, const std::string& value) {
  fqname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
}
inline void ContrailFqName::set_fqname(int index, std::string&& value) {
  fqname_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
}
inline void ContrailFqName::set_fqname(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fqname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
}
inline void ContrailFqName::set_fqname(int index, const char* value, size_t size) {
  fqname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
}
inline std::string* ContrailFqName::_internal_add_fqname() {
  return fqname_.Add();
}
inline void ContrailFqName::add_fqname(const std::string& value) {
  fqname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
}
inline void ContrailFqName::add_fqname(std::string&& value) {
  fqname_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
}
inline void ContrailFqName::add_fqname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fqname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
}
inline void ContrailFqName::add_fqname(const char* value, size_t size) {
  fqname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContrailFqName::fqname() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
  return fqname_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContrailFqName::mutable_fqname() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName.fqName)
  return &fqname_;
}

// -------------------------------------------------------------------

// EncapsulationPriorities

// repeated string encapsulation = 1;
inline int EncapsulationPriorities::_internal_encapsulation_size() const {
  return encapsulation_.size();
}
inline int EncapsulationPriorities::encapsulation_size() const {
  return _internal_encapsulation_size();
}
inline void EncapsulationPriorities::clear_encapsulation() {
  encapsulation_.Clear();
}
inline std::string* EncapsulationPriorities::add_encapsulation() {
  std::string* _s = _internal_add_encapsulation();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
  return _s;
}
inline const std::string& EncapsulationPriorities::_internal_encapsulation(int index) const {
  return encapsulation_.Get(index);
}
inline const std::string& EncapsulationPriorities::encapsulation(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
  return _internal_encapsulation(index);
}
inline std::string* EncapsulationPriorities::mutable_encapsulation(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
  return encapsulation_.Mutable(index);
}
inline void EncapsulationPriorities::set_encapsulation(int index, const std::string& value) {
  encapsulation_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
}
inline void EncapsulationPriorities::set_encapsulation(int index, std::string&& value) {
  encapsulation_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
}
inline void EncapsulationPriorities::set_encapsulation(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  encapsulation_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
}
inline void EncapsulationPriorities::set_encapsulation(int index, const char* value, size_t size) {
  encapsulation_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
}
inline std::string* EncapsulationPriorities::_internal_add_encapsulation() {
  return encapsulation_.Add();
}
inline void EncapsulationPriorities::add_encapsulation(const std::string& value) {
  encapsulation_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
}
inline void EncapsulationPriorities::add_encapsulation(std::string&& value) {
  encapsulation_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
}
inline void EncapsulationPriorities::add_encapsulation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  encapsulation_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
}
inline void EncapsulationPriorities::add_encapsulation(const char* value, size_t size) {
  encapsulation_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EncapsulationPriorities::encapsulation() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
  return encapsulation_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EncapsulationPriorities::mutable_encapsulation() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities.encapsulation)
  return &encapsulation_;
}

// -------------------------------------------------------------------

// FirewallActionListType

// optional string simpleAction = 1;
inline bool FirewallActionListType::_internal_has_simpleaction() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FirewallActionListType::has_simpleaction() const {
  return _internal_has_simpleaction();
}
inline void FirewallActionListType::clear_simpleaction() {
  simpleaction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FirewallActionListType::simpleaction() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType.simpleAction)
  return _internal_simpleaction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FirewallActionListType::set_simpleaction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 simpleaction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType.simpleAction)
}
inline std::string* FirewallActionListType::mutable_simpleaction() {
  std::string* _s = _internal_mutable_simpleaction();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType.simpleAction)
  return _s;
}
inline const std::string& FirewallActionListType::_internal_simpleaction() const {
  return simpleaction_.Get();
}
inline void FirewallActionListType::_internal_set_simpleaction(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  simpleaction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FirewallActionListType::_internal_mutable_simpleaction() {
  _has_bits_[0] |= 0x00000001u;
  return simpleaction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FirewallActionListType::release_simpleaction() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType.simpleAction)
  if (!_internal_has_simpleaction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return simpleaction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FirewallActionListType::set_allocated_simpleaction(std::string* simpleaction) {
  if (simpleaction != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  simpleaction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), simpleaction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType.simpleAction)
}

// -------------------------------------------------------------------

// FirewallPolicy

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool FirewallPolicy::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool FirewallPolicy::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& FirewallPolicy::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& FirewallPolicy::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.metadata)
  return _internal_metadata();
}
inline void FirewallPolicy::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FirewallPolicy::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FirewallPolicy::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FirewallPolicy::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FirewallPolicy::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.metadata)
  return _msg;
}
inline void FirewallPolicy::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec spec = 2;
inline bool FirewallPolicy::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool FirewallPolicy::has_spec() const {
  return _internal_has_spec();
}
inline void FirewallPolicy::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec& FirewallPolicy::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallPolicySpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec& FirewallPolicy::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.spec)
  return _internal_spec();
}
inline void FirewallPolicy::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* FirewallPolicy::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* FirewallPolicy::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* FirewallPolicy::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* FirewallPolicy::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.spec)
  return _msg;
}
inline void FirewallPolicy::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicySpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus status = 3;
inline bool FirewallPolicy::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool FirewallPolicy::has_status() const {
  return _internal_has_status();
}
inline void FirewallPolicy::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus& FirewallPolicy::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallPolicyStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus& FirewallPolicy::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.status)
  return _internal_status();
}
inline void FirewallPolicy::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* FirewallPolicy::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* FirewallPolicy::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* FirewallPolicy::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* FirewallPolicy::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.status)
  return _msg;
}
inline void FirewallPolicy::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy.status)
}

// -------------------------------------------------------------------

// FirewallPolicyAttribute

// optional string sequence = 1;
inline bool FirewallPolicyAttribute::_internal_has_sequence() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FirewallPolicyAttribute::has_sequence() const {
  return _internal_has_sequence();
}
inline void FirewallPolicyAttribute::clear_sequence() {
  sequence_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FirewallPolicyAttribute::sequence() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute.sequence)
  return _internal_sequence();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FirewallPolicyAttribute::set_sequence(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sequence_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute.sequence)
}
inline std::string* FirewallPolicyAttribute::mutable_sequence() {
  std::string* _s = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute.sequence)
  return _s;
}
inline const std::string& FirewallPolicyAttribute::_internal_sequence() const {
  return sequence_.Get();
}
inline void FirewallPolicyAttribute::_internal_set_sequence(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sequence_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FirewallPolicyAttribute::_internal_mutable_sequence() {
  _has_bits_[0] |= 0x00000001u;
  return sequence_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FirewallPolicyAttribute::release_sequence() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute.sequence)
  if (!_internal_has_sequence()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sequence_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FirewallPolicyAttribute::set_allocated_sequence(std::string* sequence) {
  if (sequence != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sequence_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sequence,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute.sequence)
}

// -------------------------------------------------------------------

// FirewallPolicyList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool FirewallPolicyList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool FirewallPolicyList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& FirewallPolicyList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& FirewallPolicyList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.metadata)
  return _internal_metadata();
}
inline void FirewallPolicyList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FirewallPolicyList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FirewallPolicyList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FirewallPolicyList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FirewallPolicyList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.metadata)
  return _msg;
}
inline void FirewallPolicyList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy items = 2;
inline int FirewallPolicyList::_internal_items_size() const {
  return items_.size();
}
inline int FirewallPolicyList::items_size() const {
  return _internal_items_size();
}
inline void FirewallPolicyList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy* FirewallPolicyList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy >*
FirewallPolicyList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy& FirewallPolicyList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy& FirewallPolicyList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy* FirewallPolicyList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy* FirewallPolicyList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicy >&
FirewallPolicyList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyList.items)
  return items_;
}

// -------------------------------------------------------------------

// FirewallPolicyReference

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
inline bool FirewallPolicyReference::_internal_has_resourcereference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || resourcereference_ != nullptr);
  return value;
}
inline bool FirewallPolicyReference::has_resourcereference() const {
  return _internal_has_resourcereference();
}
inline void FirewallPolicyReference::clear_resourcereference() {
  if (resourcereference_ != nullptr) resourcereference_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FirewallPolicyReference::_internal_resourcereference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = resourcereference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FirewallPolicyReference::resourcereference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.resourceReference)
  return _internal_resourcereference();
}
inline void FirewallPolicyReference::unsafe_arena_set_allocated_resourcereference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resourcereference_);
  }
  resourcereference_ = resourcereference;
  if (resourcereference) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.resourceReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallPolicyReference::release_resourcereference() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallPolicyReference::unsafe_arena_release_resourcereference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.resourceReference)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallPolicyReference::_internal_mutable_resourcereference() {
  _has_bits_[0] |= 0x00000001u;
  if (resourcereference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    resourcereference_ = p;
  }
  return resourcereference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallPolicyReference::mutable_resourcereference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_resourcereference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.resourceReference)
  return _msg;
}
inline void FirewallPolicyReference::set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resourcereference_;
  }
  if (resourcereference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(resourcereference);
    if (message_arena != submessage_arena) {
      resourcereference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resourcereference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resourcereference_ = resourcereference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.resourceReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute attributes = 2;
inline bool FirewallPolicyReference::_internal_has_attributes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || attributes_ != nullptr);
  return value;
}
inline bool FirewallPolicyReference::has_attributes() const {
  return _internal_has_attributes();
}
inline void FirewallPolicyReference::clear_attributes() {
  if (attributes_ != nullptr) attributes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute& FirewallPolicyReference::_internal_attributes() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_APSAttribute_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute& FirewallPolicyReference::attributes() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.attributes)
  return _internal_attributes();
}
inline void FirewallPolicyReference::unsafe_arena_set_allocated_attributes(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.attributes)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* FirewallPolicyReference::release_attributes() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* FirewallPolicyReference::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.attributes)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* FirewallPolicyReference::_internal_mutable_attributes() {
  _has_bits_[0] |= 0x00000002u;
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* FirewallPolicyReference::mutable_attributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.attributes)
  return _msg;
}
inline void FirewallPolicyReference::set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::APSAttribute>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference.attributes)
}

// -------------------------------------------------------------------

// FirewallPolicySpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool FirewallPolicySpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool FirewallPolicySpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void FirewallPolicySpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& FirewallPolicySpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& FirewallPolicySpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.commonSpec)
  return _internal_commonspec();
}
inline void FirewallPolicySpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FirewallPolicySpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FirewallPolicySpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FirewallPolicySpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FirewallPolicySpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.commonSpec)
  return _msg;
}
inline void FirewallPolicySpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.commonSpec)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference firewallRule = 3;
inline int FirewallPolicySpec::_internal_firewallrule_size() const {
  return firewallrule_.size();
}
inline int FirewallPolicySpec::firewallrule_size() const {
  return _internal_firewallrule_size();
}
inline void FirewallPolicySpec::clear_firewallrule() {
  firewallrule_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference* FirewallPolicySpec::mutable_firewallrule(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.firewallRule)
  return firewallrule_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference >*
FirewallPolicySpec::mutable_firewallrule() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.firewallRule)
  return &firewallrule_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference& FirewallPolicySpec::_internal_firewallrule(int index) const {
  return firewallrule_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference& FirewallPolicySpec::firewallrule(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.firewallRule)
  return _internal_firewallrule(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference* FirewallPolicySpec::_internal_add_firewallrule() {
  return firewallrule_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference* FirewallPolicySpec::add_firewallrule() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference* _add = _internal_add_firewallrule();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.firewallRule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleReference >&
FirewallPolicySpec::firewallrule() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec.firewallRule)
  return firewallrule_;
}

// -------------------------------------------------------------------

// FirewallPolicyStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool FirewallPolicyStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool FirewallPolicyStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void FirewallPolicyStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& FirewallPolicyStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& FirewallPolicyStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus.commonStatus)
  return _internal_commonstatus();
}
inline void FirewallPolicyStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FirewallPolicyStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FirewallPolicyStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FirewallPolicyStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FirewallPolicyStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus.commonStatus)
  return _msg;
}
inline void FirewallPolicyStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus.commonStatus)
}

// -------------------------------------------------------------------

// FirewallRule

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool FirewallRule::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool FirewallRule::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& FirewallRule::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& FirewallRule::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.metadata)
  return _internal_metadata();
}
inline void FirewallRule::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FirewallRule::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FirewallRule::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FirewallRule::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FirewallRule::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.metadata)
  return _msg;
}
inline void FirewallRule::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec spec = 2;
inline bool FirewallRule::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool FirewallRule::has_spec() const {
  return _internal_has_spec();
}
inline void FirewallRule::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec& FirewallRule::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallRuleSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec& FirewallRule::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.spec)
  return _internal_spec();
}
inline void FirewallRule::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* FirewallRule::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* FirewallRule::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* FirewallRule::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* FirewallRule::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.spec)
  return _msg;
}
inline void FirewallRule::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus status = 3;
inline bool FirewallRule::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool FirewallRule::has_status() const {
  return _internal_has_status();
}
inline void FirewallRule::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus& FirewallRule::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallRuleStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus& FirewallRule::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.status)
  return _internal_status();
}
inline void FirewallRule::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* FirewallRule::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* FirewallRule::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* FirewallRule::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* FirewallRule::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.status)
  return _msg;
}
inline void FirewallRule::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule.status)
}

// -------------------------------------------------------------------

// FirewallRuleEndpointType

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet subnet = 1;
inline bool FirewallRuleEndpointType::_internal_has_subnet() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || subnet_ != nullptr);
  return value;
}
inline bool FirewallRuleEndpointType::has_subnet() const {
  return _internal_has_subnet();
}
inline void FirewallRuleEndpointType::clear_subnet() {
  if (subnet_ != nullptr) subnet_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet& FirewallRuleEndpointType::_internal_subnet() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* p = subnet_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallSubnet_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet& FirewallRuleEndpointType::subnet() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.subnet)
  return _internal_subnet();
}
inline void FirewallRuleEndpointType::unsafe_arena_set_allocated_subnet(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* subnet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnet_);
  }
  subnet_ = subnet;
  if (subnet) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.subnet)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* FirewallRuleEndpointType::release_subnet() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* temp = subnet_;
  subnet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* FirewallRuleEndpointType::unsafe_arena_release_subnet() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.subnet)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* temp = subnet_;
  subnet_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* FirewallRuleEndpointType::_internal_mutable_subnet() {
  _has_bits_[0] |= 0x00000002u;
  if (subnet_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet>(GetArenaForAllocation());
    subnet_ = p;
  }
  return subnet_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* FirewallRuleEndpointType::mutable_subnet() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* _msg = _internal_mutable_subnet();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.subnet)
  return _msg;
}
inline void FirewallRuleEndpointType::set_allocated_subnet(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet* subnet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subnet_;
  }
  if (subnet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallSubnet>::GetOwningArena(subnet);
    if (message_arena != submessage_arena) {
      subnet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subnet, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  subnet_ = subnet;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.subnet)
}

// optional string addressGroup = 3;
inline bool FirewallRuleEndpointType::_internal_has_addressgroup() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FirewallRuleEndpointType::has_addressgroup() const {
  return _internal_has_addressgroup();
}
inline void FirewallRuleEndpointType::clear_addressgroup() {
  addressgroup_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FirewallRuleEndpointType::addressgroup() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.addressGroup)
  return _internal_addressgroup();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FirewallRuleEndpointType::set_addressgroup(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 addressgroup_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.addressGroup)
}
inline std::string* FirewallRuleEndpointType::mutable_addressgroup() {
  std::string* _s = _internal_mutable_addressgroup();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.addressGroup)
  return _s;
}
inline const std::string& FirewallRuleEndpointType::_internal_addressgroup() const {
  return addressgroup_.Get();
}
inline void FirewallRuleEndpointType::_internal_set_addressgroup(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  addressgroup_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FirewallRuleEndpointType::_internal_mutable_addressgroup() {
  _has_bits_[0] |= 0x00000001u;
  return addressgroup_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FirewallRuleEndpointType::release_addressgroup() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.addressGroup)
  if (!_internal_has_addressgroup()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return addressgroup_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FirewallRuleEndpointType::set_allocated_addressgroup(std::string* addressgroup) {
  if (addressgroup != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  addressgroup_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addressgroup,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.addressGroup)
}

// repeated string tags = 4;
inline int FirewallRuleEndpointType::_internal_tags_size() const {
  return tags_.size();
}
inline int FirewallRuleEndpointType::tags_size() const {
  return _internal_tags_size();
}
inline void FirewallRuleEndpointType::clear_tags() {
  tags_.Clear();
}
inline std::string* FirewallRuleEndpointType::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
  return _s;
}
inline const std::string& FirewallRuleEndpointType::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& FirewallRuleEndpointType::tags(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
  return _internal_tags(index);
}
inline std::string* FirewallRuleEndpointType::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
  return tags_.Mutable(index);
}
inline void FirewallRuleEndpointType::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
}
inline void FirewallRuleEndpointType::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
}
inline void FirewallRuleEndpointType::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
}
inline void FirewallRuleEndpointType::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
}
inline std::string* FirewallRuleEndpointType::_internal_add_tags() {
  return tags_.Add();
}
inline void FirewallRuleEndpointType::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
}
inline void FirewallRuleEndpointType::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
}
inline void FirewallRuleEndpointType::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
}
inline void FirewallRuleEndpointType::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FirewallRuleEndpointType::tags() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FirewallRuleEndpointType::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tags)
  return &tags_;
}

// repeated int64 tagIds = 5;
inline int FirewallRuleEndpointType::_internal_tagids_size() const {
  return tagids_.size();
}
inline int FirewallRuleEndpointType::tagids_size() const {
  return _internal_tagids_size();
}
inline void FirewallRuleEndpointType::clear_tagids() {
  tagids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FirewallRuleEndpointType::_internal_tagids(int index) const {
  return tagids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FirewallRuleEndpointType::tagids(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tagIds)
  return _internal_tagids(index);
}
inline void FirewallRuleEndpointType::set_tagids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  tagids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tagIds)
}
inline void FirewallRuleEndpointType::_internal_add_tagids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  tagids_.Add(value);
}
inline void FirewallRuleEndpointType::add_tagids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_tagids(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tagIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
FirewallRuleEndpointType::_internal_tagids() const {
  return tagids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
FirewallRuleEndpointType::tagids() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tagIds)
  return _internal_tagids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
FirewallRuleEndpointType::_internal_mutable_tagids() {
  return &tagids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
FirewallRuleEndpointType::mutable_tagids() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.tagIds)
  return _internal_mutable_tagids();
}

// optional bool any = 6;
inline bool FirewallRuleEndpointType::_internal_has_any() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FirewallRuleEndpointType::has_any() const {
  return _internal_has_any();
}
inline void FirewallRuleEndpointType::clear_any() {
  any_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool FirewallRuleEndpointType::_internal_any() const {
  return any_;
}
inline bool FirewallRuleEndpointType::any() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.any)
  return _internal_any();
}
inline void FirewallRuleEndpointType::_internal_set_any(bool value) {
  _has_bits_[0] |= 0x00000004u;
  any_ = value;
}
inline void FirewallRuleEndpointType::set_any(bool value) {
  _internal_set_any(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType.any)
}

// -------------------------------------------------------------------

// FirewallRuleList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool FirewallRuleList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool FirewallRuleList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& FirewallRuleList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& FirewallRuleList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.metadata)
  return _internal_metadata();
}
inline void FirewallRuleList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FirewallRuleList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FirewallRuleList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FirewallRuleList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FirewallRuleList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.metadata)
  return _msg;
}
inline void FirewallRuleList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule items = 2;
inline int FirewallRuleList::_internal_items_size() const {
  return items_.size();
}
inline int FirewallRuleList::items_size() const {
  return _internal_items_size();
}
inline void FirewallRuleList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule* FirewallRuleList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule >*
FirewallRuleList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule& FirewallRuleList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule& FirewallRuleList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule* FirewallRuleList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule* FirewallRuleList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRule >&
FirewallRuleList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleList.items)
  return items_;
}

// -------------------------------------------------------------------

// FirewallRuleReference

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
inline bool FirewallRuleReference::_internal_has_resourcereference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || resourcereference_ != nullptr);
  return value;
}
inline bool FirewallRuleReference::has_resourcereference() const {
  return _internal_has_resourcereference();
}
inline void FirewallRuleReference::clear_resourcereference() {
  if (resourcereference_ != nullptr) resourcereference_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FirewallRuleReference::_internal_resourcereference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = resourcereference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FirewallRuleReference::resourcereference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.resourceReference)
  return _internal_resourcereference();
}
inline void FirewallRuleReference::unsafe_arena_set_allocated_resourcereference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resourcereference_);
  }
  resourcereference_ = resourcereference;
  if (resourcereference) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.resourceReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleReference::release_resourcereference() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleReference::unsafe_arena_release_resourcereference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.resourceReference)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleReference::_internal_mutable_resourcereference() {
  _has_bits_[0] |= 0x00000001u;
  if (resourcereference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    resourcereference_ = p;
  }
  return resourcereference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleReference::mutable_resourcereference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_resourcereference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.resourceReference)
  return _msg;
}
inline void FirewallRuleReference::set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resourcereference_;
  }
  if (resourcereference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(resourcereference);
    if (message_arena != submessage_arena) {
      resourcereference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resourcereference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resourcereference_ = resourcereference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.resourceReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute attributes = 2;
inline bool FirewallRuleReference::_internal_has_attributes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || attributes_ != nullptr);
  return value;
}
inline bool FirewallRuleReference::has_attributes() const {
  return _internal_has_attributes();
}
inline void FirewallRuleReference::clear_attributes() {
  if (attributes_ != nullptr) attributes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute& FirewallRuleReference::_internal_attributes() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallPolicyAttribute_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute& FirewallRuleReference::attributes() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.attributes)
  return _internal_attributes();
}
inline void FirewallRuleReference::unsafe_arena_set_allocated_attributes(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.attributes)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* FirewallRuleReference::release_attributes() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* FirewallRuleReference::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.attributes)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* FirewallRuleReference::_internal_mutable_attributes() {
  _has_bits_[0] |= 0x00000002u;
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* FirewallRuleReference::mutable_attributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.attributes)
  return _msg;
}
inline void FirewallRuleReference::set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallPolicyAttribute>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference.attributes)
}

// -------------------------------------------------------------------

// FirewallRuleSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool FirewallRuleSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool FirewallRuleSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void FirewallRuleSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& FirewallRuleSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& FirewallRuleSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.commonSpec)
  return _internal_commonspec();
}
inline void FirewallRuleSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FirewallRuleSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FirewallRuleSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.commonSpec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FirewallRuleSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000002u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FirewallRuleSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.commonSpec)
  return _msg;
}
inline void FirewallRuleSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.commonSpec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference addressGroupReference = 2;
inline bool FirewallRuleSpec::_internal_has_addressgroupreference() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || addressgroupreference_ != nullptr);
  return value;
}
inline bool FirewallRuleSpec::has_addressgroupreference() const {
  return _internal_has_addressgroupreference();
}
inline void FirewallRuleSpec::clear_addressgroupreference() {
  if (addressgroupreference_ != nullptr) addressgroupreference_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FirewallRuleSpec::_internal_addressgroupreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = addressgroupreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FirewallRuleSpec::addressgroupreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.addressGroupReference)
  return _internal_addressgroupreference();
}
inline void FirewallRuleSpec::unsafe_arena_set_allocated_addressgroupreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* addressgroupreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addressgroupreference_);
  }
  addressgroupreference_ = addressgroupreference;
  if (addressgroupreference) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.addressGroupReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleSpec::release_addressgroupreference() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = addressgroupreference_;
  addressgroupreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleSpec::unsafe_arena_release_addressgroupreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.addressGroupReference)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = addressgroupreference_;
  addressgroupreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleSpec::_internal_mutable_addressgroupreference() {
  _has_bits_[0] |= 0x00000004u;
  if (addressgroupreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    addressgroupreference_ = p;
  }
  return addressgroupreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleSpec::mutable_addressgroupreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_addressgroupreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.addressGroupReference)
  return _msg;
}
inline void FirewallRuleSpec::set_allocated_addressgroupreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* addressgroupreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addressgroupreference_;
  }
  if (addressgroupreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(addressgroupreference);
    if (message_arena != submessage_arena) {
      addressgroupreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addressgroupreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  addressgroupreference_ = addressgroupreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.addressGroupReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType actionList = 3;
inline bool FirewallRuleSpec::_internal_has_actionlist() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || actionlist_ != nullptr);
  return value;
}
inline bool FirewallRuleSpec::has_actionlist() const {
  return _internal_has_actionlist();
}
inline void FirewallRuleSpec::clear_actionlist() {
  if (actionlist_ != nullptr) actionlist_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType& FirewallRuleSpec::_internal_actionlist() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* p = actionlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallActionListType_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType& FirewallRuleSpec::actionlist() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.actionList)
  return _internal_actionlist();
}
inline void FirewallRuleSpec::unsafe_arena_set_allocated_actionlist(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* actionlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actionlist_);
  }
  actionlist_ = actionlist;
  if (actionlist) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.actionList)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* FirewallRuleSpec::release_actionlist() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* temp = actionlist_;
  actionlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* FirewallRuleSpec::unsafe_arena_release_actionlist() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.actionList)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* temp = actionlist_;
  actionlist_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* FirewallRuleSpec::_internal_mutable_actionlist() {
  _has_bits_[0] |= 0x00000008u;
  if (actionlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType>(GetArenaForAllocation());
    actionlist_ = p;
  }
  return actionlist_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* FirewallRuleSpec::mutable_actionlist() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* _msg = _internal_mutable_actionlist();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.actionList)
  return _msg;
}
inline void FirewallRuleSpec::set_allocated_actionlist(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType* actionlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete actionlist_;
  }
  if (actionlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallActionListType>::GetOwningArena(actionlist);
    if (message_arena != submessage_arena) {
      actionlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actionlist, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  actionlist_ = actionlist;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.actionList)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType service = 4;
inline bool FirewallRuleSpec::_internal_has_service() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || service_ != nullptr);
  return value;
}
inline bool FirewallRuleSpec::has_service() const {
  return _internal_has_service();
}
inline void FirewallRuleSpec::clear_service() {
  if (service_ != nullptr) service_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType& FirewallRuleSpec::_internal_service() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* p = service_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallServiceType_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType& FirewallRuleSpec::service() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.service)
  return _internal_service();
}
inline void FirewallRuleSpec::unsafe_arena_set_allocated_service(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  service_ = service;
  if (service) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.service)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* FirewallRuleSpec::release_service() {
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* temp = service_;
  service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* FirewallRuleSpec::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.service)
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* temp = service_;
  service_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* FirewallRuleSpec::_internal_mutable_service() {
  _has_bits_[0] |= 0x00000010u;
  if (service_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType>(GetArenaForAllocation());
    service_ = p;
  }
  return service_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* FirewallRuleSpec::mutable_service() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.service)
  return _msg;
}
inline void FirewallRuleSpec::set_allocated_service(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete service_;
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallServiceType>::GetOwningArena(service);
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  service_ = service;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.service)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType Endpoint1 = 5;
inline bool FirewallRuleSpec::_internal_has_endpoint1() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || endpoint1_ != nullptr);
  return value;
}
inline bool FirewallRuleSpec::has_endpoint1() const {
  return _internal_has_endpoint1();
}
inline void FirewallRuleSpec::clear_endpoint1() {
  if (endpoint1_ != nullptr) endpoint1_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType& FirewallRuleSpec::_internal_endpoint1() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* p = endpoint1_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallRuleEndpointType_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType& FirewallRuleSpec::endpoint1() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint1)
  return _internal_endpoint1();
}
inline void FirewallRuleSpec::unsafe_arena_set_allocated_endpoint1(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint1_);
  }
  endpoint1_ = endpoint1;
  if (endpoint1) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint1)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* FirewallRuleSpec::release_endpoint1() {
  _has_bits_[0] &= ~0x00000020u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* temp = endpoint1_;
  endpoint1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* FirewallRuleSpec::unsafe_arena_release_endpoint1() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint1)
  _has_bits_[0] &= ~0x00000020u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* temp = endpoint1_;
  endpoint1_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* FirewallRuleSpec::_internal_mutable_endpoint1() {
  _has_bits_[0] |= 0x00000020u;
  if (endpoint1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType>(GetArenaForAllocation());
    endpoint1_ = p;
  }
  return endpoint1_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* FirewallRuleSpec::mutable_endpoint1() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* _msg = _internal_mutable_endpoint1();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint1)
  return _msg;
}
inline void FirewallRuleSpec::set_allocated_endpoint1(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endpoint1_;
  }
  if (endpoint1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType>::GetOwningArena(endpoint1);
    if (message_arena != submessage_arena) {
      endpoint1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  endpoint1_ = endpoint1;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint1)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType Endpoint2 = 6;
inline bool FirewallRuleSpec::_internal_has_endpoint2() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || endpoint2_ != nullptr);
  return value;
}
inline bool FirewallRuleSpec::has_endpoint2() const {
  return _internal_has_endpoint2();
}
inline void FirewallRuleSpec::clear_endpoint2() {
  if (endpoint2_ != nullptr) endpoint2_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType& FirewallRuleSpec::_internal_endpoint2() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* p = endpoint2_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FirewallRuleEndpointType_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType& FirewallRuleSpec::endpoint2() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint2)
  return _internal_endpoint2();
}
inline void FirewallRuleSpec::unsafe_arena_set_allocated_endpoint2(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint2_);
  }
  endpoint2_ = endpoint2;
  if (endpoint2) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint2)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* FirewallRuleSpec::release_endpoint2() {
  _has_bits_[0] &= ~0x00000040u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* temp = endpoint2_;
  endpoint2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* FirewallRuleSpec::unsafe_arena_release_endpoint2() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint2)
  _has_bits_[0] &= ~0x00000040u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* temp = endpoint2_;
  endpoint2_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* FirewallRuleSpec::_internal_mutable_endpoint2() {
  _has_bits_[0] |= 0x00000040u;
  if (endpoint2_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType>(GetArenaForAllocation());
    endpoint2_ = p;
  }
  return endpoint2_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* FirewallRuleSpec::mutable_endpoint2() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* _msg = _internal_mutable_endpoint2();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint2)
  return _msg;
}
inline void FirewallRuleSpec::set_allocated_endpoint2(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType* endpoint2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endpoint2_;
  }
  if (endpoint2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FirewallRuleEndpointType>::GetOwningArena(endpoint2);
    if (message_arena != submessage_arena) {
      endpoint2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  endpoint2_ = endpoint2;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.Endpoint2)
}

// repeated string matchTags = 7;
inline int FirewallRuleSpec::_internal_matchtags_size() const {
  return matchtags_.size();
}
inline int FirewallRuleSpec::matchtags_size() const {
  return _internal_matchtags_size();
}
inline void FirewallRuleSpec::clear_matchtags() {
  matchtags_.Clear();
}
inline std::string* FirewallRuleSpec::add_matchtags() {
  std::string* _s = _internal_add_matchtags();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
  return _s;
}
inline const std::string& FirewallRuleSpec::_internal_matchtags(int index) const {
  return matchtags_.Get(index);
}
inline const std::string& FirewallRuleSpec::matchtags(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
  return _internal_matchtags(index);
}
inline std::string* FirewallRuleSpec::mutable_matchtags(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
  return matchtags_.Mutable(index);
}
inline void FirewallRuleSpec::set_matchtags(int index, const std::string& value) {
  matchtags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
}
inline void FirewallRuleSpec::set_matchtags(int index, std::string&& value) {
  matchtags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
}
inline void FirewallRuleSpec::set_matchtags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  matchtags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
}
inline void FirewallRuleSpec::set_matchtags(int index, const char* value, size_t size) {
  matchtags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
}
inline std::string* FirewallRuleSpec::_internal_add_matchtags() {
  return matchtags_.Add();
}
inline void FirewallRuleSpec::add_matchtags(const std::string& value) {
  matchtags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
}
inline void FirewallRuleSpec::add_matchtags(std::string&& value) {
  matchtags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
}
inline void FirewallRuleSpec::add_matchtags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  matchtags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
}
inline void FirewallRuleSpec::add_matchtags(const char* value, size_t size) {
  matchtags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FirewallRuleSpec::matchtags() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
  return matchtags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FirewallRuleSpec::mutable_matchtags() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTags)
  return &matchtags_;
}

// repeated int64 matchTagsTypes = 8;
inline int FirewallRuleSpec::_internal_matchtagstypes_size() const {
  return matchtagstypes_.size();
}
inline int FirewallRuleSpec::matchtagstypes_size() const {
  return _internal_matchtagstypes_size();
}
inline void FirewallRuleSpec::clear_matchtagstypes() {
  matchtagstypes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FirewallRuleSpec::_internal_matchtagstypes(int index) const {
  return matchtagstypes_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FirewallRuleSpec::matchtagstypes(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTagsTypes)
  return _internal_matchtagstypes(index);
}
inline void FirewallRuleSpec::set_matchtagstypes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  matchtagstypes_.Set(index, value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTagsTypes)
}
inline void FirewallRuleSpec::_internal_add_matchtagstypes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  matchtagstypes_.Add(value);
}
inline void FirewallRuleSpec::add_matchtagstypes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_matchtagstypes(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTagsTypes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
FirewallRuleSpec::_internal_matchtagstypes() const {
  return matchtagstypes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
FirewallRuleSpec::matchtagstypes() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTagsTypes)
  return _internal_matchtagstypes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
FirewallRuleSpec::_internal_mutable_matchtagstypes() {
  return &matchtagstypes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
FirewallRuleSpec::mutable_matchtagstypes() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.matchTagsTypes)
  return _internal_mutable_matchtagstypes();
}

// optional string direction = 9;
inline bool FirewallRuleSpec::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FirewallRuleSpec::has_direction() const {
  return _internal_has_direction();
}
inline void FirewallRuleSpec::clear_direction() {
  direction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FirewallRuleSpec::direction() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.direction)
  return _internal_direction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FirewallRuleSpec::set_direction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 direction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.direction)
}
inline std::string* FirewallRuleSpec::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.direction)
  return _s;
}
inline const std::string& FirewallRuleSpec::_internal_direction() const {
  return direction_.Get();
}
inline void FirewallRuleSpec::_internal_set_direction(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  direction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FirewallRuleSpec::_internal_mutable_direction() {
  _has_bits_[0] |= 0x00000001u;
  return direction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FirewallRuleSpec::release_direction() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.direction)
  if (!_internal_has_direction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return direction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FirewallRuleSpec::set_allocated_direction(std::string* direction) {
  if (direction != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  direction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), direction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.direction)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 10;
inline int FirewallRuleSpec::_internal_tagreferences_size() const {
  return tagreferences_.size();
}
inline int FirewallRuleSpec::tagreferences_size() const {
  return _internal_tagreferences_size();
}
inline void FirewallRuleSpec::clear_tagreferences() {
  tagreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleSpec::mutable_tagreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.tagReferences)
  return tagreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
FirewallRuleSpec::mutable_tagreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.tagReferences)
  return &tagreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FirewallRuleSpec::_internal_tagreferences(int index) const {
  return tagreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FirewallRuleSpec::tagreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.tagReferences)
  return _internal_tagreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleSpec::_internal_add_tagreferences() {
  return tagreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FirewallRuleSpec::add_tagreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_tagreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.tagReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
FirewallRuleSpec::tagreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec.tagReferences)
  return tagreferences_;
}

// -------------------------------------------------------------------

// FirewallRuleStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool FirewallRuleStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool FirewallRuleStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void FirewallRuleStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& FirewallRuleStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& FirewallRuleStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus.commonStatus)
  return _internal_commonstatus();
}
inline void FirewallRuleStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FirewallRuleStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FirewallRuleStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FirewallRuleStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FirewallRuleStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus.commonStatus)
  return _msg;
}
inline void FirewallRuleStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus.commonStatus)
}

// -------------------------------------------------------------------

// FirewallServiceType

// optional string protocol = 1;
inline bool FirewallServiceType::_internal_has_protocol() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FirewallServiceType::has_protocol() const {
  return _internal_has_protocol();
}
inline void FirewallServiceType::clear_protocol() {
  protocol_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FirewallServiceType::protocol() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FirewallServiceType::set_protocol(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.protocol)
}
inline std::string* FirewallServiceType::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.protocol)
  return _s;
}
inline const std::string& FirewallServiceType::_internal_protocol() const {
  return protocol_.Get();
}
inline void FirewallServiceType::_internal_set_protocol(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FirewallServiceType::_internal_mutable_protocol() {
  _has_bits_[0] |= 0x00000001u;
  return protocol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FirewallServiceType::release_protocol() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.protocol)
  if (!_internal_has_protocol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return protocol_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FirewallServiceType::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.protocol)
}

// optional int64 protocolId = 2;
inline bool FirewallServiceType::_internal_has_protocolid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FirewallServiceType::has_protocolid() const {
  return _internal_has_protocolid();
}
inline void FirewallServiceType::clear_protocolid() {
  protocolid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FirewallServiceType::_internal_protocolid() const {
  return protocolid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FirewallServiceType::protocolid() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.protocolId)
  return _internal_protocolid();
}
inline void FirewallServiceType::_internal_set_protocolid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  protocolid_ = value;
}
inline void FirewallServiceType::set_protocolid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_protocolid(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.protocolId)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType sourcePorts = 3;
inline bool FirewallServiceType::_internal_has_sourceports() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || sourceports_ != nullptr);
  return value;
}
inline bool FirewallServiceType::has_sourceports() const {
  return _internal_has_sourceports();
}
inline void FirewallServiceType::clear_sourceports() {
  if (sourceports_ != nullptr) sourceports_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType& FirewallServiceType::_internal_sourceports() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* p = sourceports_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_PortType_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType& FirewallServiceType::sourceports() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.sourcePorts)
  return _internal_sourceports();
}
inline void FirewallServiceType::unsafe_arena_set_allocated_sourceports(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* sourceports) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sourceports_);
  }
  sourceports_ = sourceports;
  if (sourceports) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.sourcePorts)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* FirewallServiceType::release_sourceports() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* temp = sourceports_;
  sourceports_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* FirewallServiceType::unsafe_arena_release_sourceports() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.sourcePorts)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* temp = sourceports_;
  sourceports_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* FirewallServiceType::_internal_mutable_sourceports() {
  _has_bits_[0] |= 0x00000002u;
  if (sourceports_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType>(GetArenaForAllocation());
    sourceports_ = p;
  }
  return sourceports_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* FirewallServiceType::mutable_sourceports() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* _msg = _internal_mutable_sourceports();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.sourcePorts)
  return _msg;
}
inline void FirewallServiceType::set_allocated_sourceports(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* sourceports) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sourceports_;
  }
  if (sourceports) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType>::GetOwningArena(sourceports);
    if (message_arena != submessage_arena) {
      sourceports = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sourceports, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sourceports_ = sourceports;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.sourcePorts)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType destinationPorts = 4;
inline bool FirewallServiceType::_internal_has_destinationports() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || destinationports_ != nullptr);
  return value;
}
inline bool FirewallServiceType::has_destinationports() const {
  return _internal_has_destinationports();
}
inline void FirewallServiceType::clear_destinationports() {
  if (destinationports_ != nullptr) destinationports_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType& FirewallServiceType::_internal_destinationports() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* p = destinationports_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_PortType_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType& FirewallServiceType::destinationports() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.destinationPorts)
  return _internal_destinationports();
}
inline void FirewallServiceType::unsafe_arena_set_allocated_destinationports(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* destinationports) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destinationports_);
  }
  destinationports_ = destinationports;
  if (destinationports) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.destinationPorts)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* FirewallServiceType::release_destinationports() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* temp = destinationports_;
  destinationports_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* FirewallServiceType::unsafe_arena_release_destinationports() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.destinationPorts)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* temp = destinationports_;
  destinationports_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* FirewallServiceType::_internal_mutable_destinationports() {
  _has_bits_[0] |= 0x00000004u;
  if (destinationports_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType>(GetArenaForAllocation());
    destinationports_ = p;
  }
  return destinationports_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* FirewallServiceType::mutable_destinationports() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* _msg = _internal_mutable_destinationports();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.destinationPorts)
  return _msg;
}
inline void FirewallServiceType::set_allocated_destinationports(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType* destinationports) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete destinationports_;
  }
  if (destinationports) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortType>::GetOwningArena(destinationports);
    if (message_arena != submessage_arena) {
      destinationports = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destinationports, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  destinationports_ = destinationports;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType.destinationPorts)
}

// -------------------------------------------------------------------

// FirewallSubnet

// optional string ipPrefix = 1;
inline bool FirewallSubnet::_internal_has_ipprefix() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FirewallSubnet::has_ipprefix() const {
  return _internal_has_ipprefix();
}
inline void FirewallSubnet::clear_ipprefix() {
  ipprefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FirewallSubnet::ipprefix() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefix)
  return _internal_ipprefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FirewallSubnet::set_ipprefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ipprefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefix)
}
inline std::string* FirewallSubnet::mutable_ipprefix() {
  std::string* _s = _internal_mutable_ipprefix();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefix)
  return _s;
}
inline const std::string& FirewallSubnet::_internal_ipprefix() const {
  return ipprefix_.Get();
}
inline void FirewallSubnet::_internal_set_ipprefix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ipprefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FirewallSubnet::_internal_mutable_ipprefix() {
  _has_bits_[0] |= 0x00000001u;
  return ipprefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FirewallSubnet::release_ipprefix() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefix)
  if (!_internal_has_ipprefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ipprefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FirewallSubnet::set_allocated_ipprefix(std::string* ipprefix) {
  if (ipprefix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ipprefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipprefix,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefix)
}

// optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString ipPrefixLen = 2;
inline bool FirewallSubnet::_internal_has_ipprefixlen() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || ipprefixlen_ != nullptr);
  return value;
}
inline bool FirewallSubnet::has_ipprefixlen() const {
  return _internal_has_ipprefixlen();
}
inline const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& FirewallSubnet::_internal_ipprefixlen() const {
  const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* p = ipprefixlen_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString&>(
      ::k8s::io::apimachinery::pkg::util::intstr::_IntOrString_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& FirewallSubnet::ipprefixlen() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefixLen)
  return _internal_ipprefixlen();
}
inline void FirewallSubnet::unsafe_arena_set_allocated_ipprefixlen(
    ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipprefixlen_);
  }
  ipprefixlen_ = ipprefixlen;
  if (ipprefixlen) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefixLen)
}
inline ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* FirewallSubnet::release_ipprefixlen() {
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* temp = ipprefixlen_;
  ipprefixlen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* FirewallSubnet::unsafe_arena_release_ipprefixlen() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefixLen)
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* temp = ipprefixlen_;
  ipprefixlen_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* FirewallSubnet::_internal_mutable_ipprefixlen() {
  _has_bits_[0] |= 0x00000002u;
  if (ipprefixlen_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::util::intstr::IntOrString>(GetArenaForAllocation());
    ipprefixlen_ = p;
  }
  return ipprefixlen_;
}
inline ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* FirewallSubnet::mutable_ipprefixlen() {
  ::k8s::io::apimachinery::pkg::util::intstr::IntOrString* _msg = _internal_mutable_ipprefixlen();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefixLen)
  return _msg;
}
inline void FirewallSubnet::set_allocated_ipprefixlen(::k8s::io::apimachinery::pkg::util::intstr::IntOrString* ipprefixlen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipprefixlen_);
  }
  if (ipprefixlen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ipprefixlen));
    if (message_arena != submessage_arena) {
      ipprefixlen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipprefixlen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ipprefixlen_ = ipprefixlen;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet.ipPrefixLen)
}

// -------------------------------------------------------------------

// FloatingIP

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool FloatingIP::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool FloatingIP::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& FloatingIP::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& FloatingIP::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.metadata)
  return _internal_metadata();
}
inline void FloatingIP::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FloatingIP::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FloatingIP::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FloatingIP::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* FloatingIP::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.metadata)
  return _msg;
}
inline void FloatingIP::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec spec = 2;
inline bool FloatingIP::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool FloatingIP::has_spec() const {
  return _internal_has_spec();
}
inline void FloatingIP::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec& FloatingIP::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FloatingIPSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec& FloatingIP::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.spec)
  return _internal_spec();
}
inline void FloatingIP::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* FloatingIP::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* FloatingIP::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* FloatingIP::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* FloatingIP::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.spec)
  return _msg;
}
inline void FloatingIP::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus status = 3;
inline bool FloatingIP::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool FloatingIP::has_status() const {
  return _internal_has_status();
}
inline void FloatingIP::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus& FloatingIP::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FloatingIPStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus& FloatingIP::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.status)
  return _internal_status();
}
inline void FloatingIP::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* FloatingIP::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* FloatingIP::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* FloatingIP::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* FloatingIP::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.status)
  return _msg;
}
inline void FloatingIP::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP.status)
}

// -------------------------------------------------------------------

// FloatingIPList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool FloatingIPList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool FloatingIPList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& FloatingIPList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& FloatingIPList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.metadata)
  return _internal_metadata();
}
inline void FloatingIPList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FloatingIPList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FloatingIPList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FloatingIPList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* FloatingIPList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.metadata)
  return _msg;
}
inline void FloatingIPList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP items = 2;
inline int FloatingIPList::_internal_items_size() const {
  return items_.size();
}
inline int FloatingIPList::items_size() const {
  return _internal_items_size();
}
inline void FloatingIPList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP* FloatingIPList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP >*
FloatingIPList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP& FloatingIPList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP& FloatingIPList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP* FloatingIPList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP* FloatingIPList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIP >&
FloatingIPList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPList.items)
  return items_;
}

// -------------------------------------------------------------------

// FloatingIPPortMappings

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping portMappings = 1;
inline int FloatingIPPortMappings::_internal_portmappings_size() const {
  return portmappings_.size();
}
inline int FloatingIPPortMappings::portmappings_size() const {
  return _internal_portmappings_size();
}
inline void FloatingIPPortMappings::clear_portmappings() {
  portmappings_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping* FloatingIPPortMappings::mutable_portmappings(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings.portMappings)
  return portmappings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping >*
FloatingIPPortMappings::mutable_portmappings() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings.portMappings)
  return &portmappings_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping& FloatingIPPortMappings::_internal_portmappings(int index) const {
  return portmappings_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping& FloatingIPPortMappings::portmappings(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings.portMappings)
  return _internal_portmappings(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping* FloatingIPPortMappings::_internal_add_portmappings() {
  return portmappings_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping* FloatingIPPortMappings::add_portmappings() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping* _add = _internal_add_portmappings();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings.portMappings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortPortMapping >&
FloatingIPPortMappings::portmappings() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings.portMappings)
  return portmappings_;
}

// -------------------------------------------------------------------

// FloatingIPPortPortMapping

// optional int32 srcPort = 1;
inline bool FloatingIPPortPortMapping::_internal_has_srcport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FloatingIPPortPortMapping::has_srcport() const {
  return _internal_has_srcport();
}
inline void FloatingIPPortPortMapping::clear_srcport() {
  srcport_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FloatingIPPortPortMapping::_internal_srcport() const {
  return srcport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FloatingIPPortPortMapping::srcport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.srcPort)
  return _internal_srcport();
}
inline void FloatingIPPortPortMapping::_internal_set_srcport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  srcport_ = value;
}
inline void FloatingIPPortPortMapping::set_srcport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_srcport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.srcPort)
}

// optional int32 dstPort = 2;
inline bool FloatingIPPortPortMapping::_internal_has_dstport() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FloatingIPPortPortMapping::has_dstport() const {
  return _internal_has_dstport();
}
inline void FloatingIPPortPortMapping::clear_dstport() {
  dstport_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FloatingIPPortPortMapping::_internal_dstport() const {
  return dstport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FloatingIPPortPortMapping::dstport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.dstPort)
  return _internal_dstport();
}
inline void FloatingIPPortPortMapping::_internal_set_dstport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  dstport_ = value;
}
inline void FloatingIPPortPortMapping::set_dstport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dstport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.dstPort)
}

// optional string protocol = 3;
inline bool FloatingIPPortPortMapping::_internal_has_protocol() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FloatingIPPortPortMapping::has_protocol() const {
  return _internal_has_protocol();
}
inline void FloatingIPPortPortMapping::clear_protocol() {
  protocol_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FloatingIPPortPortMapping::protocol() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FloatingIPPortPortMapping::set_protocol(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.protocol)
}
inline std::string* FloatingIPPortPortMapping::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.protocol)
  return _s;
}
inline const std::string& FloatingIPPortPortMapping::_internal_protocol() const {
  return protocol_.Get();
}
inline void FloatingIPPortPortMapping::_internal_set_protocol(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FloatingIPPortPortMapping::_internal_mutable_protocol() {
  _has_bits_[0] |= 0x00000001u;
  return protocol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FloatingIPPortPortMapping::release_protocol() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.protocol)
  if (!_internal_has_protocol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return protocol_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FloatingIPPortPortMapping::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping.protocol)
}

// -------------------------------------------------------------------

// FloatingIPSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool FloatingIPSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool FloatingIPSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void FloatingIPSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& FloatingIPSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& FloatingIPSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.commonSpec)
  return _internal_commonspec();
}
inline void FloatingIPSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FloatingIPSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FloatingIPSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.commonSpec)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FloatingIPSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000004u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* FloatingIPSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.commonSpec)
  return _msg;
}
inline void FloatingIPSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.commonSpec)
}

// optional string floatingIPAddress = 2;
inline bool FloatingIPSpec::_internal_has_floatingipaddress() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FloatingIPSpec::has_floatingipaddress() const {
  return _internal_has_floatingipaddress();
}
inline void FloatingIPSpec::clear_floatingipaddress() {
  floatingipaddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FloatingIPSpec::floatingipaddress() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPAddress)
  return _internal_floatingipaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FloatingIPSpec::set_floatingipaddress(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 floatingipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPAddress)
}
inline std::string* FloatingIPSpec::mutable_floatingipaddress() {
  std::string* _s = _internal_mutable_floatingipaddress();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPAddress)
  return _s;
}
inline const std::string& FloatingIPSpec::_internal_floatingipaddress() const {
  return floatingipaddress_.Get();
}
inline void FloatingIPSpec::_internal_set_floatingipaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  floatingipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FloatingIPSpec::_internal_mutable_floatingipaddress() {
  _has_bits_[0] |= 0x00000001u;
  return floatingipaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FloatingIPSpec::release_floatingipaddress() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPAddress)
  if (!_internal_has_floatingipaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return floatingipaddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FloatingIPSpec::set_allocated_floatingipaddress(std::string* floatingipaddress) {
  if (floatingipaddress != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  floatingipaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), floatingipaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPAddress)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings floatingIPPortMappings = 3;
inline bool FloatingIPSpec::_internal_has_floatingipportmappings() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || floatingipportmappings_ != nullptr);
  return value;
}
inline bool FloatingIPSpec::has_floatingipportmappings() const {
  return _internal_has_floatingipportmappings();
}
inline void FloatingIPSpec::clear_floatingipportmappings() {
  if (floatingipportmappings_ != nullptr) floatingipportmappings_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings& FloatingIPSpec::_internal_floatingipportmappings() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* p = floatingipportmappings_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_FloatingIPPortMappings_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings& FloatingIPSpec::floatingipportmappings() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPPortMappings)
  return _internal_floatingipportmappings();
}
inline void FloatingIPSpec::unsafe_arena_set_allocated_floatingipportmappings(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* floatingipportmappings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(floatingipportmappings_);
  }
  floatingipportmappings_ = floatingipportmappings;
  if (floatingipportmappings) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPPortMappings)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* FloatingIPSpec::release_floatingipportmappings() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* temp = floatingipportmappings_;
  floatingipportmappings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* FloatingIPSpec::unsafe_arena_release_floatingipportmappings() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPPortMappings)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* temp = floatingipportmappings_;
  floatingipportmappings_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* FloatingIPSpec::_internal_mutable_floatingipportmappings() {
  _has_bits_[0] |= 0x00000008u;
  if (floatingipportmappings_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings>(GetArenaForAllocation());
    floatingipportmappings_ = p;
  }
  return floatingipportmappings_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* FloatingIPSpec::mutable_floatingipportmappings() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* _msg = _internal_mutable_floatingipportmappings();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPPortMappings)
  return _msg;
}
inline void FloatingIPSpec::set_allocated_floatingipportmappings(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings* floatingipportmappings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete floatingipportmappings_;
  }
  if (floatingipportmappings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::FloatingIPPortMappings>::GetOwningArena(floatingipportmappings);
    if (message_arena != submessage_arena) {
      floatingipportmappings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, floatingipportmappings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  floatingipportmappings_ = floatingipportmappings;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPPortMappings)
}

// optional string floatingIPTrafficDirection = 4;
inline bool FloatingIPSpec::_internal_has_floatingiptrafficdirection() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FloatingIPSpec::has_floatingiptrafficdirection() const {
  return _internal_has_floatingiptrafficdirection();
}
inline void FloatingIPSpec::clear_floatingiptrafficdirection() {
  floatingiptrafficdirection_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FloatingIPSpec::floatingiptrafficdirection() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPTrafficDirection)
  return _internal_floatingiptrafficdirection();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FloatingIPSpec::set_floatingiptrafficdirection(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 floatingiptrafficdirection_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPTrafficDirection)
}
inline std::string* FloatingIPSpec::mutable_floatingiptrafficdirection() {
  std::string* _s = _internal_mutable_floatingiptrafficdirection();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPTrafficDirection)
  return _s;
}
inline const std::string& FloatingIPSpec::_internal_floatingiptrafficdirection() const {
  return floatingiptrafficdirection_.Get();
}
inline void FloatingIPSpec::_internal_set_floatingiptrafficdirection(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  floatingiptrafficdirection_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FloatingIPSpec::_internal_mutable_floatingiptrafficdirection() {
  _has_bits_[0] |= 0x00000002u;
  return floatingiptrafficdirection_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FloatingIPSpec::release_floatingiptrafficdirection() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPTrafficDirection)
  if (!_internal_has_floatingiptrafficdirection()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return floatingiptrafficdirection_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FloatingIPSpec::set_allocated_floatingiptrafficdirection(std::string* floatingiptrafficdirection) {
  if (floatingiptrafficdirection != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  floatingiptrafficdirection_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), floatingiptrafficdirection,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPTrafficDirection)
}

// optional .k8s.io.api.core.v1.ObjectReference parent = 5;
inline bool FloatingIPSpec::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || parent_ != nullptr);
  return value;
}
inline bool FloatingIPSpec::has_parent() const {
  return _internal_has_parent();
}
inline const ::k8s::io::api::core::v1::ObjectReference& FloatingIPSpec::_internal_parent() const {
  const ::k8s::io::api::core::v1::ObjectReference* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::api::core::v1::ObjectReference&>(
      ::k8s::io::api::core::v1::_ObjectReference_default_instance_);
}
inline const ::k8s::io::api::core::v1::ObjectReference& FloatingIPSpec::parent() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.parent)
  return _internal_parent();
}
inline void FloatingIPSpec::unsafe_arena_set_allocated_parent(
    ::k8s::io::api::core::v1::ObjectReference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.parent)
}
inline ::k8s::io::api::core::v1::ObjectReference* FloatingIPSpec::release_parent() {
  _has_bits_[0] &= ~0x00000010u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* FloatingIPSpec::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.parent)
  _has_bits_[0] &= ~0x00000010u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* FloatingIPSpec::_internal_mutable_parent() {
  _has_bits_[0] |= 0x00000010u;
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::api::core::v1::ObjectReference>(GetArenaForAllocation());
    parent_ = p;
  }
  return parent_;
}
inline ::k8s::io::api::core::v1::ObjectReference* FloatingIPSpec::mutable_parent() {
  ::k8s::io::api::core::v1::ObjectReference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.parent)
  return _msg;
}
inline void FloatingIPSpec::set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent));
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.parent)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 7;
inline int FloatingIPSpec::_internal_virtualmachineinterfacereferences_size() const {
  return virtualmachineinterfacereferences_.size();
}
inline int FloatingIPSpec::virtualmachineinterfacereferences_size() const {
  return _internal_virtualmachineinterfacereferences_size();
}
inline void FloatingIPSpec::clear_virtualmachineinterfacereferences() {
  virtualmachineinterfacereferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FloatingIPSpec::mutable_virtualmachineinterfacereferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.virtualMachineInterfaceReferences)
  return virtualmachineinterfacereferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
FloatingIPSpec::mutable_virtualmachineinterfacereferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.virtualMachineInterfaceReferences)
  return &virtualmachineinterfacereferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FloatingIPSpec::_internal_virtualmachineinterfacereferences(int index) const {
  return virtualmachineinterfacereferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FloatingIPSpec::virtualmachineinterfacereferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.virtualMachineInterfaceReferences)
  return _internal_virtualmachineinterfacereferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FloatingIPSpec::_internal_add_virtualmachineinterfacereferences() {
  return virtualmachineinterfacereferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FloatingIPSpec::add_virtualmachineinterfacereferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_virtualmachineinterfacereferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.virtualMachineInterfaceReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
FloatingIPSpec::virtualmachineinterfacereferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.virtualMachineInterfaceReferences)
  return virtualmachineinterfacereferences_;
}

// optional bool floatingIPPortMappingsEnable = 8;
inline bool FloatingIPSpec::_internal_has_floatingipportmappingsenable() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FloatingIPSpec::has_floatingipportmappingsenable() const {
  return _internal_has_floatingipportmappingsenable();
}
inline void FloatingIPSpec::clear_floatingipportmappingsenable() {
  floatingipportmappingsenable_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool FloatingIPSpec::_internal_floatingipportmappingsenable() const {
  return floatingipportmappingsenable_;
}
inline bool FloatingIPSpec::floatingipportmappingsenable() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPPortMappingsEnable)
  return _internal_floatingipportmappingsenable();
}
inline void FloatingIPSpec::_internal_set_floatingipportmappingsenable(bool value) {
  _has_bits_[0] |= 0x00000020u;
  floatingipportmappingsenable_ = value;
}
inline void FloatingIPSpec::set_floatingipportmappingsenable(bool value) {
  _internal_set_floatingipportmappingsenable(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec.floatingIPPortMappingsEnable)
}

// -------------------------------------------------------------------

// FloatingIPStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool FloatingIPStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool FloatingIPStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void FloatingIPStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& FloatingIPStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& FloatingIPStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.commonStatus)
  return _internal_commonstatus();
}
inline void FloatingIPStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FloatingIPStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FloatingIPStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FloatingIPStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* FloatingIPStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.commonStatus)
  return _msg;
}
inline void FloatingIPStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.commonStatus)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference subnetReference = 2;
inline bool FloatingIPStatus::_internal_has_subnetreference() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || subnetreference_ != nullptr);
  return value;
}
inline bool FloatingIPStatus::has_subnetreference() const {
  return _internal_has_subnetreference();
}
inline void FloatingIPStatus::clear_subnetreference() {
  if (subnetreference_ != nullptr) subnetreference_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FloatingIPStatus::_internal_subnetreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = subnetreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& FloatingIPStatus::subnetreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.subnetReference)
  return _internal_subnetreference();
}
inline void FloatingIPStatus::unsafe_arena_set_allocated_subnetreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnetreference_);
  }
  subnetreference_ = subnetreference;
  if (subnetreference) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.subnetReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FloatingIPStatus::release_subnetreference() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = subnetreference_;
  subnetreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FloatingIPStatus::unsafe_arena_release_subnetreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.subnetReference)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = subnetreference_;
  subnetreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FloatingIPStatus::_internal_mutable_subnetreference() {
  _has_bits_[0] |= 0x00000002u;
  if (subnetreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    subnetreference_ = p;
  }
  return subnetreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* FloatingIPStatus::mutable_subnetreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_subnetreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.subnetReference)
  return _msg;
}
inline void FloatingIPStatus::set_allocated_subnetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subnetreference_;
  }
  if (subnetreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(subnetreference);
    if (message_arena != submessage_arena) {
      subnetreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subnetreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  subnetreference_ = subnetreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus.subnetReference)
}

// -------------------------------------------------------------------

// GlobalSystemConfig

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool GlobalSystemConfig::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool GlobalSystemConfig::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& GlobalSystemConfig::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& GlobalSystemConfig::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.metadata)
  return _internal_metadata();
}
inline void GlobalSystemConfig::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* GlobalSystemConfig::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* GlobalSystemConfig::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* GlobalSystemConfig::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* GlobalSystemConfig::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.metadata)
  return _msg;
}
inline void GlobalSystemConfig::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec spec = 2;
inline bool GlobalSystemConfig::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool GlobalSystemConfig::has_spec() const {
  return _internal_has_spec();
}
inline void GlobalSystemConfig::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec& GlobalSystemConfig::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_GlobalSystemConfigSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec& GlobalSystemConfig::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.spec)
  return _internal_spec();
}
inline void GlobalSystemConfig::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* GlobalSystemConfig::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* GlobalSystemConfig::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* GlobalSystemConfig::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* GlobalSystemConfig::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.spec)
  return _msg;
}
inline void GlobalSystemConfig::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus status = 3;
inline bool GlobalSystemConfig::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool GlobalSystemConfig::has_status() const {
  return _internal_has_status();
}
inline void GlobalSystemConfig::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus& GlobalSystemConfig::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_GlobalSystemConfigStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus& GlobalSystemConfig::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.status)
  return _internal_status();
}
inline void GlobalSystemConfig::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* GlobalSystemConfig::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* GlobalSystemConfig::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* GlobalSystemConfig::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* GlobalSystemConfig::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.status)
  return _msg;
}
inline void GlobalSystemConfig::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfigStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig.status)
}

// -------------------------------------------------------------------

// GlobalSystemConfigList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool GlobalSystemConfigList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool GlobalSystemConfigList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& GlobalSystemConfigList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& GlobalSystemConfigList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.metadata)
  return _internal_metadata();
}
inline void GlobalSystemConfigList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* GlobalSystemConfigList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* GlobalSystemConfigList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* GlobalSystemConfigList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* GlobalSystemConfigList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.metadata)
  return _msg;
}
inline void GlobalSystemConfigList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig items = 2;
inline int GlobalSystemConfigList::_internal_items_size() const {
  return items_.size();
}
inline int GlobalSystemConfigList::items_size() const {
  return _internal_items_size();
}
inline void GlobalSystemConfigList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig* GlobalSystemConfigList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig >*
GlobalSystemConfigList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig& GlobalSystemConfigList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig& GlobalSystemConfigList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig* GlobalSystemConfigList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig* GlobalSystemConfigList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalSystemConfig >&
GlobalSystemConfigList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigList.items)
  return items_;
}

// -------------------------------------------------------------------

// GlobalSystemConfigSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool GlobalSystemConfigSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool GlobalSystemConfigSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void GlobalSystemConfigSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& GlobalSystemConfigSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& GlobalSystemConfigSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.commonSpec)
  return _internal_commonspec();
}
inline void GlobalSystemConfigSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* GlobalSystemConfigSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* GlobalSystemConfigSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* GlobalSystemConfigSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* GlobalSystemConfigSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.commonSpec)
  return _msg;
}
inline void GlobalSystemConfigSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.commonSpec)
}

// optional bool enable4bytesAS = 2;
inline bool GlobalSystemConfigSpec::_internal_has_enable4bytesas() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GlobalSystemConfigSpec::has_enable4bytesas() const {
  return _internal_has_enable4bytesas();
}
inline void GlobalSystemConfigSpec::clear_enable4bytesas() {
  enable4bytesas_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GlobalSystemConfigSpec::_internal_enable4bytesas() const {
  return enable4bytesas_;
}
inline bool GlobalSystemConfigSpec::enable4bytesas() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.enable4bytesAS)
  return _internal_enable4bytesas();
}
inline void GlobalSystemConfigSpec::_internal_set_enable4bytesas(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable4bytesas_ = value;
}
inline void GlobalSystemConfigSpec::set_enable4bytesas(bool value) {
  _internal_set_enable4bytesas(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.enable4bytesAS)
}

// optional int32 autonomousSystem = 3;
inline bool GlobalSystemConfigSpec::_internal_has_autonomoussystem() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GlobalSystemConfigSpec::has_autonomoussystem() const {
  return _internal_has_autonomoussystem();
}
inline void GlobalSystemConfigSpec::clear_autonomoussystem() {
  autonomoussystem_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlobalSystemConfigSpec::_internal_autonomoussystem() const {
  return autonomoussystem_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlobalSystemConfigSpec::autonomoussystem() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.autonomousSystem)
  return _internal_autonomoussystem();
}
inline void GlobalSystemConfigSpec::_internal_set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  autonomoussystem_ = value;
}
inline void GlobalSystemConfigSpec::set_autonomoussystem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_autonomoussystem(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.autonomousSystem)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference bgpRouterReferences = 4;
inline int GlobalSystemConfigSpec::_internal_bgprouterreferences_size() const {
  return bgprouterreferences_.size();
}
inline int GlobalSystemConfigSpec::bgprouterreferences_size() const {
  return _internal_bgprouterreferences_size();
}
inline void GlobalSystemConfigSpec::clear_bgprouterreferences() {
  bgprouterreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* GlobalSystemConfigSpec::mutable_bgprouterreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.bgpRouterReferences)
  return bgprouterreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
GlobalSystemConfigSpec::mutable_bgprouterreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.bgpRouterReferences)
  return &bgprouterreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& GlobalSystemConfigSpec::_internal_bgprouterreferences(int index) const {
  return bgprouterreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& GlobalSystemConfigSpec::bgprouterreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.bgpRouterReferences)
  return _internal_bgprouterreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* GlobalSystemConfigSpec::_internal_add_bgprouterreferences() {
  return bgprouterreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* GlobalSystemConfigSpec::add_bgprouterreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_bgprouterreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.bgpRouterReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
GlobalSystemConfigSpec::bgprouterreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.bgpRouterReferences)
  return bgprouterreferences_;
}

// optional bool ibgpAutoMesh = 5;
inline bool GlobalSystemConfigSpec::_internal_has_ibgpautomesh() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GlobalSystemConfigSpec::has_ibgpautomesh() const {
  return _internal_has_ibgpautomesh();
}
inline void GlobalSystemConfigSpec::clear_ibgpautomesh() {
  ibgpautomesh_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool GlobalSystemConfigSpec::_internal_ibgpautomesh() const {
  return ibgpautomesh_;
}
inline bool GlobalSystemConfigSpec::ibgpautomesh() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.ibgpAutoMesh)
  return _internal_ibgpautomesh();
}
inline void GlobalSystemConfigSpec::_internal_set_ibgpautomesh(bool value) {
  _has_bits_[0] |= 0x00000008u;
  ibgpautomesh_ = value;
}
inline void GlobalSystemConfigSpec::set_ibgpautomesh(bool value) {
  _internal_set_ibgpautomesh(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.ibgpAutoMesh)
}

// optional bool defaultEnableSNAT = 6;
inline bool GlobalSystemConfigSpec::_internal_has_defaultenablesnat() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GlobalSystemConfigSpec::has_defaultenablesnat() const {
  return _internal_has_defaultenablesnat();
}
inline void GlobalSystemConfigSpec::clear_defaultenablesnat() {
  defaultenablesnat_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool GlobalSystemConfigSpec::_internal_defaultenablesnat() const {
  return defaultenablesnat_;
}
inline bool GlobalSystemConfigSpec::defaultenablesnat() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.defaultEnableSNAT)
  return _internal_defaultenablesnat();
}
inline void GlobalSystemConfigSpec::_internal_set_defaultenablesnat(bool value) {
  _has_bits_[0] |= 0x00000010u;
  defaultenablesnat_ = value;
}
inline void GlobalSystemConfigSpec::set_defaultenablesnat(bool value) {
  _internal_set_defaultenablesnat(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec.defaultEnableSNAT)
}

// -------------------------------------------------------------------

// GlobalSystemConfigStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool GlobalSystemConfigStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool GlobalSystemConfigStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void GlobalSystemConfigStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& GlobalSystemConfigStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& GlobalSystemConfigStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus.commonStatus)
  return _internal_commonstatus();
}
inline void GlobalSystemConfigStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* GlobalSystemConfigStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* GlobalSystemConfigStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* GlobalSystemConfigStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* GlobalSystemConfigStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus.commonStatus)
  return _msg;
}
inline void GlobalSystemConfigStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus.commonStatus)
}

// -------------------------------------------------------------------

// GlobalVrouterConfig

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool GlobalVrouterConfig::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfig::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& GlobalVrouterConfig::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& GlobalVrouterConfig::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.metadata)
  return _internal_metadata();
}
inline void GlobalVrouterConfig::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* GlobalVrouterConfig::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* GlobalVrouterConfig::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* GlobalVrouterConfig::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* GlobalVrouterConfig::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.metadata)
  return _msg;
}
inline void GlobalVrouterConfig::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec spec = 2;
inline bool GlobalVrouterConfig::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfig::has_spec() const {
  return _internal_has_spec();
}
inline void GlobalVrouterConfig::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec& GlobalVrouterConfig::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_GlobalVrouterConfigSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec& GlobalVrouterConfig::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.spec)
  return _internal_spec();
}
inline void GlobalVrouterConfig::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* GlobalVrouterConfig::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* GlobalVrouterConfig::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* GlobalVrouterConfig::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* GlobalVrouterConfig::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.spec)
  return _msg;
}
inline void GlobalVrouterConfig::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus status = 3;
inline bool GlobalVrouterConfig::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfig::has_status() const {
  return _internal_has_status();
}
inline void GlobalVrouterConfig::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus& GlobalVrouterConfig::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_GlobalVrouterConfigStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus& GlobalVrouterConfig::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.status)
  return _internal_status();
}
inline void GlobalVrouterConfig::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* GlobalVrouterConfig::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* GlobalVrouterConfig::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* GlobalVrouterConfig::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* GlobalVrouterConfig::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.status)
  return _msg;
}
inline void GlobalVrouterConfig::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfigStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig.status)
}

// -------------------------------------------------------------------

// GlobalVrouterConfigList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool GlobalVrouterConfigList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfigList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& GlobalVrouterConfigList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& GlobalVrouterConfigList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.metadata)
  return _internal_metadata();
}
inline void GlobalVrouterConfigList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* GlobalVrouterConfigList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* GlobalVrouterConfigList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* GlobalVrouterConfigList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* GlobalVrouterConfigList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.metadata)
  return _msg;
}
inline void GlobalVrouterConfigList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig items = 2;
inline int GlobalVrouterConfigList::_internal_items_size() const {
  return items_.size();
}
inline int GlobalVrouterConfigList::items_size() const {
  return _internal_items_size();
}
inline void GlobalVrouterConfigList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig* GlobalVrouterConfigList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig >*
GlobalVrouterConfigList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig& GlobalVrouterConfigList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig& GlobalVrouterConfigList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig* GlobalVrouterConfigList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig* GlobalVrouterConfigList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::GlobalVrouterConfig >&
GlobalVrouterConfigList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigList.items)
  return items_;
}

// -------------------------------------------------------------------

// GlobalVrouterConfigSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool GlobalVrouterConfigSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfigSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void GlobalVrouterConfigSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& GlobalVrouterConfigSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& GlobalVrouterConfigSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.commonSpec)
  return _internal_commonspec();
}
inline void GlobalVrouterConfigSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* GlobalVrouterConfigSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* GlobalVrouterConfigSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* GlobalVrouterConfigSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* GlobalVrouterConfigSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.commonSpec)
  return _msg;
}
inline void GlobalVrouterConfigSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.commonSpec)
}

// optional .k8s.io.api.core.v1.ObjectReference parent = 2;
inline bool GlobalVrouterConfigSpec::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || parent_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfigSpec::has_parent() const {
  return _internal_has_parent();
}
inline const ::k8s::io::api::core::v1::ObjectReference& GlobalVrouterConfigSpec::_internal_parent() const {
  const ::k8s::io::api::core::v1::ObjectReference* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::api::core::v1::ObjectReference&>(
      ::k8s::io::api::core::v1::_ObjectReference_default_instance_);
}
inline const ::k8s::io::api::core::v1::ObjectReference& GlobalVrouterConfigSpec::parent() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.parent)
  return _internal_parent();
}
inline void GlobalVrouterConfigSpec::unsafe_arena_set_allocated_parent(
    ::k8s::io::api::core::v1::ObjectReference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.parent)
}
inline ::k8s::io::api::core::v1::ObjectReference* GlobalVrouterConfigSpec::release_parent() {
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* GlobalVrouterConfigSpec::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.parent)
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* GlobalVrouterConfigSpec::_internal_mutable_parent() {
  _has_bits_[0] |= 0x00000002u;
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::api::core::v1::ObjectReference>(GetArenaForAllocation());
    parent_ = p;
  }
  return parent_;
}
inline ::k8s::io::api::core::v1::ObjectReference* GlobalVrouterConfigSpec::mutable_parent() {
  ::k8s::io::api::core::v1::ObjectReference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.parent)
  return _msg;
}
inline void GlobalVrouterConfigSpec::set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent));
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.parent)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities encapsulationPriorities = 3;
inline bool GlobalVrouterConfigSpec::_internal_has_encapsulationpriorities() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || encapsulationpriorities_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfigSpec::has_encapsulationpriorities() const {
  return _internal_has_encapsulationpriorities();
}
inline void GlobalVrouterConfigSpec::clear_encapsulationpriorities() {
  if (encapsulationpriorities_ != nullptr) encapsulationpriorities_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities& GlobalVrouterConfigSpec::_internal_encapsulationpriorities() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* p = encapsulationpriorities_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_EncapsulationPriorities_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities& GlobalVrouterConfigSpec::encapsulationpriorities() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.encapsulationPriorities)
  return _internal_encapsulationpriorities();
}
inline void GlobalVrouterConfigSpec::unsafe_arena_set_allocated_encapsulationpriorities(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* encapsulationpriorities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encapsulationpriorities_);
  }
  encapsulationpriorities_ = encapsulationpriorities;
  if (encapsulationpriorities) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.encapsulationPriorities)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* GlobalVrouterConfigSpec::release_encapsulationpriorities() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* temp = encapsulationpriorities_;
  encapsulationpriorities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* GlobalVrouterConfigSpec::unsafe_arena_release_encapsulationpriorities() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.encapsulationPriorities)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* temp = encapsulationpriorities_;
  encapsulationpriorities_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* GlobalVrouterConfigSpec::_internal_mutable_encapsulationpriorities() {
  _has_bits_[0] |= 0x00000004u;
  if (encapsulationpriorities_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities>(GetArenaForAllocation());
    encapsulationpriorities_ = p;
  }
  return encapsulationpriorities_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* GlobalVrouterConfigSpec::mutable_encapsulationpriorities() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* _msg = _internal_mutable_encapsulationpriorities();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.encapsulationPriorities)
  return _msg;
}
inline void GlobalVrouterConfigSpec::set_allocated_encapsulationpriorities(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities* encapsulationpriorities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete encapsulationpriorities_;
  }
  if (encapsulationpriorities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::EncapsulationPriorities>::GetOwningArena(encapsulationpriorities);
    if (message_arena != submessage_arena) {
      encapsulationpriorities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encapsulationpriorities, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  encapsulationpriorities_ = encapsulationpriorities;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.encapsulationPriorities)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices linklocalServices = 4;
inline bool GlobalVrouterConfigSpec::_internal_has_linklocalservices() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || linklocalservices_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfigSpec::has_linklocalservices() const {
  return _internal_has_linklocalservices();
}
inline void GlobalVrouterConfigSpec::clear_linklocalservices() {
  if (linklocalservices_ != nullptr) linklocalservices_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices& GlobalVrouterConfigSpec::_internal_linklocalservices() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* p = linklocalservices_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_LinklocalServices_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices& GlobalVrouterConfigSpec::linklocalservices() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.linklocalServices)
  return _internal_linklocalservices();
}
inline void GlobalVrouterConfigSpec::unsafe_arena_set_allocated_linklocalservices(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* linklocalservices) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linklocalservices_);
  }
  linklocalservices_ = linklocalservices;
  if (linklocalservices) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.linklocalServices)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* GlobalVrouterConfigSpec::release_linklocalservices() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* temp = linklocalservices_;
  linklocalservices_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* GlobalVrouterConfigSpec::unsafe_arena_release_linklocalservices() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.linklocalServices)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* temp = linklocalservices_;
  linklocalservices_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* GlobalVrouterConfigSpec::_internal_mutable_linklocalservices() {
  _has_bits_[0] |= 0x00000008u;
  if (linklocalservices_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices>(GetArenaForAllocation());
    linklocalservices_ = p;
  }
  return linklocalservices_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* GlobalVrouterConfigSpec::mutable_linklocalservices() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* _msg = _internal_mutable_linklocalservices();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.linklocalServices)
  return _msg;
}
inline void GlobalVrouterConfigSpec::set_allocated_linklocalservices(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices* linklocalservices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete linklocalservices_;
  }
  if (linklocalservices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServices>::GetOwningArena(linklocalservices);
    if (message_arena != submessage_arena) {
      linklocalservices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linklocalservices, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  linklocalservices_ = linklocalservices;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.linklocalServices)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools portTranslationPools = 5;
inline bool GlobalVrouterConfigSpec::_internal_has_porttranslationpools() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || porttranslationpools_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfigSpec::has_porttranslationpools() const {
  return _internal_has_porttranslationpools();
}
inline void GlobalVrouterConfigSpec::clear_porttranslationpools() {
  if (porttranslationpools_ != nullptr) porttranslationpools_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools& GlobalVrouterConfigSpec::_internal_porttranslationpools() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* p = porttranslationpools_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_PortTranslationPools_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools& GlobalVrouterConfigSpec::porttranslationpools() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.portTranslationPools)
  return _internal_porttranslationpools();
}
inline void GlobalVrouterConfigSpec::unsafe_arena_set_allocated_porttranslationpools(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* porttranslationpools) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(porttranslationpools_);
  }
  porttranslationpools_ = porttranslationpools;
  if (porttranslationpools) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.portTranslationPools)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* GlobalVrouterConfigSpec::release_porttranslationpools() {
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* temp = porttranslationpools_;
  porttranslationpools_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* GlobalVrouterConfigSpec::unsafe_arena_release_porttranslationpools() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.portTranslationPools)
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* temp = porttranslationpools_;
  porttranslationpools_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* GlobalVrouterConfigSpec::_internal_mutable_porttranslationpools() {
  _has_bits_[0] |= 0x00000010u;
  if (porttranslationpools_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools>(GetArenaForAllocation());
    porttranslationpools_ = p;
  }
  return porttranslationpools_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* GlobalVrouterConfigSpec::mutable_porttranslationpools() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* _msg = _internal_mutable_porttranslationpools();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.portTranslationPools)
  return _msg;
}
inline void GlobalVrouterConfigSpec::set_allocated_porttranslationpools(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools* porttranslationpools) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete porttranslationpools_;
  }
  if (porttranslationpools) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPools>::GetOwningArena(porttranslationpools);
    if (message_arena != submessage_arena) {
      porttranslationpools = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, porttranslationpools, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  porttranslationpools_ = porttranslationpools;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.portTranslationPools)
}

// optional int32 flowExportRate = 6;
inline bool GlobalVrouterConfigSpec::_internal_has_flowexportrate() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GlobalVrouterConfigSpec::has_flowexportrate() const {
  return _internal_has_flowexportrate();
}
inline void GlobalVrouterConfigSpec::clear_flowexportrate() {
  flowexportrate_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlobalVrouterConfigSpec::_internal_flowexportrate() const {
  return flowexportrate_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlobalVrouterConfigSpec::flowexportrate() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.flowExportRate)
  return _internal_flowexportrate();
}
inline void GlobalVrouterConfigSpec::_internal_set_flowexportrate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  flowexportrate_ = value;
}
inline void GlobalVrouterConfigSpec::set_flowexportrate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_flowexportrate(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec.flowExportRate)
}

// -------------------------------------------------------------------

// GlobalVrouterConfigStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool GlobalVrouterConfigStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool GlobalVrouterConfigStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void GlobalVrouterConfigStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& GlobalVrouterConfigStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& GlobalVrouterConfigStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus.commonStatus)
  return _internal_commonstatus();
}
inline void GlobalVrouterConfigStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* GlobalVrouterConfigStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* GlobalVrouterConfigStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* GlobalVrouterConfigStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* GlobalVrouterConfigStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus.commonStatus)
  return _msg;
}
inline void GlobalVrouterConfigStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus.commonStatus)
}

// -------------------------------------------------------------------

// IPRange

// optional string from = 1;
inline bool IPRange::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IPRange::has_from() const {
  return _internal_has_from();
}
inline void IPRange::clear_from() {
  from_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IPRange::from() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPRange::set_from(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.from)
}
inline std::string* IPRange::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.from)
  return _s;
}
inline const std::string& IPRange::_internal_from() const {
  return from_.Get();
}
inline void IPRange::_internal_set_from(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPRange::_internal_mutable_from() {
  _has_bits_[0] |= 0x00000001u;
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPRange::release_from() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.from)
  if (!_internal_has_from()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return from_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IPRange::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.from)
}

// optional string to = 2;
inline bool IPRange::_internal_has_to() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IPRange::has_to() const {
  return _internal_has_to();
}
inline void IPRange::clear_to() {
  to_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IPRange::to() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPRange::set_to(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.to)
}
inline std::string* IPRange::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.to)
  return _s;
}
inline const std::string& IPRange::_internal_to() const {
  return to_.Get();
}
inline void IPRange::_internal_set_to(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPRange::_internal_mutable_to() {
  _has_bits_[0] |= 0x00000002u;
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPRange::release_to() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.to)
  if (!_internal_has_to()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return to_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IPRange::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange.to)
}

// -------------------------------------------------------------------

// ImportVirtualNetworkRouter

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry virtualNetworkRouters = 1;
inline int ImportVirtualNetworkRouter::_internal_virtualnetworkrouters_size() const {
  return virtualnetworkrouters_.size();
}
inline int ImportVirtualNetworkRouter::virtualnetworkrouters_size() const {
  return _internal_virtualnetworkrouters_size();
}
inline void ImportVirtualNetworkRouter::clear_virtualnetworkrouters() {
  virtualnetworkrouters_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry* ImportVirtualNetworkRouter::mutable_virtualnetworkrouters(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter.virtualNetworkRouters)
  return virtualnetworkrouters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry >*
ImportVirtualNetworkRouter::mutable_virtualnetworkrouters() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter.virtualNetworkRouters)
  return &virtualnetworkrouters_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry& ImportVirtualNetworkRouter::_internal_virtualnetworkrouters(int index) const {
  return virtualnetworkrouters_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry& ImportVirtualNetworkRouter::virtualnetworkrouters(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter.virtualNetworkRouters)
  return _internal_virtualnetworkrouters(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry* ImportVirtualNetworkRouter::_internal_add_virtualnetworkrouters() {
  return virtualnetworkrouters_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry* ImportVirtualNetworkRouter::add_virtualnetworkrouters() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry* _add = _internal_add_virtualnetworkrouters();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter.virtualNetworkRouters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterEntry >&
ImportVirtualNetworkRouter::virtualnetworkrouters() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter.virtualNetworkRouters)
  return virtualnetworkrouters_;
}

// -------------------------------------------------------------------

// InstanceIP

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool InstanceIP::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool InstanceIP::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& InstanceIP::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& InstanceIP::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.metadata)
  return _internal_metadata();
}
inline void InstanceIP::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* InstanceIP::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* InstanceIP::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* InstanceIP::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* InstanceIP::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.metadata)
  return _msg;
}
inline void InstanceIP::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec spec = 2;
inline bool InstanceIP::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool InstanceIP::has_spec() const {
  return _internal_has_spec();
}
inline void InstanceIP::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec& InstanceIP::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_InstanceIPSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec& InstanceIP::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.spec)
  return _internal_spec();
}
inline void InstanceIP::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* InstanceIP::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* InstanceIP::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* InstanceIP::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* InstanceIP::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.spec)
  return _msg;
}
inline void InstanceIP::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus status = 3;
inline bool InstanceIP::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool InstanceIP::has_status() const {
  return _internal_has_status();
}
inline void InstanceIP::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus& InstanceIP::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_InstanceIPStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus& InstanceIP::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.status)
  return _internal_status();
}
inline void InstanceIP::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* InstanceIP::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* InstanceIP::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* InstanceIP::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* InstanceIP::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.status)
  return _msg;
}
inline void InstanceIP::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIPStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP.status)
}

// -------------------------------------------------------------------

// InstanceIPList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool InstanceIPList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool InstanceIPList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& InstanceIPList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& InstanceIPList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.metadata)
  return _internal_metadata();
}
inline void InstanceIPList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* InstanceIPList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* InstanceIPList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* InstanceIPList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* InstanceIPList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.metadata)
  return _msg;
}
inline void InstanceIPList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP items = 2;
inline int InstanceIPList::_internal_items_size() const {
  return items_.size();
}
inline int InstanceIPList::items_size() const {
  return _internal_items_size();
}
inline void InstanceIPList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP* InstanceIPList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP >*
InstanceIPList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP& InstanceIPList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP& InstanceIPList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP* InstanceIPList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP* InstanceIPList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::InstanceIP >&
InstanceIPList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPList.items)
  return items_;
}

// -------------------------------------------------------------------

// InstanceIPSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool InstanceIPSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool InstanceIPSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void InstanceIPSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& InstanceIPSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& InstanceIPSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.commonSpec)
  return _internal_commonspec();
}
inline void InstanceIPSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* InstanceIPSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* InstanceIPSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.commonSpec)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* InstanceIPSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000008u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* InstanceIPSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.commonSpec)
  return _msg;
}
inline void InstanceIPSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.commonSpec)
}

// optional string instanceIPAddress = 2;
inline bool InstanceIPSpec::_internal_has_instanceipaddress() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstanceIPSpec::has_instanceipaddress() const {
  return _internal_has_instanceipaddress();
}
inline void InstanceIPSpec::clear_instanceipaddress() {
  instanceipaddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstanceIPSpec::instanceipaddress() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPAddress)
  return _internal_instanceipaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceIPSpec::set_instanceipaddress(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 instanceipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPAddress)
}
inline std::string* InstanceIPSpec::mutable_instanceipaddress() {
  std::string* _s = _internal_mutable_instanceipaddress();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPAddress)
  return _s;
}
inline const std::string& InstanceIPSpec::_internal_instanceipaddress() const {
  return instanceipaddress_.Get();
}
inline void InstanceIPSpec::_internal_set_instanceipaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  instanceipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceIPSpec::_internal_mutable_instanceipaddress() {
  _has_bits_[0] |= 0x00000001u;
  return instanceipaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceIPSpec::release_instanceipaddress() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPAddress)
  if (!_internal_has_instanceipaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return instanceipaddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceIPSpec::set_allocated_instanceipaddress(std::string* instanceipaddress) {
  if (instanceipaddress != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  instanceipaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instanceipaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPAddress)
}

// optional string instanceIPFamily = 3;
inline bool InstanceIPSpec::_internal_has_instanceipfamily() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstanceIPSpec::has_instanceipfamily() const {
  return _internal_has_instanceipfamily();
}
inline void InstanceIPSpec::clear_instanceipfamily() {
  instanceipfamily_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstanceIPSpec::instanceipfamily() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPFamily)
  return _internal_instanceipfamily();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceIPSpec::set_instanceipfamily(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 instanceipfamily_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPFamily)
}
inline std::string* InstanceIPSpec::mutable_instanceipfamily() {
  std::string* _s = _internal_mutable_instanceipfamily();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPFamily)
  return _s;
}
inline const std::string& InstanceIPSpec::_internal_instanceipfamily() const {
  return instanceipfamily_.Get();
}
inline void InstanceIPSpec::_internal_set_instanceipfamily(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  instanceipfamily_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceIPSpec::_internal_mutable_instanceipfamily() {
  _has_bits_[0] |= 0x00000002u;
  return instanceipfamily_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceIPSpec::release_instanceipfamily() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPFamily)
  if (!_internal_has_instanceipfamily()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return instanceipfamily_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceIPSpec::set_allocated_instanceipfamily(std::string* instanceipfamily) {
  if (instanceipfamily != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  instanceipfamily_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instanceipfamily,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.instanceIPFamily)
}

// optional string cidr = 4;
inline bool InstanceIPSpec::_internal_has_cidr() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InstanceIPSpec::has_cidr() const {
  return _internal_has_cidr();
}
inline void InstanceIPSpec::clear_cidr() {
  cidr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InstanceIPSpec::cidr() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.cidr)
  return _internal_cidr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceIPSpec::set_cidr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 cidr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.cidr)
}
inline std::string* InstanceIPSpec::mutable_cidr() {
  std::string* _s = _internal_mutable_cidr();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.cidr)
  return _s;
}
inline const std::string& InstanceIPSpec::_internal_cidr() const {
  return cidr_.Get();
}
inline void InstanceIPSpec::_internal_set_cidr(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  cidr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceIPSpec::_internal_mutable_cidr() {
  _has_bits_[0] |= 0x00000004u;
  return cidr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceIPSpec::release_cidr() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.cidr)
  if (!_internal_has_cidr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return cidr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceIPSpec::set_allocated_cidr(std::string* cidr) {
  if (cidr != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cidr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cidr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.cidr)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualNetworkReference = 5;
inline bool InstanceIPSpec::_internal_has_virtualnetworkreference() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || virtualnetworkreference_ != nullptr);
  return value;
}
inline bool InstanceIPSpec::has_virtualnetworkreference() const {
  return _internal_has_virtualnetworkreference();
}
inline void InstanceIPSpec::clear_virtualnetworkreference() {
  if (virtualnetworkreference_ != nullptr) virtualnetworkreference_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& InstanceIPSpec::_internal_virtualnetworkreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = virtualnetworkreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& InstanceIPSpec::virtualnetworkreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualNetworkReference)
  return _internal_virtualnetworkreference();
}
inline void InstanceIPSpec::unsafe_arena_set_allocated_virtualnetworkreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkreference_);
  }
  virtualnetworkreference_ = virtualnetworkreference;
  if (virtualnetworkreference) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualNetworkReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPSpec::release_virtualnetworkreference() {
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = virtualnetworkreference_;
  virtualnetworkreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPSpec::unsafe_arena_release_virtualnetworkreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualNetworkReference)
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = virtualnetworkreference_;
  virtualnetworkreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPSpec::_internal_mutable_virtualnetworkreference() {
  _has_bits_[0] |= 0x00000010u;
  if (virtualnetworkreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    virtualnetworkreference_ = p;
  }
  return virtualnetworkreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPSpec::mutable_virtualnetworkreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_virtualnetworkreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualNetworkReference)
  return _msg;
}
inline void InstanceIPSpec::set_allocated_virtualnetworkreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete virtualnetworkreference_;
  }
  if (virtualnetworkreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(virtualnetworkreference);
    if (message_arena != submessage_arena) {
      virtualnetworkreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtualnetworkreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  virtualnetworkreference_ = virtualnetworkreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualNetworkReference)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 6;
inline int InstanceIPSpec::_internal_virtualmachineinterfacereferences_size() const {
  return virtualmachineinterfacereferences_.size();
}
inline int InstanceIPSpec::virtualmachineinterfacereferences_size() const {
  return _internal_virtualmachineinterfacereferences_size();
}
inline void InstanceIPSpec::clear_virtualmachineinterfacereferences() {
  virtualmachineinterfacereferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPSpec::mutable_virtualmachineinterfacereferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualMachineInterfaceReferences)
  return virtualmachineinterfacereferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
InstanceIPSpec::mutable_virtualmachineinterfacereferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualMachineInterfaceReferences)
  return &virtualmachineinterfacereferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& InstanceIPSpec::_internal_virtualmachineinterfacereferences(int index) const {
  return virtualmachineinterfacereferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& InstanceIPSpec::virtualmachineinterfacereferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualMachineInterfaceReferences)
  return _internal_virtualmachineinterfacereferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPSpec::_internal_add_virtualmachineinterfacereferences() {
  return virtualmachineinterfacereferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPSpec::add_virtualmachineinterfacereferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_virtualmachineinterfacereferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualMachineInterfaceReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
InstanceIPSpec::virtualmachineinterfacereferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.virtualMachineInterfaceReferences)
  return virtualmachineinterfacereferences_;
}

// repeated string ipRangeKeys = 7;
inline int InstanceIPSpec::_internal_iprangekeys_size() const {
  return iprangekeys_.size();
}
inline int InstanceIPSpec::iprangekeys_size() const {
  return _internal_iprangekeys_size();
}
inline void InstanceIPSpec::clear_iprangekeys() {
  iprangekeys_.Clear();
}
inline std::string* InstanceIPSpec::add_iprangekeys() {
  std::string* _s = _internal_add_iprangekeys();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
  return _s;
}
inline const std::string& InstanceIPSpec::_internal_iprangekeys(int index) const {
  return iprangekeys_.Get(index);
}
inline const std::string& InstanceIPSpec::iprangekeys(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
  return _internal_iprangekeys(index);
}
inline std::string* InstanceIPSpec::mutable_iprangekeys(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
  return iprangekeys_.Mutable(index);
}
inline void InstanceIPSpec::set_iprangekeys(int index, const std::string& value) {
  iprangekeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
}
inline void InstanceIPSpec::set_iprangekeys(int index, std::string&& value) {
  iprangekeys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
}
inline void InstanceIPSpec::set_iprangekeys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  iprangekeys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
}
inline void InstanceIPSpec::set_iprangekeys(int index, const char* value, size_t size) {
  iprangekeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
}
inline std::string* InstanceIPSpec::_internal_add_iprangekeys() {
  return iprangekeys_.Add();
}
inline void InstanceIPSpec::add_iprangekeys(const std::string& value) {
  iprangekeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
}
inline void InstanceIPSpec::add_iprangekeys(std::string&& value) {
  iprangekeys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
}
inline void InstanceIPSpec::add_iprangekeys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  iprangekeys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
}
inline void InstanceIPSpec::add_iprangekeys(const char* value, size_t size) {
  iprangekeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InstanceIPSpec::iprangekeys() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
  return iprangekeys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InstanceIPSpec::mutable_iprangekeys() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec.ipRangeKeys)
  return &iprangekeys_;
}

// -------------------------------------------------------------------

// InstanceIPStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool InstanceIPStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool InstanceIPStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void InstanceIPStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& InstanceIPStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& InstanceIPStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.commonStatus)
  return _internal_commonstatus();
}
inline void InstanceIPStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* InstanceIPStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* InstanceIPStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* InstanceIPStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* InstanceIPStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.commonStatus)
  return _msg;
}
inline void InstanceIPStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.commonStatus)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference subnetReference = 2;
inline bool InstanceIPStatus::_internal_has_subnetreference() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || subnetreference_ != nullptr);
  return value;
}
inline bool InstanceIPStatus::has_subnetreference() const {
  return _internal_has_subnetreference();
}
inline void InstanceIPStatus::clear_subnetreference() {
  if (subnetreference_ != nullptr) subnetreference_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& InstanceIPStatus::_internal_subnetreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = subnetreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& InstanceIPStatus::subnetreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.subnetReference)
  return _internal_subnetreference();
}
inline void InstanceIPStatus::unsafe_arena_set_allocated_subnetreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnetreference_);
  }
  subnetreference_ = subnetreference;
  if (subnetreference) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.subnetReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPStatus::release_subnetreference() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = subnetreference_;
  subnetreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPStatus::unsafe_arena_release_subnetreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.subnetReference)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = subnetreference_;
  subnetreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPStatus::_internal_mutable_subnetreference() {
  _has_bits_[0] |= 0x00000002u;
  if (subnetreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    subnetreference_ = p;
  }
  return subnetreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* InstanceIPStatus::mutable_subnetreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_subnetreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.subnetReference)
  return _msg;
}
inline void InstanceIPStatus::set_allocated_subnetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* subnetreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subnetreference_;
  }
  if (subnetreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(subnetreference);
    if (message_arena != submessage_arena) {
      subnetreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subnetreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  subnetreference_ = subnetreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus.subnetReference)
}

// -------------------------------------------------------------------

// LinklocalServiceEntryType

// optional string ipFabricDNSServiceName = 1;
inline bool LinklocalServiceEntryType::_internal_has_ipfabricdnsservicename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinklocalServiceEntryType::has_ipfabricdnsservicename() const {
  return _internal_has_ipfabricdnsservicename();
}
inline void LinklocalServiceEntryType::clear_ipfabricdnsservicename() {
  ipfabricdnsservicename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LinklocalServiceEntryType::ipfabricdnsservicename() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricDNSServiceName)
  return _internal_ipfabricdnsservicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinklocalServiceEntryType::set_ipfabricdnsservicename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ipfabricdnsservicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricDNSServiceName)
}
inline std::string* LinklocalServiceEntryType::mutable_ipfabricdnsservicename() {
  std::string* _s = _internal_mutable_ipfabricdnsservicename();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricDNSServiceName)
  return _s;
}
inline const std::string& LinklocalServiceEntryType::_internal_ipfabricdnsservicename() const {
  return ipfabricdnsservicename_.Get();
}
inline void LinklocalServiceEntryType::_internal_set_ipfabricdnsservicename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ipfabricdnsservicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LinklocalServiceEntryType::_internal_mutable_ipfabricdnsservicename() {
  _has_bits_[0] |= 0x00000001u;
  return ipfabricdnsservicename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LinklocalServiceEntryType::release_ipfabricdnsservicename() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricDNSServiceName)
  if (!_internal_has_ipfabricdnsservicename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ipfabricdnsservicename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LinklocalServiceEntryType::set_allocated_ipfabricdnsservicename(std::string* ipfabricdnsservicename) {
  if (ipfabricdnsservicename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ipfabricdnsservicename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipfabricdnsservicename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricDNSServiceName)
}

// repeated string ipFabricServiceIP = 2;
inline int LinklocalServiceEntryType::_internal_ipfabricserviceip_size() const {
  return ipfabricserviceip_.size();
}
inline int LinklocalServiceEntryType::ipfabricserviceip_size() const {
  return _internal_ipfabricserviceip_size();
}
inline void LinklocalServiceEntryType::clear_ipfabricserviceip() {
  ipfabricserviceip_.Clear();
}
inline std::string* LinklocalServiceEntryType::add_ipfabricserviceip() {
  std::string* _s = _internal_add_ipfabricserviceip();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
  return _s;
}
inline const std::string& LinklocalServiceEntryType::_internal_ipfabricserviceip(int index) const {
  return ipfabricserviceip_.Get(index);
}
inline const std::string& LinklocalServiceEntryType::ipfabricserviceip(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
  return _internal_ipfabricserviceip(index);
}
inline std::string* LinklocalServiceEntryType::mutable_ipfabricserviceip(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
  return ipfabricserviceip_.Mutable(index);
}
inline void LinklocalServiceEntryType::set_ipfabricserviceip(int index, const std::string& value) {
  ipfabricserviceip_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
}
inline void LinklocalServiceEntryType::set_ipfabricserviceip(int index, std::string&& value) {
  ipfabricserviceip_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
}
inline void LinklocalServiceEntryType::set_ipfabricserviceip(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ipfabricserviceip_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
}
inline void LinklocalServiceEntryType::set_ipfabricserviceip(int index, const char* value, size_t size) {
  ipfabricserviceip_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
}
inline std::string* LinklocalServiceEntryType::_internal_add_ipfabricserviceip() {
  return ipfabricserviceip_.Add();
}
inline void LinklocalServiceEntryType::add_ipfabricserviceip(const std::string& value) {
  ipfabricserviceip_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
}
inline void LinklocalServiceEntryType::add_ipfabricserviceip(std::string&& value) {
  ipfabricserviceip_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
}
inline void LinklocalServiceEntryType::add_ipfabricserviceip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ipfabricserviceip_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
}
inline void LinklocalServiceEntryType::add_ipfabricserviceip(const char* value, size_t size) {
  ipfabricserviceip_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LinklocalServiceEntryType::ipfabricserviceip() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
  return ipfabricserviceip_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LinklocalServiceEntryType::mutable_ipfabricserviceip() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServiceIP)
  return &ipfabricserviceip_;
}

// optional int32 ipFabricServicePort = 3;
inline bool LinklocalServiceEntryType::_internal_has_ipfabricserviceport() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LinklocalServiceEntryType::has_ipfabricserviceport() const {
  return _internal_has_ipfabricserviceport();
}
inline void LinklocalServiceEntryType::clear_ipfabricserviceport() {
  ipfabricserviceport_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LinklocalServiceEntryType::_internal_ipfabricserviceport() const {
  return ipfabricserviceport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LinklocalServiceEntryType::ipfabricserviceport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServicePort)
  return _internal_ipfabricserviceport();
}
inline void LinklocalServiceEntryType::_internal_set_ipfabricserviceport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  ipfabricserviceport_ = value;
}
inline void LinklocalServiceEntryType::set_ipfabricserviceport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ipfabricserviceport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.ipFabricServicePort)
}

// optional string linklocalServiceIP = 4;
inline bool LinklocalServiceEntryType::_internal_has_linklocalserviceip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LinklocalServiceEntryType::has_linklocalserviceip() const {
  return _internal_has_linklocalserviceip();
}
inline void LinklocalServiceEntryType::clear_linklocalserviceip() {
  linklocalserviceip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LinklocalServiceEntryType::linklocalserviceip() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceIP)
  return _internal_linklocalserviceip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinklocalServiceEntryType::set_linklocalserviceip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 linklocalserviceip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceIP)
}
inline std::string* LinklocalServiceEntryType::mutable_linklocalserviceip() {
  std::string* _s = _internal_mutable_linklocalserviceip();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceIP)
  return _s;
}
inline const std::string& LinklocalServiceEntryType::_internal_linklocalserviceip() const {
  return linklocalserviceip_.Get();
}
inline void LinklocalServiceEntryType::_internal_set_linklocalserviceip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  linklocalserviceip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LinklocalServiceEntryType::_internal_mutable_linklocalserviceip() {
  _has_bits_[0] |= 0x00000002u;
  return linklocalserviceip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LinklocalServiceEntryType::release_linklocalserviceip() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceIP)
  if (!_internal_has_linklocalserviceip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return linklocalserviceip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LinklocalServiceEntryType::set_allocated_linklocalserviceip(std::string* linklocalserviceip) {
  if (linklocalserviceip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  linklocalserviceip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), linklocalserviceip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceIP)
}

// optional string linklocalServiceName = 5;
inline bool LinklocalServiceEntryType::_internal_has_linklocalservicename() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LinklocalServiceEntryType::has_linklocalservicename() const {
  return _internal_has_linklocalservicename();
}
inline void LinklocalServiceEntryType::clear_linklocalservicename() {
  linklocalservicename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LinklocalServiceEntryType::linklocalservicename() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceName)
  return _internal_linklocalservicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinklocalServiceEntryType::set_linklocalservicename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 linklocalservicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceName)
}
inline std::string* LinklocalServiceEntryType::mutable_linklocalservicename() {
  std::string* _s = _internal_mutable_linklocalservicename();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceName)
  return _s;
}
inline const std::string& LinklocalServiceEntryType::_internal_linklocalservicename() const {
  return linklocalservicename_.Get();
}
inline void LinklocalServiceEntryType::_internal_set_linklocalservicename(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  linklocalservicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LinklocalServiceEntryType::_internal_mutable_linklocalservicename() {
  _has_bits_[0] |= 0x00000004u;
  return linklocalservicename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LinklocalServiceEntryType::release_linklocalservicename() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceName)
  if (!_internal_has_linklocalservicename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return linklocalservicename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LinklocalServiceEntryType::set_allocated_linklocalservicename(std::string* linklocalservicename) {
  if (linklocalservicename != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  linklocalservicename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), linklocalservicename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServiceName)
}

// optional int32 linklocalServicePort = 6;
inline bool LinklocalServiceEntryType::_internal_has_linklocalserviceport() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LinklocalServiceEntryType::has_linklocalserviceport() const {
  return _internal_has_linklocalserviceport();
}
inline void LinklocalServiceEntryType::clear_linklocalserviceport() {
  linklocalserviceport_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LinklocalServiceEntryType::_internal_linklocalserviceport() const {
  return linklocalserviceport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LinklocalServiceEntryType::linklocalserviceport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServicePort)
  return _internal_linklocalserviceport();
}
inline void LinklocalServiceEntryType::_internal_set_linklocalserviceport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  linklocalserviceport_ = value;
}
inline void LinklocalServiceEntryType::set_linklocalserviceport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_linklocalserviceport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType.linklocalServicePort)
}

// -------------------------------------------------------------------

// LinklocalServices

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType linklocalServiceEntry = 1;
inline int LinklocalServices::_internal_linklocalserviceentry_size() const {
  return linklocalserviceentry_.size();
}
inline int LinklocalServices::linklocalserviceentry_size() const {
  return _internal_linklocalserviceentry_size();
}
inline void LinklocalServices::clear_linklocalserviceentry() {
  linklocalserviceentry_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType* LinklocalServices::mutable_linklocalserviceentry(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices.linklocalServiceEntry)
  return linklocalserviceentry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType >*
LinklocalServices::mutable_linklocalserviceentry() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices.linklocalServiceEntry)
  return &linklocalserviceentry_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType& LinklocalServices::_internal_linklocalserviceentry(int index) const {
  return linklocalserviceentry_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType& LinklocalServices::linklocalserviceentry(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices.linklocalServiceEntry)
  return _internal_linklocalserviceentry(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType* LinklocalServices::_internal_add_linklocalserviceentry() {
  return linklocalserviceentry_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType* LinklocalServices::add_linklocalserviceentry() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType* _add = _internal_add_linklocalserviceentry();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices.linklocalServiceEntry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::LinklocalServiceEntryType >&
LinklocalServices::linklocalserviceentry() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices.linklocalServiceEntry)
  return linklocalserviceentry_;
}

// -------------------------------------------------------------------

// MACAddresses

// repeated string macAddress = 1;
inline int MACAddresses::_internal_macaddress_size() const {
  return macaddress_.size();
}
inline int MACAddresses::macaddress_size() const {
  return _internal_macaddress_size();
}
inline void MACAddresses::clear_macaddress() {
  macaddress_.Clear();
}
inline std::string* MACAddresses::add_macaddress() {
  std::string* _s = _internal_add_macaddress();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
  return _s;
}
inline const std::string& MACAddresses::_internal_macaddress(int index) const {
  return macaddress_.Get(index);
}
inline const std::string& MACAddresses::macaddress(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
  return _internal_macaddress(index);
}
inline std::string* MACAddresses::mutable_macaddress(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
  return macaddress_.Mutable(index);
}
inline void MACAddresses::set_macaddress(int index, const std::string& value) {
  macaddress_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
}
inline void MACAddresses::set_macaddress(int index, std::string&& value) {
  macaddress_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
}
inline void MACAddresses::set_macaddress(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  macaddress_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
}
inline void MACAddresses::set_macaddress(int index, const char* value, size_t size) {
  macaddress_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
}
inline std::string* MACAddresses::_internal_add_macaddress() {
  return macaddress_.Add();
}
inline void MACAddresses::add_macaddress(const std::string& value) {
  macaddress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
}
inline void MACAddresses::add_macaddress(std::string&& value) {
  macaddress_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
}
inline void MACAddresses::add_macaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  macaddress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
}
inline void MACAddresses::add_macaddress(const char* value, size_t size) {
  macaddress_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MACAddresses::macaddress() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
  return macaddress_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MACAddresses::mutable_macaddress() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses.macAddress)
  return &macaddress_;
}

// -------------------------------------------------------------------

// PolicyBasedForwardingRule

// optional string direction = 1;
inline bool PolicyBasedForwardingRule::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolicyBasedForwardingRule::has_direction() const {
  return _internal_has_direction();
}
inline void PolicyBasedForwardingRule::clear_direction() {
  direction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PolicyBasedForwardingRule::direction() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule.direction)
  return _internal_direction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyBasedForwardingRule::set_direction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 direction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule.direction)
}
inline std::string* PolicyBasedForwardingRule::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule.direction)
  return _s;
}
inline const std::string& PolicyBasedForwardingRule::_internal_direction() const {
  return direction_.Get();
}
inline void PolicyBasedForwardingRule::_internal_set_direction(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  direction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PolicyBasedForwardingRule::_internal_mutable_direction() {
  _has_bits_[0] |= 0x00000001u;
  return direction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PolicyBasedForwardingRule::release_direction() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule.direction)
  if (!_internal_has_direction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return direction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PolicyBasedForwardingRule::set_allocated_direction(std::string* direction) {
  if (direction != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  direction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), direction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule.direction)
}

// -------------------------------------------------------------------

// PortRange

// optional int32 startPort = 1;
inline bool PortRange::_internal_has_startport() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PortRange::has_startport() const {
  return _internal_has_startport();
}
inline void PortRange::clear_startport() {
  startport_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortRange::_internal_startport() const {
  return startport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortRange::startport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange.startPort)
  return _internal_startport();
}
inline void PortRange::_internal_set_startport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  startport_ = value;
}
inline void PortRange::set_startport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_startport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange.startPort)
}

// optional int32 endPort = 2;
inline bool PortRange::_internal_has_endport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PortRange::has_endport() const {
  return _internal_has_endport();
}
inline void PortRange::clear_endport() {
  endport_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortRange::_internal_endport() const {
  return endport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortRange::endport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange.endPort)
  return _internal_endport();
}
inline void PortRange::_internal_set_endport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  endport_ = value;
}
inline void PortRange::set_endport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_endport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange.endPort)
}

// -------------------------------------------------------------------

// PortTranslationPool

// optional string protocol = 1;
inline bool PortTranslationPool::_internal_has_protocol() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PortTranslationPool::has_protocol() const {
  return _internal_has_protocol();
}
inline void PortTranslationPool::clear_protocol() {
  protocol_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PortTranslationPool::protocol() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortTranslationPool::set_protocol(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.protocol)
}
inline std::string* PortTranslationPool::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.protocol)
  return _s;
}
inline const std::string& PortTranslationPool::_internal_protocol() const {
  return protocol_.Get();
}
inline void PortTranslationPool::_internal_set_protocol(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortTranslationPool::_internal_mutable_protocol() {
  _has_bits_[0] |= 0x00000001u;
  return protocol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortTranslationPool::release_protocol() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.protocol)
  if (!_internal_has_protocol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return protocol_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortTranslationPool::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.protocol)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange portRange = 2;
inline bool PortTranslationPool::_internal_has_portrange() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || portrange_ != nullptr);
  return value;
}
inline bool PortTranslationPool::has_portrange() const {
  return _internal_has_portrange();
}
inline void PortTranslationPool::clear_portrange() {
  if (portrange_ != nullptr) portrange_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange& PortTranslationPool::_internal_portrange() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* p = portrange_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_PortRange_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange& PortTranslationPool::portrange() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.portRange)
  return _internal_portrange();
}
inline void PortTranslationPool::unsafe_arena_set_allocated_portrange(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* portrange) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(portrange_);
  }
  portrange_ = portrange;
  if (portrange) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.portRange)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* PortTranslationPool::release_portrange() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* temp = portrange_;
  portrange_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* PortTranslationPool::unsafe_arena_release_portrange() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.portRange)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* temp = portrange_;
  portrange_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* PortTranslationPool::_internal_mutable_portrange() {
  _has_bits_[0] |= 0x00000002u;
  if (portrange_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange>(GetArenaForAllocation());
    portrange_ = p;
  }
  return portrange_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* PortTranslationPool::mutable_portrange() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* _msg = _internal_mutable_portrange();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.portRange)
  return _msg;
}
inline void PortTranslationPool::set_allocated_portrange(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange* portrange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete portrange_;
  }
  if (portrange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortRange>::GetOwningArena(portrange);
    if (message_arena != submessage_arena) {
      portrange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, portrange, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  portrange_ = portrange;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.portRange)
}

// optional int32 portCount = 3;
inline bool PortTranslationPool::_internal_has_portcount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PortTranslationPool::has_portcount() const {
  return _internal_has_portcount();
}
inline void PortTranslationPool::clear_portcount() {
  portcount_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortTranslationPool::_internal_portcount() const {
  return portcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortTranslationPool::portcount() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.portCount)
  return _internal_portcount();
}
inline void PortTranslationPool::_internal_set_portcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  portcount_ = value;
}
inline void PortTranslationPool::set_portcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_portcount(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool.portCount)
}

// -------------------------------------------------------------------

// PortTranslationPools

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool pools = 1;
inline int PortTranslationPools::_internal_pools_size() const {
  return pools_.size();
}
inline int PortTranslationPools::pools_size() const {
  return _internal_pools_size();
}
inline void PortTranslationPools::clear_pools() {
  pools_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool* PortTranslationPools::mutable_pools(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools.pools)
  return pools_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool >*
PortTranslationPools::mutable_pools() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools.pools)
  return &pools_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool& PortTranslationPools::_internal_pools(int index) const {
  return pools_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool& PortTranslationPools::pools(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools.pools)
  return _internal_pools(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool* PortTranslationPools::_internal_add_pools() {
  return pools_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool* PortTranslationPools::add_pools() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool* _add = _internal_add_pools();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools.pools)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PortTranslationPool >&
PortTranslationPools::pools() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools.pools)
  return pools_;
}

// -------------------------------------------------------------------

// PortType

// optional int64 startPort = 1;
inline bool PortType::_internal_has_startport() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PortType::has_startport() const {
  return _internal_has_startport();
}
inline void PortType::clear_startport() {
  startport_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PortType::_internal_startport() const {
  return startport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PortType::startport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType.startPort)
  return _internal_startport();
}
inline void PortType::_internal_set_startport(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  startport_ = value;
}
inline void PortType::set_startport(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_startport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType.startPort)
}

// optional int64 endPort = 2;
inline bool PortType::_internal_has_endport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PortType::has_endport() const {
  return _internal_has_endport();
}
inline void PortType::clear_endport() {
  endport_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PortType::_internal_endport() const {
  return endport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PortType::endport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType.endPort)
  return _internal_endport();
}
inline void PortType::_internal_set_endport(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  endport_ = value;
}
inline void PortType::set_endport(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_endport(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType.endPort)
}

// -------------------------------------------------------------------

// Range

// optional string key = 1;
inline bool Range::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Range::has_key() const {
  return _internal_has_key();
}
inline void Range::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Range::key() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Range::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.key)
}
inline std::string* Range::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.key)
  return _s;
}
inline const std::string& Range::_internal_key() const {
  return key_.Get();
}
inline void Range::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Range::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Range::release_key() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Range::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.key)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange ipRanges = 2;
inline int Range::_internal_ipranges_size() const {
  return ipranges_.size();
}
inline int Range::ipranges_size() const {
  return _internal_ipranges_size();
}
inline void Range::clear_ipranges() {
  ipranges_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange* Range::mutable_ipranges(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.ipRanges)
  return ipranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange >*
Range::mutable_ipranges() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.ipRanges)
  return &ipranges_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange& Range::_internal_ipranges(int index) const {
  return ipranges_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange& Range::ipranges(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.ipRanges)
  return _internal_ipranges(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange* Range::_internal_add_ipranges() {
  return ipranges_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange* Range::add_ipranges() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange* _add = _internal_add_ipranges();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.ipRanges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::IPRange >&
Range::ipranges() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range.ipRanges)
  return ipranges_;
}

// -------------------------------------------------------------------

// ReconcilerState

// optional string state = 1;
inline bool ReconcilerState::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReconcilerState::has_state() const {
  return _internal_has_state();
}
inline void ReconcilerState::clear_state() {
  state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReconcilerState::state() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReconcilerState::set_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.state)
}
inline std::string* ReconcilerState::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.state)
  return _s;
}
inline const std::string& ReconcilerState::_internal_state() const {
  return state_.Get();
}
inline void ReconcilerState::_internal_set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReconcilerState::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000001u;
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReconcilerState::release_state() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return state_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReconcilerState::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.state)
}

// optional string observation = 2;
inline bool ReconcilerState::_internal_has_observation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReconcilerState::has_observation() const {
  return _internal_has_observation();
}
inline void ReconcilerState::clear_observation() {
  observation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReconcilerState::observation() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.observation)
  return _internal_observation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReconcilerState::set_observation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 observation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.observation)
}
inline std::string* ReconcilerState::mutable_observation() {
  std::string* _s = _internal_mutable_observation();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.observation)
  return _s;
}
inline const std::string& ReconcilerState::_internal_observation() const {
  return observation_.Get();
}
inline void ReconcilerState::_internal_set_observation(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  observation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReconcilerState::_internal_mutable_observation() {
  _has_bits_[0] |= 0x00000002u;
  return observation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReconcilerState::release_observation() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.observation)
  if (!_internal_has_observation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return observation_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReconcilerState::set_allocated_observation(std::string* observation) {
  if (observation != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  observation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), observation,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState.observation)
}

// -------------------------------------------------------------------

// ResourceReference

// optional .k8s.io.api.core.v1.ObjectReference objectReference = 1;
inline bool ResourceReference::_internal_has_objectreference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || objectreference_ != nullptr);
  return value;
}
inline bool ResourceReference::has_objectreference() const {
  return _internal_has_objectreference();
}
inline const ::k8s::io::api::core::v1::ObjectReference& ResourceReference::_internal_objectreference() const {
  const ::k8s::io::api::core::v1::ObjectReference* p = objectreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::api::core::v1::ObjectReference&>(
      ::k8s::io::api::core::v1::_ObjectReference_default_instance_);
}
inline const ::k8s::io::api::core::v1::ObjectReference& ResourceReference::objectreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.objectReference)
  return _internal_objectreference();
}
inline void ResourceReference::unsafe_arena_set_allocated_objectreference(
    ::k8s::io::api::core::v1::ObjectReference* objectreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectreference_);
  }
  objectreference_ = objectreference;
  if (objectreference) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.objectReference)
}
inline ::k8s::io::api::core::v1::ObjectReference* ResourceReference::release_objectreference() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::api::core::v1::ObjectReference* temp = objectreference_;
  objectreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* ResourceReference::unsafe_arena_release_objectreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.objectReference)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::api::core::v1::ObjectReference* temp = objectreference_;
  objectreference_ = nullptr;
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* ResourceReference::_internal_mutable_objectreference() {
  _has_bits_[0] |= 0x00000001u;
  if (objectreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::api::core::v1::ObjectReference>(GetArenaForAllocation());
    objectreference_ = p;
  }
  return objectreference_;
}
inline ::k8s::io::api::core::v1::ObjectReference* ResourceReference::mutable_objectreference() {
  ::k8s::io::api::core::v1::ObjectReference* _msg = _internal_mutable_objectreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.objectReference)
  return _msg;
}
inline void ResourceReference::set_allocated_objectreference(::k8s::io::api::core::v1::ObjectReference* objectreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectreference_);
  }
  if (objectreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectreference));
    if (message_arena != submessage_arena) {
      objectreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  objectreference_ = objectreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.objectReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName contrailFqName = 2;
inline bool ResourceReference::_internal_has_contrailfqname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || contrailfqname_ != nullptr);
  return value;
}
inline bool ResourceReference::has_contrailfqname() const {
  return _internal_has_contrailfqname();
}
inline void ResourceReference::clear_contrailfqname() {
  if (contrailfqname_ != nullptr) contrailfqname_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName& ResourceReference::_internal_contrailfqname() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* p = contrailfqname_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ContrailFqName_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName& ResourceReference::contrailfqname() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.contrailFqName)
  return _internal_contrailfqname();
}
inline void ResourceReference::unsafe_arena_set_allocated_contrailfqname(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contrailfqname_);
  }
  contrailfqname_ = contrailfqname;
  if (contrailfqname) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.contrailFqName)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* ResourceReference::release_contrailfqname() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* temp = contrailfqname_;
  contrailfqname_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* ResourceReference::unsafe_arena_release_contrailfqname() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.contrailFqName)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* temp = contrailfqname_;
  contrailfqname_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* ResourceReference::_internal_mutable_contrailfqname() {
  _has_bits_[0] |= 0x00000002u;
  if (contrailfqname_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName>(GetArenaForAllocation());
    contrailfqname_ = p;
  }
  return contrailfqname_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* ResourceReference::mutable_contrailfqname() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* _msg = _internal_mutable_contrailfqname();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.contrailFqName)
  return _msg;
}
inline void ResourceReference::set_allocated_contrailfqname(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName* contrailfqname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete contrailfqname_;
  }
  if (contrailfqname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ContrailFqName>::GetOwningArena(contrailfqname);
    if (message_arena != submessage_arena) {
      contrailfqname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contrailfqname, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  contrailfqname_ = contrailfqname;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference.contrailFqName)
}

// -------------------------------------------------------------------

// RouteOriginOverride

// optional bool originOverride = 1;
inline bool RouteOriginOverride::_internal_has_originoverride() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RouteOriginOverride::has_originoverride() const {
  return _internal_has_originoverride();
}
inline void RouteOriginOverride::clear_originoverride() {
  originoverride_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool RouteOriginOverride::_internal_originoverride() const {
  return originoverride_;
}
inline bool RouteOriginOverride::originoverride() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride.originOverride)
  return _internal_originoverride();
}
inline void RouteOriginOverride::_internal_set_originoverride(bool value) {
  _has_bits_[0] |= 0x00000002u;
  originoverride_ = value;
}
inline void RouteOriginOverride::set_originoverride(bool value) {
  _internal_set_originoverride(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride.originOverride)
}

// optional string origin = 2;
inline bool RouteOriginOverride::_internal_has_origin() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RouteOriginOverride::has_origin() const {
  return _internal_has_origin();
}
inline void RouteOriginOverride::clear_origin() {
  origin_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RouteOriginOverride::origin() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride.origin)
  return _internal_origin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteOriginOverride::set_origin(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 origin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride.origin)
}
inline std::string* RouteOriginOverride::mutable_origin() {
  std::string* _s = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride.origin)
  return _s;
}
inline const std::string& RouteOriginOverride::_internal_origin() const {
  return origin_.Get();
}
inline void RouteOriginOverride::_internal_set_origin(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  origin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteOriginOverride::_internal_mutable_origin() {
  _has_bits_[0] |= 0x00000001u;
  return origin_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteOriginOverride::release_origin() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride.origin)
  if (!_internal_has_origin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return origin_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteOriginOverride::set_allocated_origin(std::string* origin) {
  if (origin != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  origin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), origin,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride.origin)
}

// -------------------------------------------------------------------

// RouteTarget

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool RouteTarget::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool RouteTarget::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& RouteTarget::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& RouteTarget::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.metadata)
  return _internal_metadata();
}
inline void RouteTarget::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* RouteTarget::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* RouteTarget::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* RouteTarget::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* RouteTarget::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.metadata)
  return _msg;
}
inline void RouteTarget::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec spec = 2;
inline bool RouteTarget::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool RouteTarget::has_spec() const {
  return _internal_has_spec();
}
inline void RouteTarget::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec& RouteTarget::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_RouteTargetSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec& RouteTarget::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.spec)
  return _internal_spec();
}
inline void RouteTarget::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* RouteTarget::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* RouteTarget::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* RouteTarget::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* RouteTarget::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.spec)
  return _msg;
}
inline void RouteTarget::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus status = 3;
inline bool RouteTarget::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool RouteTarget::has_status() const {
  return _internal_has_status();
}
inline void RouteTarget::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus& RouteTarget::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_RouteTargetStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus& RouteTarget::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.status)
  return _internal_status();
}
inline void RouteTarget::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* RouteTarget::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* RouteTarget::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* RouteTarget::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* RouteTarget::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.status)
  return _msg;
}
inline void RouteTarget::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget.status)
}

// -------------------------------------------------------------------

// RouteTargetList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool RouteTargetList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool RouteTargetList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& RouteTargetList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& RouteTargetList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.metadata)
  return _internal_metadata();
}
inline void RouteTargetList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* RouteTargetList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* RouteTargetList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* RouteTargetList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* RouteTargetList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.metadata)
  return _msg;
}
inline void RouteTargetList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget items = 2;
inline int RouteTargetList::_internal_items_size() const {
  return items_.size();
}
inline int RouteTargetList::items_size() const {
  return _internal_items_size();
}
inline void RouteTargetList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget* RouteTargetList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget >*
RouteTargetList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget& RouteTargetList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget& RouteTargetList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget* RouteTargetList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget* RouteTargetList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTarget >&
RouteTargetList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetList.items)
  return items_;
}

// -------------------------------------------------------------------

// RouteTargetReference

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
inline bool RouteTargetReference::_internal_has_resourcereference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || resourcereference_ != nullptr);
  return value;
}
inline bool RouteTargetReference::has_resourcereference() const {
  return _internal_has_resourcereference();
}
inline void RouteTargetReference::clear_resourcereference() {
  if (resourcereference_ != nullptr) resourcereference_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& RouteTargetReference::_internal_resourcereference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = resourcereference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& RouteTargetReference::resourcereference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.resourceReference)
  return _internal_resourcereference();
}
inline void RouteTargetReference::unsafe_arena_set_allocated_resourcereference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resourcereference_);
  }
  resourcereference_ = resourcereference;
  if (resourcereference) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.resourceReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* RouteTargetReference::release_resourcereference() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* RouteTargetReference::unsafe_arena_release_resourcereference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.resourceReference)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* RouteTargetReference::_internal_mutable_resourcereference() {
  _has_bits_[0] |= 0x00000001u;
  if (resourcereference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    resourcereference_ = p;
  }
  return resourcereference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* RouteTargetReference::mutable_resourcereference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_resourcereference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.resourceReference)
  return _msg;
}
inline void RouteTargetReference::set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resourcereference_;
  }
  if (resourcereference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(resourcereference);
    if (message_arena != submessage_arena) {
      resourcereference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resourcereference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resourcereference_ = resourcereference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.resourceReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes attributes = 2;
inline bool RouteTargetReference::_internal_has_attributes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || attributes_ != nullptr);
  return value;
}
inline bool RouteTargetReference::has_attributes() const {
  return _internal_has_attributes();
}
inline void RouteTargetReference::clear_attributes() {
  if (attributes_ != nullptr) attributes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes& RouteTargetReference::_internal_attributes() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_RouteTargetReferenceAttributes_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes& RouteTargetReference::attributes() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.attributes)
  return _internal_attributes();
}
inline void RouteTargetReference::unsafe_arena_set_allocated_attributes(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.attributes)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* RouteTargetReference::release_attributes() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* RouteTargetReference::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.attributes)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* RouteTargetReference::_internal_mutable_attributes() {
  _has_bits_[0] |= 0x00000002u;
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* RouteTargetReference::mutable_attributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.attributes)
  return _msg;
}
inline void RouteTargetReference::set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReferenceAttributes>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference.attributes)
}

// -------------------------------------------------------------------

// RouteTargetReferenceAttributes

// optional string importExport = 1;
inline bool RouteTargetReferenceAttributes::_internal_has_importexport() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RouteTargetReferenceAttributes::has_importexport() const {
  return _internal_has_importexport();
}
inline void RouteTargetReferenceAttributes::clear_importexport() {
  importexport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RouteTargetReferenceAttributes::importexport() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes.importExport)
  return _internal_importexport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteTargetReferenceAttributes::set_importexport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 importexport_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes.importExport)
}
inline std::string* RouteTargetReferenceAttributes::mutable_importexport() {
  std::string* _s = _internal_mutable_importexport();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes.importExport)
  return _s;
}
inline const std::string& RouteTargetReferenceAttributes::_internal_importexport() const {
  return importexport_.Get();
}
inline void RouteTargetReferenceAttributes::_internal_set_importexport(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  importexport_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteTargetReferenceAttributes::_internal_mutable_importexport() {
  _has_bits_[0] |= 0x00000001u;
  return importexport_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteTargetReferenceAttributes::release_importexport() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes.importExport)
  if (!_internal_has_importexport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return importexport_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteTargetReferenceAttributes::set_allocated_importexport(std::string* importexport) {
  if (importexport != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  importexport_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), importexport,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes.importExport)
}

// -------------------------------------------------------------------

// RouteTargetSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool RouteTargetSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool RouteTargetSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void RouteTargetSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& RouteTargetSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& RouteTargetSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec.commonSpec)
  return _internal_commonspec();
}
inline void RouteTargetSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* RouteTargetSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* RouteTargetSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* RouteTargetSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* RouteTargetSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec.commonSpec)
  return _msg;
}
inline void RouteTargetSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec.commonSpec)
}

// -------------------------------------------------------------------

// RouteTargetStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool RouteTargetStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool RouteTargetStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void RouteTargetStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& RouteTargetStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& RouteTargetStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus.commonStatus)
  return _internal_commonstatus();
}
inline void RouteTargetStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* RouteTargetStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* RouteTargetStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* RouteTargetStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* RouteTargetStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus.commonStatus)
  return _msg;
}
inline void RouteTargetStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus.commonStatus)
}

// -------------------------------------------------------------------

// RoutingInstance

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool RoutingInstance::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool RoutingInstance::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& RoutingInstance::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& RoutingInstance::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.metadata)
  return _internal_metadata();
}
inline void RoutingInstance::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* RoutingInstance::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* RoutingInstance::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* RoutingInstance::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* RoutingInstance::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.metadata)
  return _msg;
}
inline void RoutingInstance::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec spec = 2;
inline bool RoutingInstance::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool RoutingInstance::has_spec() const {
  return _internal_has_spec();
}
inline void RoutingInstance::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec& RoutingInstance::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_RoutingInstanceSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec& RoutingInstance::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.spec)
  return _internal_spec();
}
inline void RoutingInstance::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* RoutingInstance::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* RoutingInstance::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* RoutingInstance::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* RoutingInstance::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.spec)
  return _msg;
}
inline void RoutingInstance::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus status = 3;
inline bool RoutingInstance::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool RoutingInstance::has_status() const {
  return _internal_has_status();
}
inline void RoutingInstance::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus& RoutingInstance::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_RoutingInstanceStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus& RoutingInstance::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.status)
  return _internal_status();
}
inline void RoutingInstance::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* RoutingInstance::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* RoutingInstance::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* RoutingInstance::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* RoutingInstance::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.status)
  return _msg;
}
inline void RoutingInstance::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance.status)
}

// -------------------------------------------------------------------

// RoutingInstanceList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool RoutingInstanceList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool RoutingInstanceList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& RoutingInstanceList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& RoutingInstanceList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.metadata)
  return _internal_metadata();
}
inline void RoutingInstanceList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* RoutingInstanceList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* RoutingInstanceList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* RoutingInstanceList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* RoutingInstanceList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.metadata)
  return _msg;
}
inline void RoutingInstanceList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance items = 2;
inline int RoutingInstanceList::_internal_items_size() const {
  return items_.size();
}
inline int RoutingInstanceList::items_size() const {
  return _internal_items_size();
}
inline void RoutingInstanceList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance* RoutingInstanceList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance >*
RoutingInstanceList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance& RoutingInstanceList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance& RoutingInstanceList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance* RoutingInstanceList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance* RoutingInstanceList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstance >&
RoutingInstanceList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceList.items)
  return items_;
}

// -------------------------------------------------------------------

// RoutingInstanceReference

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
inline bool RoutingInstanceReference::_internal_has_resourcereference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || resourcereference_ != nullptr);
  return value;
}
inline bool RoutingInstanceReference::has_resourcereference() const {
  return _internal_has_resourcereference();
}
inline void RoutingInstanceReference::clear_resourcereference() {
  if (resourcereference_ != nullptr) resourcereference_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& RoutingInstanceReference::_internal_resourcereference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = resourcereference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& RoutingInstanceReference::resourcereference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.resourceReference)
  return _internal_resourcereference();
}
inline void RoutingInstanceReference::unsafe_arena_set_allocated_resourcereference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resourcereference_);
  }
  resourcereference_ = resourcereference;
  if (resourcereference) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.resourceReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* RoutingInstanceReference::release_resourcereference() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* RoutingInstanceReference::unsafe_arena_release_resourcereference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.resourceReference)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* RoutingInstanceReference::_internal_mutable_resourcereference() {
  _has_bits_[0] |= 0x00000001u;
  if (resourcereference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    resourcereference_ = p;
  }
  return resourcereference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* RoutingInstanceReference::mutable_resourcereference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_resourcereference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.resourceReference)
  return _msg;
}
inline void RoutingInstanceReference::set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resourcereference_;
  }
  if (resourcereference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(resourcereference);
    if (message_arena != submessage_arena) {
      resourcereference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resourcereference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resourcereference_ = resourcereference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.resourceReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule attributes = 2;
inline bool RoutingInstanceReference::_internal_has_attributes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || attributes_ != nullptr);
  return value;
}
inline bool RoutingInstanceReference::has_attributes() const {
  return _internal_has_attributes();
}
inline void RoutingInstanceReference::clear_attributes() {
  if (attributes_ != nullptr) attributes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule& RoutingInstanceReference::_internal_attributes() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_PolicyBasedForwardingRule_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule& RoutingInstanceReference::attributes() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.attributes)
  return _internal_attributes();
}
inline void RoutingInstanceReference::unsafe_arena_set_allocated_attributes(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.attributes)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* RoutingInstanceReference::release_attributes() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* RoutingInstanceReference::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.attributes)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* RoutingInstanceReference::_internal_mutable_attributes() {
  _has_bits_[0] |= 0x00000002u;
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* RoutingInstanceReference::mutable_attributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.attributes)
  return _msg;
}
inline void RoutingInstanceReference::set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::PolicyBasedForwardingRule>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference.attributes)
}

// -------------------------------------------------------------------

// RoutingInstanceSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool RoutingInstanceSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool RoutingInstanceSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void RoutingInstanceSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& RoutingInstanceSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& RoutingInstanceSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.commonSpec)
  return _internal_commonspec();
}
inline void RoutingInstanceSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* RoutingInstanceSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* RoutingInstanceSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* RoutingInstanceSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* RoutingInstanceSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.commonSpec)
  return _msg;
}
inline void RoutingInstanceSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.commonSpec)
}

// optional .k8s.io.api.core.v1.ObjectReference parent = 2;
inline bool RoutingInstanceSpec::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || parent_ != nullptr);
  return value;
}
inline bool RoutingInstanceSpec::has_parent() const {
  return _internal_has_parent();
}
inline const ::k8s::io::api::core::v1::ObjectReference& RoutingInstanceSpec::_internal_parent() const {
  const ::k8s::io::api::core::v1::ObjectReference* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::api::core::v1::ObjectReference&>(
      ::k8s::io::api::core::v1::_ObjectReference_default_instance_);
}
inline const ::k8s::io::api::core::v1::ObjectReference& RoutingInstanceSpec::parent() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.parent)
  return _internal_parent();
}
inline void RoutingInstanceSpec::unsafe_arena_set_allocated_parent(
    ::k8s::io::api::core::v1::ObjectReference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.parent)
}
inline ::k8s::io::api::core::v1::ObjectReference* RoutingInstanceSpec::release_parent() {
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* RoutingInstanceSpec::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.parent)
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* RoutingInstanceSpec::_internal_mutable_parent() {
  _has_bits_[0] |= 0x00000002u;
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::api::core::v1::ObjectReference>(GetArenaForAllocation());
    parent_ = p;
  }
  return parent_;
}
inline ::k8s::io::api::core::v1::ObjectReference* RoutingInstanceSpec::mutable_parent() {
  ::k8s::io::api::core::v1::ObjectReference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.parent)
  return _msg;
}
inline void RoutingInstanceSpec::set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent));
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.parent)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference routeTargetReferences = 3;
inline int RoutingInstanceSpec::_internal_routetargetreferences_size() const {
  return routetargetreferences_.size();
}
inline int RoutingInstanceSpec::routetargetreferences_size() const {
  return _internal_routetargetreferences_size();
}
inline void RoutingInstanceSpec::clear_routetargetreferences() {
  routetargetreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* RoutingInstanceSpec::mutable_routetargetreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.routeTargetReferences)
  return routetargetreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference >*
RoutingInstanceSpec::mutable_routetargetreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.routeTargetReferences)
  return &routetargetreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& RoutingInstanceSpec::_internal_routetargetreferences(int index) const {
  return routetargetreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& RoutingInstanceSpec::routetargetreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.routeTargetReferences)
  return _internal_routetargetreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* RoutingInstanceSpec::_internal_add_routetargetreferences() {
  return routetargetreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* RoutingInstanceSpec::add_routetargetreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* _add = _internal_add_routetargetreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.routeTargetReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference >&
RoutingInstanceSpec::routetargetreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec.routeTargetReferences)
  return routetargetreferences_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RoutingInstanceStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool RoutingInstanceStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool RoutingInstanceStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void RoutingInstanceStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& RoutingInstanceStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& RoutingInstanceStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.commonStatus)
  return _internal_commonstatus();
}
inline void RoutingInstanceStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* RoutingInstanceStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* RoutingInstanceStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* RoutingInstanceStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* RoutingInstanceStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.commonStatus)
  return _msg;
}
inline void RoutingInstanceStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.commonStatus)
}

// optional bool isDefault = 2;
inline bool RoutingInstanceStatus::_internal_has_isdefault() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoutingInstanceStatus::has_isdefault() const {
  return _internal_has_isdefault();
}
inline void RoutingInstanceStatus::clear_isdefault() {
  isdefault_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool RoutingInstanceStatus::_internal_isdefault() const {
  return isdefault_;
}
inline bool RoutingInstanceStatus::isdefault() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.isDefault)
  return _internal_isdefault();
}
inline void RoutingInstanceStatus::_internal_set_isdefault(bool value) {
  _has_bits_[0] |= 0x00000004u;
  isdefault_ = value;
}
inline void RoutingInstanceStatus::set_isdefault(bool value) {
  _internal_set_isdefault(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.isDefault)
}

// optional bool routingInstanceFabricSNAT = 3;
inline bool RoutingInstanceStatus::_internal_has_routinginstancefabricsnat() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RoutingInstanceStatus::has_routinginstancefabricsnat() const {
  return _internal_has_routinginstancefabricsnat();
}
inline void RoutingInstanceStatus::clear_routinginstancefabricsnat() {
  routinginstancefabricsnat_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RoutingInstanceStatus::_internal_routinginstancefabricsnat() const {
  return routinginstancefabricsnat_;
}
inline bool RoutingInstanceStatus::routinginstancefabricsnat() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.routingInstanceFabricSNAT)
  return _internal_routinginstancefabricsnat();
}
inline void RoutingInstanceStatus::_internal_set_routinginstancefabricsnat(bool value) {
  _has_bits_[0] |= 0x00000008u;
  routinginstancefabricsnat_ = value;
}
inline void RoutingInstanceStatus::set_routinginstancefabricsnat(bool value) {
  _internal_set_routinginstancefabricsnat(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.routingInstanceFabricSNAT)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference defaultRouteTargetReference = 4;
inline bool RoutingInstanceStatus::_internal_has_defaultroutetargetreference() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || defaultroutetargetreference_ != nullptr);
  return value;
}
inline bool RoutingInstanceStatus::has_defaultroutetargetreference() const {
  return _internal_has_defaultroutetargetreference();
}
inline void RoutingInstanceStatus::clear_defaultroutetargetreference() {
  if (defaultroutetargetreference_ != nullptr) defaultroutetargetreference_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& RoutingInstanceStatus::_internal_defaultroutetargetreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* p = defaultroutetargetreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_RouteTargetReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& RoutingInstanceStatus::defaultroutetargetreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.defaultRouteTargetReference)
  return _internal_defaultroutetargetreference();
}
inline void RoutingInstanceStatus::unsafe_arena_set_allocated_defaultroutetargetreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* defaultroutetargetreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(defaultroutetargetreference_);
  }
  defaultroutetargetreference_ = defaultroutetargetreference;
  if (defaultroutetargetreference) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.defaultRouteTargetReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* RoutingInstanceStatus::release_defaultroutetargetreference() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* temp = defaultroutetargetreference_;
  defaultroutetargetreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* RoutingInstanceStatus::unsafe_arena_release_defaultroutetargetreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.defaultRouteTargetReference)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* temp = defaultroutetargetreference_;
  defaultroutetargetreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* RoutingInstanceStatus::_internal_mutable_defaultroutetargetreference() {
  _has_bits_[0] |= 0x00000002u;
  if (defaultroutetargetreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference>(GetArenaForAllocation());
    defaultroutetargetreference_ = p;
  }
  return defaultroutetargetreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* RoutingInstanceStatus::mutable_defaultroutetargetreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* _msg = _internal_mutable_defaultroutetargetreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.defaultRouteTargetReference)
  return _msg;
}
inline void RoutingInstanceStatus::set_allocated_defaultroutetargetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* defaultroutetargetreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete defaultroutetargetreference_;
  }
  if (defaultroutetargetreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference>::GetOwningArena(defaultroutetargetreference);
    if (message_arena != submessage_arena) {
      defaultroutetargetreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, defaultroutetargetreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  defaultroutetargetreference_ = defaultroutetargetreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.defaultRouteTargetReference)
}

// map<string, .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList> virtualNetworkRouterRouteTargetReferences = 5;
inline int RoutingInstanceStatus::_internal_virtualnetworkrouterroutetargetreferences_size() const {
  return virtualnetworkrouterroutetargetreferences_.size();
}
inline int RoutingInstanceStatus::virtualnetworkrouterroutetargetreferences_size() const {
  return _internal_virtualnetworkrouterroutetargetreferences_size();
}
inline void RoutingInstanceStatus::clear_virtualnetworkrouterroutetargetreferences() {
  virtualnetworkrouterroutetargetreferences_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList >&
RoutingInstanceStatus::_internal_virtualnetworkrouterroutetargetreferences() const {
  return virtualnetworkrouterroutetargetreferences_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList >&
RoutingInstanceStatus::virtualnetworkrouterroutetargetreferences() const {
  // @@protoc_insertion_point(field_map:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.virtualNetworkRouterRouteTargetReferences)
  return _internal_virtualnetworkrouterroutetargetreferences();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList >*
RoutingInstanceStatus::_internal_mutable_virtualnetworkrouterroutetargetreferences() {
  return virtualnetworkrouterroutetargetreferences_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouteTargetReferenceList >*
RoutingInstanceStatus::mutable_virtualnetworkrouterroutetargetreferences() {
  // @@protoc_insertion_point(field_mutable_map:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.virtualNetworkRouterRouteTargetReferences)
  return _internal_mutable_virtualnetworkrouterroutetargetreferences();
}

// -------------------------------------------------------------------

// Subnet

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool Subnet::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool Subnet::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& Subnet::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& Subnet::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.metadata)
  return _internal_metadata();
}
inline void Subnet::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Subnet::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Subnet::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Subnet::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Subnet::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.metadata)
  return _msg;
}
inline void Subnet::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec spec = 2;
inline bool Subnet::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool Subnet::has_spec() const {
  return _internal_has_spec();
}
inline void Subnet::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec& Subnet::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_SubnetSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec& Subnet::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.spec)
  return _internal_spec();
}
inline void Subnet::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* Subnet::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* Subnet::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* Subnet::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* Subnet::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.spec)
  return _msg;
}
inline void Subnet::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus status = 3;
inline bool Subnet::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool Subnet::has_status() const {
  return _internal_has_status();
}
inline void Subnet::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus& Subnet::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_SubnetStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus& Subnet::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.status)
  return _internal_status();
}
inline void Subnet::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* Subnet::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* Subnet::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* Subnet::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* Subnet::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.status)
  return _msg;
}
inline void Subnet::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::SubnetStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet.status)
}

// -------------------------------------------------------------------

// SubnetList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool SubnetList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool SubnetList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& SubnetList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& SubnetList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.metadata)
  return _internal_metadata();
}
inline void SubnetList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* SubnetList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* SubnetList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* SubnetList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* SubnetList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.metadata)
  return _msg;
}
inline void SubnetList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet items = 2;
inline int SubnetList::_internal_items_size() const {
  return items_.size();
}
inline int SubnetList::items_size() const {
  return _internal_items_size();
}
inline void SubnetList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet* SubnetList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet >*
SubnetList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet& SubnetList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet& SubnetList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet* SubnetList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet* SubnetList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Subnet >&
SubnetList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetList.items)
  return items_;
}

// -------------------------------------------------------------------

// SubnetReference

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;
inline bool SubnetReference::_internal_has_resourcereference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || resourcereference_ != nullptr);
  return value;
}
inline bool SubnetReference::has_resourcereference() const {
  return _internal_has_resourcereference();
}
inline void SubnetReference::clear_resourcereference() {
  if (resourcereference_ != nullptr) resourcereference_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& SubnetReference::_internal_resourcereference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = resourcereference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& SubnetReference::resourcereference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.resourceReference)
  return _internal_resourcereference();
}
inline void SubnetReference::unsafe_arena_set_allocated_resourcereference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resourcereference_);
  }
  resourcereference_ = resourcereference;
  if (resourcereference) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.resourceReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* SubnetReference::release_resourcereference() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* SubnetReference::unsafe_arena_release_resourcereference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.resourceReference)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = resourcereference_;
  resourcereference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* SubnetReference::_internal_mutable_resourcereference() {
  _has_bits_[0] |= 0x00000001u;
  if (resourcereference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    resourcereference_ = p;
  }
  return resourcereference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* SubnetReference::mutable_resourcereference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_resourcereference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.resourceReference)
  return _msg;
}
inline void SubnetReference::set_allocated_resourcereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* resourcereference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resourcereference_;
  }
  if (resourcereference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(resourcereference);
    if (message_arena != submessage_arena) {
      resourcereference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resourcereference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resourcereference_ = resourcereference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.resourceReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes attributes = 2;
inline bool SubnetReference::_internal_has_attributes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || attributes_ != nullptr);
  return value;
}
inline bool SubnetReference::has_attributes() const {
  return _internal_has_attributes();
}
inline void SubnetReference::clear_attributes() {
  if (attributes_ != nullptr) attributes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes& SubnetReference::_internal_attributes() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_BGPSessionIPAttributes_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes& SubnetReference::attributes() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.attributes)
  return _internal_attributes();
}
inline void SubnetReference::unsafe_arena_set_allocated_attributes(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.attributes)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* SubnetReference::release_attributes() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* SubnetReference::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.attributes)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* SubnetReference::_internal_mutable_attributes() {
  _has_bits_[0] |= 0x00000002u;
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* SubnetReference::mutable_attributes() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.attributes)
  return _msg;
}
inline void SubnetReference::set_allocated_attributes(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::BGPSessionIPAttributes>::GetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference.attributes)
}

// -------------------------------------------------------------------

// SubnetSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool SubnetSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool SubnetSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void SubnetSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& SubnetSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& SubnetSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.commonSpec)
  return _internal_commonspec();
}
inline void SubnetSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* SubnetSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* SubnetSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.commonSpec)
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* SubnetSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000010u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* SubnetSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.commonSpec)
  return _msg;
}
inline void SubnetSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.commonSpec)
}

// optional string cidr = 3;
inline bool SubnetSpec::_internal_has_cidr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubnetSpec::has_cidr() const {
  return _internal_has_cidr();
}
inline void SubnetSpec::clear_cidr() {
  cidr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubnetSpec::cidr() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.cidr)
  return _internal_cidr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubnetSpec::set_cidr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cidr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.cidr)
}
inline std::string* SubnetSpec::mutable_cidr() {
  std::string* _s = _internal_mutable_cidr();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.cidr)
  return _s;
}
inline const std::string& SubnetSpec::_internal_cidr() const {
  return cidr_.Get();
}
inline void SubnetSpec::_internal_set_cidr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cidr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubnetSpec::_internal_mutable_cidr() {
  _has_bits_[0] |= 0x00000001u;
  return cidr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubnetSpec::release_cidr() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.cidr)
  if (!_internal_has_cidr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cidr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubnetSpec::set_allocated_cidr(std::string* cidr) {
  if (cidr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cidr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cidr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.cidr)
}

// optional string defaultGateway = 4;
inline bool SubnetSpec::_internal_has_defaultgateway() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SubnetSpec::has_defaultgateway() const {
  return _internal_has_defaultgateway();
}
inline void SubnetSpec::clear_defaultgateway() {
  defaultgateway_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SubnetSpec::defaultgateway() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.defaultGateway)
  return _internal_defaultgateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubnetSpec::set_defaultgateway(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 defaultgateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.defaultGateway)
}
inline std::string* SubnetSpec::mutable_defaultgateway() {
  std::string* _s = _internal_mutable_defaultgateway();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.defaultGateway)
  return _s;
}
inline const std::string& SubnetSpec::_internal_defaultgateway() const {
  return defaultgateway_.Get();
}
inline void SubnetSpec::_internal_set_defaultgateway(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  defaultgateway_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubnetSpec::_internal_mutable_defaultgateway() {
  _has_bits_[0] |= 0x00000002u;
  return defaultgateway_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubnetSpec::release_defaultgateway() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.defaultGateway)
  if (!_internal_has_defaultgateway()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return defaultgateway_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubnetSpec::set_allocated_defaultgateway(std::string* defaultgateway) {
  if (defaultgateway != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  defaultgateway_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), defaultgateway,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.defaultGateway)
}

// repeated string dnsNameservers = 5;
inline int SubnetSpec::_internal_dnsnameservers_size() const {
  return dnsnameservers_.size();
}
inline int SubnetSpec::dnsnameservers_size() const {
  return _internal_dnsnameservers_size();
}
inline void SubnetSpec::clear_dnsnameservers() {
  dnsnameservers_.Clear();
}
inline std::string* SubnetSpec::add_dnsnameservers() {
  std::string* _s = _internal_add_dnsnameservers();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
  return _s;
}
inline const std::string& SubnetSpec::_internal_dnsnameservers(int index) const {
  return dnsnameservers_.Get(index);
}
inline const std::string& SubnetSpec::dnsnameservers(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
  return _internal_dnsnameservers(index);
}
inline std::string* SubnetSpec::mutable_dnsnameservers(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
  return dnsnameservers_.Mutable(index);
}
inline void SubnetSpec::set_dnsnameservers(int index, const std::string& value) {
  dnsnameservers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
}
inline void SubnetSpec::set_dnsnameservers(int index, std::string&& value) {
  dnsnameservers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
}
inline void SubnetSpec::set_dnsnameservers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dnsnameservers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
}
inline void SubnetSpec::set_dnsnameservers(int index, const char* value, size_t size) {
  dnsnameservers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
}
inline std::string* SubnetSpec::_internal_add_dnsnameservers() {
  return dnsnameservers_.Add();
}
inline void SubnetSpec::add_dnsnameservers(const std::string& value) {
  dnsnameservers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
}
inline void SubnetSpec::add_dnsnameservers(std::string&& value) {
  dnsnameservers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
}
inline void SubnetSpec::add_dnsnameservers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dnsnameservers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
}
inline void SubnetSpec::add_dnsnameservers(const char* value, size_t size) {
  dnsnameservers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubnetSpec::dnsnameservers() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
  return dnsnameservers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubnetSpec::mutable_dnsnameservers() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.dnsNameservers)
  return &dnsnameservers_;
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range ranges = 6;
inline int SubnetSpec::_internal_ranges_size() const {
  return ranges_.size();
}
inline int SubnetSpec::ranges_size() const {
  return _internal_ranges_size();
}
inline void SubnetSpec::clear_ranges() {
  ranges_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range* SubnetSpec::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.ranges)
  return ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range >*
SubnetSpec::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.ranges)
  return &ranges_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range& SubnetSpec::_internal_ranges(int index) const {
  return ranges_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range& SubnetSpec::ranges(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.ranges)
  return _internal_ranges(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range* SubnetSpec::_internal_add_ranges() {
  return ranges_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range* SubnetSpec::add_ranges() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range* _add = _internal_add_ranges();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Range >&
SubnetSpec::ranges() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.ranges)
  return ranges_;
}

// optional bool disableBGPaaSIPAutoAllocation = 7;
inline bool SubnetSpec::_internal_has_disablebgpaasipautoallocation() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SubnetSpec::has_disablebgpaasipautoallocation() const {
  return _internal_has_disablebgpaasipautoallocation();
}
inline void SubnetSpec::clear_disablebgpaasipautoallocation() {
  disablebgpaasipautoallocation_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool SubnetSpec::_internal_disablebgpaasipautoallocation() const {
  return disablebgpaasipautoallocation_;
}
inline bool SubnetSpec::disablebgpaasipautoallocation() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.disableBGPaaSIPAutoAllocation)
  return _internal_disablebgpaasipautoallocation();
}
inline void SubnetSpec::_internal_set_disablebgpaasipautoallocation(bool value) {
  _has_bits_[0] |= 0x00000020u;
  disablebgpaasipautoallocation_ = value;
}
inline void SubnetSpec::set_disablebgpaasipautoallocation(bool value) {
  _internal_set_disablebgpaasipautoallocation(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.disableBGPaaSIPAutoAllocation)
}

// optional string bgpaasPrimaryIP = 8;
inline bool SubnetSpec::_internal_has_bgpaasprimaryip() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SubnetSpec::has_bgpaasprimaryip() const {
  return _internal_has_bgpaasprimaryip();
}
inline void SubnetSpec::clear_bgpaasprimaryip() {
  bgpaasprimaryip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SubnetSpec::bgpaasprimaryip() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasPrimaryIP)
  return _internal_bgpaasprimaryip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubnetSpec::set_bgpaasprimaryip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 bgpaasprimaryip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasPrimaryIP)
}
inline std::string* SubnetSpec::mutable_bgpaasprimaryip() {
  std::string* _s = _internal_mutable_bgpaasprimaryip();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasPrimaryIP)
  return _s;
}
inline const std::string& SubnetSpec::_internal_bgpaasprimaryip() const {
  return bgpaasprimaryip_.Get();
}
inline void SubnetSpec::_internal_set_bgpaasprimaryip(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  bgpaasprimaryip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubnetSpec::_internal_mutable_bgpaasprimaryip() {
  _has_bits_[0] |= 0x00000004u;
  return bgpaasprimaryip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubnetSpec::release_bgpaasprimaryip() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasPrimaryIP)
  if (!_internal_has_bgpaasprimaryip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return bgpaasprimaryip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubnetSpec::set_allocated_bgpaasprimaryip(std::string* bgpaasprimaryip) {
  if (bgpaasprimaryip != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  bgpaasprimaryip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bgpaasprimaryip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasPrimaryIP)
}

// optional string bgpaasSecondaryIP = 9;
inline bool SubnetSpec::_internal_has_bgpaassecondaryip() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SubnetSpec::has_bgpaassecondaryip() const {
  return _internal_has_bgpaassecondaryip();
}
inline void SubnetSpec::clear_bgpaassecondaryip() {
  bgpaassecondaryip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SubnetSpec::bgpaassecondaryip() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasSecondaryIP)
  return _internal_bgpaassecondaryip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubnetSpec::set_bgpaassecondaryip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 bgpaassecondaryip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasSecondaryIP)
}
inline std::string* SubnetSpec::mutable_bgpaassecondaryip() {
  std::string* _s = _internal_mutable_bgpaassecondaryip();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasSecondaryIP)
  return _s;
}
inline const std::string& SubnetSpec::_internal_bgpaassecondaryip() const {
  return bgpaassecondaryip_.Get();
}
inline void SubnetSpec::_internal_set_bgpaassecondaryip(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  bgpaassecondaryip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubnetSpec::_internal_mutable_bgpaassecondaryip() {
  _has_bits_[0] |= 0x00000008u;
  return bgpaassecondaryip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubnetSpec::release_bgpaassecondaryip() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasSecondaryIP)
  if (!_internal_has_bgpaassecondaryip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return bgpaassecondaryip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubnetSpec::set_allocated_bgpaassecondaryip(std::string* bgpaassecondaryip) {
  if (bgpaassecondaryip != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  bgpaassecondaryip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bgpaassecondaryip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec.bgpaasSecondaryIP)
}

// -------------------------------------------------------------------

// SubnetStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool SubnetStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool SubnetStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void SubnetStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& SubnetStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& SubnetStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.commonStatus)
  return _internal_commonstatus();
}
inline void SubnetStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* SubnetStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* SubnetStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.commonStatus)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* SubnetStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000002u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* SubnetStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.commonStatus)
  return _msg;
}
inline void SubnetStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.commonStatus)
}

// optional int64 ipCount = 2;
inline bool SubnetStatus::_internal_has_ipcount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SubnetStatus::has_ipcount() const {
  return _internal_has_ipcount();
}
inline void SubnetStatus::clear_ipcount() {
  ipcount_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SubnetStatus::_internal_ipcount() const {
  return ipcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SubnetStatus::ipcount() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.ipCount)
  return _internal_ipcount();
}
inline void SubnetStatus::_internal_set_ipcount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  ipcount_ = value;
}
inline void SubnetStatus::set_ipcount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ipcount(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.ipCount)
}

// optional string allocationUsage = 3;
inline bool SubnetStatus::_internal_has_allocationusage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubnetStatus::has_allocationusage() const {
  return _internal_has_allocationusage();
}
inline void SubnetStatus::clear_allocationusage() {
  allocationusage_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubnetStatus::allocationusage() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.allocationUsage)
  return _internal_allocationusage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubnetStatus::set_allocationusage(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 allocationusage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.allocationUsage)
}
inline std::string* SubnetStatus::mutable_allocationusage() {
  std::string* _s = _internal_mutable_allocationusage();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.allocationUsage)
  return _s;
}
inline const std::string& SubnetStatus::_internal_allocationusage() const {
  return allocationusage_.Get();
}
inline void SubnetStatus::_internal_set_allocationusage(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  allocationusage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubnetStatus::_internal_mutable_allocationusage() {
  _has_bits_[0] |= 0x00000001u;
  return allocationusage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubnetStatus::release_allocationusage() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.allocationUsage)
  if (!_internal_has_allocationusage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return allocationusage_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubnetStatus::set_allocated_allocationusage(std::string* allocationusage) {
  if (allocationusage != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  allocationusage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), allocationusage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus.allocationUsage)
}

// -------------------------------------------------------------------

// Tag

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool Tag::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool Tag::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& Tag::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& Tag::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.metadata)
  return _internal_metadata();
}
inline void Tag::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Tag::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Tag::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Tag::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Tag::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.metadata)
  return _msg;
}
inline void Tag::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec spec = 2;
inline bool Tag::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool Tag::has_spec() const {
  return _internal_has_spec();
}
inline void Tag::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec& Tag::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_TagSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec& Tag::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.spec)
  return _internal_spec();
}
inline void Tag::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* Tag::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* Tag::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* Tag::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* Tag::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.spec)
  return _msg;
}
inline void Tag::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus status = 3;
inline bool Tag::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool Tag::has_status() const {
  return _internal_has_status();
}
inline void Tag::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus& Tag::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_TagStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus& Tag::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.status)
  return _internal_status();
}
inline void Tag::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* Tag::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* Tag::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* Tag::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* Tag::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.status)
  return _msg;
}
inline void Tag::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag.status)
}

// -------------------------------------------------------------------

// TagList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool TagList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool TagList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& TagList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& TagList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.metadata)
  return _internal_metadata();
}
inline void TagList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* TagList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* TagList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* TagList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* TagList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.metadata)
  return _msg;
}
inline void TagList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag items = 2;
inline int TagList::_internal_items_size() const {
  return items_.size();
}
inline int TagList::items_size() const {
  return _internal_items_size();
}
inline void TagList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag* TagList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag >*
TagList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag& TagList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag& TagList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag* TagList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag* TagList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::Tag >&
TagList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagList.items)
  return items_;
}

// -------------------------------------------------------------------

// TagSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool TagSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool TagSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void TagSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& TagSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& TagSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.commonSpec)
  return _internal_commonspec();
}
inline void TagSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* TagSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* TagSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.commonSpec)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* TagSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000004u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* TagSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.commonSpec)
  return _msg;
}
inline void TagSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.commonSpec)
}

// optional string tagTypeName = 2;
inline bool TagSpec::_internal_has_tagtypename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TagSpec::has_tagtypename() const {
  return _internal_has_tagtypename();
}
inline void TagSpec::clear_tagtypename() {
  tagtypename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TagSpec::tagtypename() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeName)
  return _internal_tagtypename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagSpec::set_tagtypename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tagtypename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeName)
}
inline std::string* TagSpec::mutable_tagtypename() {
  std::string* _s = _internal_mutable_tagtypename();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeName)
  return _s;
}
inline const std::string& TagSpec::_internal_tagtypename() const {
  return tagtypename_.Get();
}
inline void TagSpec::_internal_set_tagtypename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tagtypename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagSpec::_internal_mutable_tagtypename() {
  _has_bits_[0] |= 0x00000001u;
  return tagtypename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagSpec::release_tagtypename() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeName)
  if (!_internal_has_tagtypename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tagtypename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagSpec::set_allocated_tagtypename(std::string* tagtypename) {
  if (tagtypename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tagtypename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagtypename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeName)
}

// optional string tagValue = 3;
inline bool TagSpec::_internal_has_tagvalue() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TagSpec::has_tagvalue() const {
  return _internal_has_tagvalue();
}
inline void TagSpec::clear_tagvalue() {
  tagvalue_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TagSpec::tagvalue() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagValue)
  return _internal_tagvalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagSpec::set_tagvalue(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 tagvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagValue)
}
inline std::string* TagSpec::mutable_tagvalue() {
  std::string* _s = _internal_mutable_tagvalue();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagValue)
  return _s;
}
inline const std::string& TagSpec::_internal_tagvalue() const {
  return tagvalue_.Get();
}
inline void TagSpec::_internal_set_tagvalue(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tagvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagSpec::_internal_mutable_tagvalue() {
  _has_bits_[0] |= 0x00000002u;
  return tagvalue_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagSpec::release_tagvalue() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagValue)
  if (!_internal_has_tagvalue()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tagvalue_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagSpec::set_allocated_tagvalue(std::string* tagvalue) {
  if (tagvalue != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tagvalue_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagvalue,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagValue)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagTypeReference = 4;
inline bool TagSpec::_internal_has_tagtypereference() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || tagtypereference_ != nullptr);
  return value;
}
inline bool TagSpec::has_tagtypereference() const {
  return _internal_has_tagtypereference();
}
inline void TagSpec::clear_tagtypereference() {
  if (tagtypereference_ != nullptr) tagtypereference_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& TagSpec::_internal_tagtypereference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = tagtypereference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& TagSpec::tagtypereference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeReference)
  return _internal_tagtypereference();
}
inline void TagSpec::unsafe_arena_set_allocated_tagtypereference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* tagtypereference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tagtypereference_);
  }
  tagtypereference_ = tagtypereference;
  if (tagtypereference) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* TagSpec::release_tagtypereference() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = tagtypereference_;
  tagtypereference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* TagSpec::unsafe_arena_release_tagtypereference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeReference)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = tagtypereference_;
  tagtypereference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* TagSpec::_internal_mutable_tagtypereference() {
  _has_bits_[0] |= 0x00000008u;
  if (tagtypereference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    tagtypereference_ = p;
  }
  return tagtypereference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* TagSpec::mutable_tagtypereference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_tagtypereference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeReference)
  return _msg;
}
inline void TagSpec::set_allocated_tagtypereference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* tagtypereference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tagtypereference_;
  }
  if (tagtypereference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(tagtypereference);
    if (message_arena != submessage_arena) {
      tagtypereference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tagtypereference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tagtypereference_ = tagtypereference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec.tagTypeReference)
}

// -------------------------------------------------------------------

// TagStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool TagStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool TagStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void TagStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& TagStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& TagStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.commonStatus)
  return _internal_commonstatus();
}
inline void TagStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* TagStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* TagStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.commonStatus)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* TagStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000002u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* TagStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.commonStatus)
  return _msg;
}
inline void TagStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.commonStatus)
}

// optional string tagId = 2;
inline bool TagStatus::_internal_has_tagid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TagStatus::has_tagid() const {
  return _internal_has_tagid();
}
inline void TagStatus::clear_tagid() {
  tagid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TagStatus::tagid() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.tagId)
  return _internal_tagid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagStatus::set_tagid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tagid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.tagId)
}
inline std::string* TagStatus::mutable_tagid() {
  std::string* _s = _internal_mutable_tagid();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.tagId)
  return _s;
}
inline const std::string& TagStatus::_internal_tagid() const {
  return tagid_.Get();
}
inline void TagStatus::_internal_set_tagid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tagid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagStatus::_internal_mutable_tagid() {
  _has_bits_[0] |= 0x00000001u;
  return tagid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagStatus::release_tagid() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.tagId)
  if (!_internal_has_tagid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tagid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagStatus::set_allocated_tagid(std::string* tagid) {
  if (tagid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tagid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus.tagId)
}

// -------------------------------------------------------------------

// TagType

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool TagType::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool TagType::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& TagType::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& TagType::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.metadata)
  return _internal_metadata();
}
inline void TagType::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* TagType::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* TagType::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* TagType::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* TagType::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.metadata)
  return _msg;
}
inline void TagType::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec spec = 2;
inline bool TagType::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool TagType::has_spec() const {
  return _internal_has_spec();
}
inline void TagType::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec& TagType::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_TagTypeSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec& TagType::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.spec)
  return _internal_spec();
}
inline void TagType::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* TagType::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* TagType::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* TagType::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* TagType::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.spec)
  return _msg;
}
inline void TagType::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus status = 3;
inline bool TagType::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool TagType::has_status() const {
  return _internal_has_status();
}
inline void TagType::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus& TagType::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_TagTypeStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus& TagType::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.status)
  return _internal_status();
}
inline void TagType::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* TagType::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* TagType::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* TagType::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* TagType::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.status)
  return _msg;
}
inline void TagType::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagTypeStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType.status)
}

// -------------------------------------------------------------------

// TagTypeList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool TagTypeList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool TagTypeList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& TagTypeList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& TagTypeList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.metadata)
  return _internal_metadata();
}
inline void TagTypeList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* TagTypeList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* TagTypeList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* TagTypeList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* TagTypeList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.metadata)
  return _msg;
}
inline void TagTypeList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType items = 2;
inline int TagTypeList::_internal_items_size() const {
  return items_.size();
}
inline int TagTypeList::items_size() const {
  return _internal_items_size();
}
inline void TagTypeList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType* TagTypeList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType >*
TagTypeList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType& TagTypeList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType& TagTypeList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType* TagTypeList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType* TagTypeList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::TagType >&
TagTypeList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeList.items)
  return items_;
}

// -------------------------------------------------------------------

// TagTypeSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool TagTypeSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool TagTypeSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void TagTypeSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& TagTypeSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& TagTypeSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec.commonSpec)
  return _internal_commonspec();
}
inline void TagTypeSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* TagTypeSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* TagTypeSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* TagTypeSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* TagTypeSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec.commonSpec)
  return _msg;
}
inline void TagTypeSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec.commonSpec)
}

// -------------------------------------------------------------------

// TagTypeStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool TagTypeStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool TagTypeStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void TagTypeStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& TagTypeStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& TagTypeStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.commonStatus)
  return _internal_commonstatus();
}
inline void TagTypeStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* TagTypeStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* TagTypeStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.commonStatus)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* TagTypeStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000002u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* TagTypeStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.commonStatus)
  return _msg;
}
inline void TagTypeStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.commonStatus)
}

// optional string tagTypeId = 2;
inline bool TagTypeStatus::_internal_has_tagtypeid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TagTypeStatus::has_tagtypeid() const {
  return _internal_has_tagtypeid();
}
inline void TagTypeStatus::clear_tagtypeid() {
  tagtypeid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TagTypeStatus::tagtypeid() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.tagTypeId)
  return _internal_tagtypeid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagTypeStatus::set_tagtypeid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tagtypeid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.tagTypeId)
}
inline std::string* TagTypeStatus::mutable_tagtypeid() {
  std::string* _s = _internal_mutable_tagtypeid();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.tagTypeId)
  return _s;
}
inline const std::string& TagTypeStatus::_internal_tagtypeid() const {
  return tagtypeid_.Get();
}
inline void TagTypeStatus::_internal_set_tagtypeid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tagtypeid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagTypeStatus::_internal_mutable_tagtypeid() {
  _has_bits_[0] |= 0x00000001u;
  return tagtypeid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagTypeStatus::release_tagtypeid() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.tagTypeId)
  if (!_internal_has_tagtypeid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tagtypeid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagTypeStatus::set_allocated_tagtypeid(std::string* tagtypeid) {
  if (tagtypeid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tagtypeid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagtypeid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus.tagTypeId)
}

// -------------------------------------------------------------------

// VirtualMachine

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool VirtualMachine::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualMachine::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualMachine::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualMachine::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.metadata)
  return _internal_metadata();
}
inline void VirtualMachine::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualMachine::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualMachine::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualMachine::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualMachine::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.metadata)
  return _msg;
}
inline void VirtualMachine::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec spec = 2;
inline bool VirtualMachine::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool VirtualMachine::has_spec() const {
  return _internal_has_spec();
}
inline void VirtualMachine::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec& VirtualMachine::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualMachineSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec& VirtualMachine::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.spec)
  return _internal_spec();
}
inline void VirtualMachine::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* VirtualMachine::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* VirtualMachine::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* VirtualMachine::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* VirtualMachine::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.spec)
  return _msg;
}
inline void VirtualMachine::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus status = 3;
inline bool VirtualMachine::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool VirtualMachine::has_status() const {
  return _internal_has_status();
}
inline void VirtualMachine::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus& VirtualMachine::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualMachineStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus& VirtualMachine::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.status)
  return _internal_status();
}
inline void VirtualMachine::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* VirtualMachine::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* VirtualMachine::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* VirtualMachine::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* VirtualMachine::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.status)
  return _msg;
}
inline void VirtualMachine::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine.status)
}

// -------------------------------------------------------------------

// VirtualMachineInterface

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool VirtualMachineInterface::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualMachineInterface::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualMachineInterface::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualMachineInterface::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.metadata)
  return _internal_metadata();
}
inline void VirtualMachineInterface::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualMachineInterface::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualMachineInterface::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualMachineInterface::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualMachineInterface::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.metadata)
  return _msg;
}
inline void VirtualMachineInterface::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec spec = 2;
inline bool VirtualMachineInterface::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool VirtualMachineInterface::has_spec() const {
  return _internal_has_spec();
}
inline void VirtualMachineInterface::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec& VirtualMachineInterface::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualMachineInterfaceSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec& VirtualMachineInterface::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.spec)
  return _internal_spec();
}
inline void VirtualMachineInterface::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* VirtualMachineInterface::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* VirtualMachineInterface::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* VirtualMachineInterface::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* VirtualMachineInterface::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.spec)
  return _msg;
}
inline void VirtualMachineInterface::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus status = 3;
inline bool VirtualMachineInterface::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool VirtualMachineInterface::has_status() const {
  return _internal_has_status();
}
inline void VirtualMachineInterface::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus& VirtualMachineInterface::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualMachineInterfaceStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus& VirtualMachineInterface::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.status)
  return _internal_status();
}
inline void VirtualMachineInterface::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* VirtualMachineInterface::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* VirtualMachineInterface::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* VirtualMachineInterface::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* VirtualMachineInterface::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.status)
  return _msg;
}
inline void VirtualMachineInterface::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface.status)
}

// -------------------------------------------------------------------

// VirtualMachineInterfaceList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool VirtualMachineInterfaceList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualMachineInterfaceList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualMachineInterfaceList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.metadata)
  return _internal_metadata();
}
inline void VirtualMachineInterfaceList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualMachineInterfaceList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualMachineInterfaceList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualMachineInterfaceList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualMachineInterfaceList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.metadata)
  return _msg;
}
inline void VirtualMachineInterfaceList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface items = 2;
inline int VirtualMachineInterfaceList::_internal_items_size() const {
  return items_.size();
}
inline int VirtualMachineInterfaceList::items_size() const {
  return _internal_items_size();
}
inline void VirtualMachineInterfaceList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface* VirtualMachineInterfaceList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface >*
VirtualMachineInterfaceList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface& VirtualMachineInterfaceList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface& VirtualMachineInterfaceList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface* VirtualMachineInterfaceList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface* VirtualMachineInterfaceList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterface >&
VirtualMachineInterfaceList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceList.items)
  return items_;
}

// -------------------------------------------------------------------

// VirtualMachineInterfaceProperties

// optional uint32 subInterfaceVlanTag = 1;
inline bool VirtualMachineInterfaceProperties::_internal_has_subinterfacevlantag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualMachineInterfaceProperties::has_subinterfacevlantag() const {
  return _internal_has_subinterfacevlantag();
}
inline void VirtualMachineInterfaceProperties::clear_subinterfacevlantag() {
  subinterfacevlantag_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VirtualMachineInterfaceProperties::_internal_subinterfacevlantag() const {
  return subinterfacevlantag_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VirtualMachineInterfaceProperties::subinterfacevlantag() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProperties.subInterfaceVlanTag)
  return _internal_subinterfacevlantag();
}
inline void VirtualMachineInterfaceProperties::_internal_set_subinterfacevlantag(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  subinterfacevlantag_ = value;
}
inline void VirtualMachineInterfaceProperties::set_subinterfacevlantag(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_subinterfacevlantag(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProperties.subInterfaceVlanTag)
}

// -------------------------------------------------------------------

// VirtualMachineInterfaceSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool VirtualMachineInterfaceSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void VirtualMachineInterfaceSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualMachineInterfaceSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualMachineInterfaceSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.commonSpec)
  return _internal_commonspec();
}
inline void VirtualMachineInterfaceSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualMachineInterfaceSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualMachineInterfaceSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualMachineInterfaceSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualMachineInterfaceSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.commonSpec)
  return _msg;
}
inline void VirtualMachineInterfaceSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.commonSpec)
}

// optional .k8s.io.api.core.v1.ObjectReference parent = 2;
inline bool VirtualMachineInterfaceSpec::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || parent_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceSpec::has_parent() const {
  return _internal_has_parent();
}
inline const ::k8s::io::api::core::v1::ObjectReference& VirtualMachineInterfaceSpec::_internal_parent() const {
  const ::k8s::io::api::core::v1::ObjectReference* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::api::core::v1::ObjectReference&>(
      ::k8s::io::api::core::v1::_ObjectReference_default_instance_);
}
inline const ::k8s::io::api::core::v1::ObjectReference& VirtualMachineInterfaceSpec::parent() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.parent)
  return _internal_parent();
}
inline void VirtualMachineInterfaceSpec::unsafe_arena_set_allocated_parent(
    ::k8s::io::api::core::v1::ObjectReference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.parent)
}
inline ::k8s::io::api::core::v1::ObjectReference* VirtualMachineInterfaceSpec::release_parent() {
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* VirtualMachineInterfaceSpec::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.parent)
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* VirtualMachineInterfaceSpec::_internal_mutable_parent() {
  _has_bits_[0] |= 0x00000002u;
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::api::core::v1::ObjectReference>(GetArenaForAllocation());
    parent_ = p;
  }
  return parent_;
}
inline ::k8s::io::api::core::v1::ObjectReference* VirtualMachineInterfaceSpec::mutable_parent() {
  ::k8s::io::api::core::v1::ObjectReference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.parent)
  return _msg;
}
inline void VirtualMachineInterfaceSpec::set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent));
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.parent)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses virtualMachineInterfaceMacAddresses = 3;
inline bool VirtualMachineInterfaceSpec::_internal_has_virtualmachineinterfacemacaddresses() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || virtualmachineinterfacemacaddresses_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceSpec::has_virtualmachineinterfacemacaddresses() const {
  return _internal_has_virtualmachineinterfacemacaddresses();
}
inline void VirtualMachineInterfaceSpec::clear_virtualmachineinterfacemacaddresses() {
  if (virtualmachineinterfacemacaddresses_ != nullptr) virtualmachineinterfacemacaddresses_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses& VirtualMachineInterfaceSpec::_internal_virtualmachineinterfacemacaddresses() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* p = virtualmachineinterfacemacaddresses_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_MACAddresses_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses& VirtualMachineInterfaceSpec::virtualmachineinterfacemacaddresses() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceMacAddresses)
  return _internal_virtualmachineinterfacemacaddresses();
}
inline void VirtualMachineInterfaceSpec::unsafe_arena_set_allocated_virtualmachineinterfacemacaddresses(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* virtualmachineinterfacemacaddresses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualmachineinterfacemacaddresses_);
  }
  virtualmachineinterfacemacaddresses_ = virtualmachineinterfacemacaddresses;
  if (virtualmachineinterfacemacaddresses) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceMacAddresses)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* VirtualMachineInterfaceSpec::release_virtualmachineinterfacemacaddresses() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* temp = virtualmachineinterfacemacaddresses_;
  virtualmachineinterfacemacaddresses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* VirtualMachineInterfaceSpec::unsafe_arena_release_virtualmachineinterfacemacaddresses() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceMacAddresses)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* temp = virtualmachineinterfacemacaddresses_;
  virtualmachineinterfacemacaddresses_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* VirtualMachineInterfaceSpec::_internal_mutable_virtualmachineinterfacemacaddresses() {
  _has_bits_[0] |= 0x00000004u;
  if (virtualmachineinterfacemacaddresses_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses>(GetArenaForAllocation());
    virtualmachineinterfacemacaddresses_ = p;
  }
  return virtualmachineinterfacemacaddresses_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* VirtualMachineInterfaceSpec::mutable_virtualmachineinterfacemacaddresses() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* _msg = _internal_mutable_virtualmachineinterfacemacaddresses();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceMacAddresses)
  return _msg;
}
inline void VirtualMachineInterfaceSpec::set_allocated_virtualmachineinterfacemacaddresses(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses* virtualmachineinterfacemacaddresses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete virtualmachineinterfacemacaddresses_;
  }
  if (virtualmachineinterfacemacaddresses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::MACAddresses>::GetOwningArena(virtualmachineinterfacemacaddresses);
    if (message_arena != submessage_arena) {
      virtualmachineinterfacemacaddresses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtualmachineinterfacemacaddresses, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  virtualmachineinterfacemacaddresses_ = virtualmachineinterfacemacaddresses;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceMacAddresses)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualNetworkReference = 4;
inline bool VirtualMachineInterfaceSpec::_internal_has_virtualnetworkreference() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || virtualnetworkreference_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceSpec::has_virtualnetworkreference() const {
  return _internal_has_virtualnetworkreference();
}
inline void VirtualMachineInterfaceSpec::clear_virtualnetworkreference() {
  if (virtualnetworkreference_ != nullptr) virtualnetworkreference_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceSpec::_internal_virtualnetworkreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = virtualnetworkreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceSpec::virtualnetworkreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualNetworkReference)
  return _internal_virtualnetworkreference();
}
inline void VirtualMachineInterfaceSpec::unsafe_arena_set_allocated_virtualnetworkreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkreference_);
  }
  virtualnetworkreference_ = virtualnetworkreference;
  if (virtualnetworkreference) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualNetworkReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::release_virtualnetworkreference() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = virtualnetworkreference_;
  virtualnetworkreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::unsafe_arena_release_virtualnetworkreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualNetworkReference)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = virtualnetworkreference_;
  virtualnetworkreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::_internal_mutable_virtualnetworkreference() {
  _has_bits_[0] |= 0x00000008u;
  if (virtualnetworkreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    virtualnetworkreference_ = p;
  }
  return virtualnetworkreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::mutable_virtualnetworkreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_virtualnetworkreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualNetworkReference)
  return _msg;
}
inline void VirtualMachineInterfaceSpec::set_allocated_virtualnetworkreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* virtualnetworkreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete virtualnetworkreference_;
  }
  if (virtualnetworkreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(virtualnetworkreference);
    if (message_arena != submessage_arena) {
      virtualnetworkreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtualnetworkreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  virtualnetworkreference_ = virtualnetworkreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualNetworkReference)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineReferences = 5;
inline int VirtualMachineInterfaceSpec::_internal_virtualmachinereferences_size() const {
  return virtualmachinereferences_.size();
}
inline int VirtualMachineInterfaceSpec::virtualmachinereferences_size() const {
  return _internal_virtualmachinereferences_size();
}
inline void VirtualMachineInterfaceSpec::clear_virtualmachinereferences() {
  virtualmachinereferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::mutable_virtualmachinereferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineReferences)
  return virtualmachinereferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
VirtualMachineInterfaceSpec::mutable_virtualmachinereferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineReferences)
  return &virtualmachinereferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceSpec::_internal_virtualmachinereferences(int index) const {
  return virtualmachinereferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceSpec::virtualmachinereferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineReferences)
  return _internal_virtualmachinereferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::_internal_add_virtualmachinereferences() {
  return virtualmachinereferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::add_virtualmachinereferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_virtualmachinereferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
VirtualMachineInterfaceSpec::virtualmachinereferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineReferences)
  return virtualmachinereferences_;
}

// optional bool virtualMachineInterfaceDisablePolicy = 6;
inline bool VirtualMachineInterfaceSpec::_internal_has_virtualmachineinterfacedisablepolicy() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VirtualMachineInterfaceSpec::has_virtualmachineinterfacedisablepolicy() const {
  return _internal_has_virtualmachineinterfacedisablepolicy();
}
inline void VirtualMachineInterfaceSpec::clear_virtualmachineinterfacedisablepolicy() {
  virtualmachineinterfacedisablepolicy_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool VirtualMachineInterfaceSpec::_internal_virtualmachineinterfacedisablepolicy() const {
  return virtualmachineinterfacedisablepolicy_;
}
inline bool VirtualMachineInterfaceSpec::virtualmachineinterfacedisablepolicy() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceDisablePolicy)
  return _internal_virtualmachineinterfacedisablepolicy();
}
inline void VirtualMachineInterfaceSpec::_internal_set_virtualmachineinterfacedisablepolicy(bool value) {
  _has_bits_[0] |= 0x00000040u;
  virtualmachineinterfacedisablepolicy_ = value;
}
inline void VirtualMachineInterfaceSpec::set_virtualmachineinterfacedisablepolicy(bool value) {
  _internal_set_virtualmachineinterfacedisablepolicy(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceDisablePolicy)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs allowedAddressPairs = 7;
inline bool VirtualMachineInterfaceSpec::_internal_has_allowedaddresspairs() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || allowedaddresspairs_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceSpec::has_allowedaddresspairs() const {
  return _internal_has_allowedaddresspairs();
}
inline void VirtualMachineInterfaceSpec::clear_allowedaddresspairs() {
  if (allowedaddresspairs_ != nullptr) allowedaddresspairs_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs& VirtualMachineInterfaceSpec::_internal_allowedaddresspairs() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* p = allowedaddresspairs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_AllowedAddressPairs_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs& VirtualMachineInterfaceSpec::allowedaddresspairs() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.allowedAddressPairs)
  return _internal_allowedaddresspairs();
}
inline void VirtualMachineInterfaceSpec::unsafe_arena_set_allocated_allowedaddresspairs(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* allowedaddresspairs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(allowedaddresspairs_);
  }
  allowedaddresspairs_ = allowedaddresspairs;
  if (allowedaddresspairs) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.allowedAddressPairs)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* VirtualMachineInterfaceSpec::release_allowedaddresspairs() {
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* temp = allowedaddresspairs_;
  allowedaddresspairs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* VirtualMachineInterfaceSpec::unsafe_arena_release_allowedaddresspairs() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.allowedAddressPairs)
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* temp = allowedaddresspairs_;
  allowedaddresspairs_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* VirtualMachineInterfaceSpec::_internal_mutable_allowedaddresspairs() {
  _has_bits_[0] |= 0x00000010u;
  if (allowedaddresspairs_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs>(GetArenaForAllocation());
    allowedaddresspairs_ = p;
  }
  return allowedaddresspairs_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* VirtualMachineInterfaceSpec::mutable_allowedaddresspairs() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* _msg = _internal_mutable_allowedaddresspairs();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.allowedAddressPairs)
  return _msg;
}
inline void VirtualMachineInterfaceSpec::set_allocated_allowedaddresspairs(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs* allowedaddresspairs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete allowedaddresspairs_;
  }
  if (allowedaddresspairs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::AllowedAddressPairs>::GetOwningArena(allowedaddresspairs);
    if (message_arena != submessage_arena) {
      allowedaddresspairs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allowedaddresspairs, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  allowedaddresspairs_ = allowedaddresspairs;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.allowedAddressPairs)
}

// optional bool portSecurityEnabled = 8;
inline bool VirtualMachineInterfaceSpec::_internal_has_portsecurityenabled() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool VirtualMachineInterfaceSpec::has_portsecurityenabled() const {
  return _internal_has_portsecurityenabled();
}
inline void VirtualMachineInterfaceSpec::clear_portsecurityenabled() {
  portsecurityenabled_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool VirtualMachineInterfaceSpec::_internal_portsecurityenabled() const {
  return portsecurityenabled_;
}
inline bool VirtualMachineInterfaceSpec::portsecurityenabled() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.portSecurityEnabled)
  return _internal_portsecurityenabled();
}
inline void VirtualMachineInterfaceSpec::_internal_set_portsecurityenabled(bool value) {
  _has_bits_[0] |= 0x00000080u;
  portsecurityenabled_ = value;
}
inline void VirtualMachineInterfaceSpec::set_portsecurityenabled(bool value) {
  _internal_set_portsecurityenabled(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.portSecurityEnabled)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 9;
inline int VirtualMachineInterfaceSpec::_internal_virtualmachineinterfacereferences_size() const {
  return virtualmachineinterfacereferences_.size();
}
inline int VirtualMachineInterfaceSpec::virtualmachineinterfacereferences_size() const {
  return _internal_virtualmachineinterfacereferences_size();
}
inline void VirtualMachineInterfaceSpec::clear_virtualmachineinterfacereferences() {
  virtualmachineinterfacereferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::mutable_virtualmachineinterfacereferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceReferences)
  return virtualmachineinterfacereferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
VirtualMachineInterfaceSpec::mutable_virtualmachineinterfacereferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceReferences)
  return &virtualmachineinterfacereferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceSpec::_internal_virtualmachineinterfacereferences(int index) const {
  return virtualmachineinterfacereferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceSpec::virtualmachineinterfacereferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceReferences)
  return _internal_virtualmachineinterfacereferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::_internal_add_virtualmachineinterfacereferences() {
  return virtualmachineinterfacereferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::add_virtualmachineinterfacereferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_virtualmachineinterfacereferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
VirtualMachineInterfaceSpec::virtualmachineinterfacereferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.virtualMachineInterfaceReferences)
  return virtualmachineinterfacereferences_;
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProperties properties = 10;
inline bool VirtualMachineInterfaceSpec::_internal_has_properties() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || properties_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceSpec::has_properties() const {
  return _internal_has_properties();
}
inline void VirtualMachineInterfaceSpec::clear_properties() {
  if (properties_ != nullptr) properties_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties& VirtualMachineInterfaceSpec::_internal_properties() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* p = properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualMachineInterfaceProperties_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties& VirtualMachineInterfaceSpec::properties() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.properties)
  return _internal_properties();
}
inline void VirtualMachineInterfaceSpec::unsafe_arena_set_allocated_properties(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties_);
  }
  properties_ = properties;
  if (properties) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.properties)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* VirtualMachineInterfaceSpec::release_properties() {
  _has_bits_[0] &= ~0x00000020u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* temp = properties_;
  properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* VirtualMachineInterfaceSpec::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.properties)
  _has_bits_[0] &= ~0x00000020u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* temp = properties_;
  properties_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* VirtualMachineInterfaceSpec::_internal_mutable_properties() {
  _has_bits_[0] |= 0x00000020u;
  if (properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties>(GetArenaForAllocation());
    properties_ = p;
  }
  return properties_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* VirtualMachineInterfaceSpec::mutable_properties() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.properties)
  return _msg;
}
inline void VirtualMachineInterfaceSpec::set_allocated_properties(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete properties_;
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachineInterfaceProperties>::GetOwningArena(properties);
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.properties)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 11;
inline int VirtualMachineInterfaceSpec::_internal_tagreferences_size() const {
  return tagreferences_.size();
}
inline int VirtualMachineInterfaceSpec::tagreferences_size() const {
  return _internal_tagreferences_size();
}
inline void VirtualMachineInterfaceSpec::clear_tagreferences() {
  tagreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::mutable_tagreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.tagReferences)
  return tagreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
VirtualMachineInterfaceSpec::mutable_tagreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.tagReferences)
  return &tagreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceSpec::_internal_tagreferences(int index) const {
  return tagreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceSpec::tagreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.tagReferences)
  return _internal_tagreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::_internal_add_tagreferences() {
  return tagreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceSpec::add_tagreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_tagreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.tagReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
VirtualMachineInterfaceSpec::tagreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec.tagReferences)
  return tagreferences_;
}

// -------------------------------------------------------------------

// VirtualMachineInterfaceStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool VirtualMachineInterfaceStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void VirtualMachineInterfaceStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualMachineInterfaceStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualMachineInterfaceStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.commonStatus)
  return _internal_commonstatus();
}
inline void VirtualMachineInterfaceStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualMachineInterfaceStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualMachineInterfaceStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualMachineInterfaceStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualMachineInterfaceStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.commonStatus)
  return _msg;
}
inline void VirtualMachineInterfaceStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.commonStatus)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference routingInstanceReferences = 3;
inline int VirtualMachineInterfaceStatus::_internal_routinginstancereferences_size() const {
  return routinginstancereferences_.size();
}
inline int VirtualMachineInterfaceStatus::routinginstancereferences_size() const {
  return _internal_routinginstancereferences_size();
}
inline void VirtualMachineInterfaceStatus::clear_routinginstancereferences() {
  routinginstancereferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference* VirtualMachineInterfaceStatus::mutable_routinginstancereferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.routingInstanceReferences)
  return routinginstancereferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference >*
VirtualMachineInterfaceStatus::mutable_routinginstancereferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.routingInstanceReferences)
  return &routinginstancereferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference& VirtualMachineInterfaceStatus::_internal_routinginstancereferences(int index) const {
  return routinginstancereferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference& VirtualMachineInterfaceStatus::routinginstancereferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.routingInstanceReferences)
  return _internal_routinginstancereferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference* VirtualMachineInterfaceStatus::_internal_add_routinginstancereferences() {
  return routinginstancereferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference* VirtualMachineInterfaceStatus::add_routinginstancereferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference* _add = _internal_add_routinginstancereferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.routingInstanceReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RoutingInstanceReference >&
VirtualMachineInterfaceStatus::routinginstancereferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.routingInstanceReferences)
  return routinginstancereferences_;
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference bgpRouterReference = 4;
inline bool VirtualMachineInterfaceStatus::_internal_has_bgprouterreference() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || bgprouterreference_ != nullptr);
  return value;
}
inline bool VirtualMachineInterfaceStatus::has_bgprouterreference() const {
  return _internal_has_bgprouterreference();
}
inline void VirtualMachineInterfaceStatus::clear_bgprouterreference() {
  if (bgprouterreference_ != nullptr) bgprouterreference_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceStatus::_internal_bgprouterreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = bgprouterreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualMachineInterfaceStatus::bgprouterreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.bgpRouterReference)
  return _internal_bgprouterreference();
}
inline void VirtualMachineInterfaceStatus::unsafe_arena_set_allocated_bgprouterreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* bgprouterreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bgprouterreference_);
  }
  bgprouterreference_ = bgprouterreference;
  if (bgprouterreference) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.bgpRouterReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceStatus::release_bgprouterreference() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = bgprouterreference_;
  bgprouterreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceStatus::unsafe_arena_release_bgprouterreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.bgpRouterReference)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = bgprouterreference_;
  bgprouterreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceStatus::_internal_mutable_bgprouterreference() {
  _has_bits_[0] |= 0x00000002u;
  if (bgprouterreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    bgprouterreference_ = p;
  }
  return bgprouterreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualMachineInterfaceStatus::mutable_bgprouterreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_bgprouterreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.bgpRouterReference)
  return _msg;
}
inline void VirtualMachineInterfaceStatus::set_allocated_bgprouterreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* bgprouterreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bgprouterreference_;
  }
  if (bgprouterreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(bgprouterreference);
    if (message_arena != submessage_arena) {
      bgprouterreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bgprouterreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  bgprouterreference_ = bgprouterreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus.bgpRouterReference)
}

// -------------------------------------------------------------------

// VirtualMachineList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool VirtualMachineList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualMachineList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualMachineList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualMachineList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.metadata)
  return _internal_metadata();
}
inline void VirtualMachineList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualMachineList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualMachineList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualMachineList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualMachineList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.metadata)
  return _msg;
}
inline void VirtualMachineList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine items = 2;
inline int VirtualMachineList::_internal_items_size() const {
  return items_.size();
}
inline int VirtualMachineList::items_size() const {
  return _internal_items_size();
}
inline void VirtualMachineList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine* VirtualMachineList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine >*
VirtualMachineList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine& VirtualMachineList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine& VirtualMachineList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine* VirtualMachineList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine* VirtualMachineList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualMachine >&
VirtualMachineList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineList.items)
  return items_;
}

// -------------------------------------------------------------------

// VirtualMachineSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool VirtualMachineSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool VirtualMachineSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void VirtualMachineSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualMachineSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualMachineSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.commonSpec)
  return _internal_commonspec();
}
inline void VirtualMachineSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualMachineSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualMachineSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.commonSpec)
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualMachineSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000010u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualMachineSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.commonSpec)
  return _msg;
}
inline void VirtualMachineSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.commonSpec)
}

// optional string serverType = 2;
inline bool VirtualMachineSpec::_internal_has_servertype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualMachineSpec::has_servertype() const {
  return _internal_has_servertype();
}
inline void VirtualMachineSpec::clear_servertype() {
  servertype_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VirtualMachineSpec::servertype() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverType)
  return _internal_servertype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualMachineSpec::set_servertype(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 servertype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverType)
}
inline std::string* VirtualMachineSpec::mutable_servertype() {
  std::string* _s = _internal_mutable_servertype();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverType)
  return _s;
}
inline const std::string& VirtualMachineSpec::_internal_servertype() const {
  return servertype_.Get();
}
inline void VirtualMachineSpec::_internal_set_servertype(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  servertype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualMachineSpec::_internal_mutable_servertype() {
  _has_bits_[0] |= 0x00000001u;
  return servertype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualMachineSpec::release_servertype() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverType)
  if (!_internal_has_servertype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return servertype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualMachineSpec::set_allocated_servertype(std::string* servertype) {
  if (servertype != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  servertype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), servertype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverType)
}

// optional string serverName = 3;
inline bool VirtualMachineSpec::_internal_has_servername() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VirtualMachineSpec::has_servername() const {
  return _internal_has_servername();
}
inline void VirtualMachineSpec::clear_servername() {
  servername_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VirtualMachineSpec::servername() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverName)
  return _internal_servername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualMachineSpec::set_servername(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 servername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverName)
}
inline std::string* VirtualMachineSpec::mutable_servername() {
  std::string* _s = _internal_mutable_servername();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverName)
  return _s;
}
inline const std::string& VirtualMachineSpec::_internal_servername() const {
  return servername_.Get();
}
inline void VirtualMachineSpec::_internal_set_servername(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  servername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualMachineSpec::_internal_mutable_servername() {
  _has_bits_[0] |= 0x00000002u;
  return servername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualMachineSpec::release_servername() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverName)
  if (!_internal_has_servername()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return servername_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualMachineSpec::set_allocated_servername(std::string* servername) {
  if (servername != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  servername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), servername,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverName)
}

// optional string serverNamespace = 4;
inline bool VirtualMachineSpec::_internal_has_servernamespace() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VirtualMachineSpec::has_servernamespace() const {
  return _internal_has_servernamespace();
}
inline void VirtualMachineSpec::clear_servernamespace() {
  servernamespace_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VirtualMachineSpec::servernamespace() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverNamespace)
  return _internal_servernamespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualMachineSpec::set_servernamespace(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 servernamespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverNamespace)
}
inline std::string* VirtualMachineSpec::mutable_servernamespace() {
  std::string* _s = _internal_mutable_servernamespace();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverNamespace)
  return _s;
}
inline const std::string& VirtualMachineSpec::_internal_servernamespace() const {
  return servernamespace_.Get();
}
inline void VirtualMachineSpec::_internal_set_servernamespace(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  servernamespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualMachineSpec::_internal_mutable_servernamespace() {
  _has_bits_[0] |= 0x00000004u;
  return servernamespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualMachineSpec::release_servernamespace() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverNamespace)
  if (!_internal_has_servernamespace()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return servernamespace_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualMachineSpec::set_allocated_servernamespace(std::string* servernamespace) {
  if (servernamespace != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  servernamespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), servernamespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverNamespace)
}

// optional string serverClusterName = 5;
inline bool VirtualMachineSpec::_internal_has_serverclustername() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VirtualMachineSpec::has_serverclustername() const {
  return _internal_has_serverclustername();
}
inline void VirtualMachineSpec::clear_serverclustername() {
  serverclustername_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& VirtualMachineSpec::serverclustername() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverClusterName)
  return _internal_serverclustername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualMachineSpec::set_serverclustername(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 serverclustername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverClusterName)
}
inline std::string* VirtualMachineSpec::mutable_serverclustername() {
  std::string* _s = _internal_mutable_serverclustername();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverClusterName)
  return _s;
}
inline const std::string& VirtualMachineSpec::_internal_serverclustername() const {
  return serverclustername_.Get();
}
inline void VirtualMachineSpec::_internal_set_serverclustername(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  serverclustername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualMachineSpec::_internal_mutable_serverclustername() {
  _has_bits_[0] |= 0x00000008u;
  return serverclustername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualMachineSpec::release_serverclustername() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverClusterName)
  if (!_internal_has_serverclustername()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return serverclustername_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualMachineSpec::set_allocated_serverclustername(std::string* serverclustername) {
  if (serverclustername != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  serverclustername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverclustername,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec.serverClusterName)
}

// -------------------------------------------------------------------

// VirtualMachineStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool VirtualMachineStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool VirtualMachineStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void VirtualMachineStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualMachineStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualMachineStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus.commonStatus)
  return _internal_commonstatus();
}
inline void VirtualMachineStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualMachineStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualMachineStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualMachineStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualMachineStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus.commonStatus)
  return _msg;
}
inline void VirtualMachineStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus.commonStatus)
}

// -------------------------------------------------------------------

// VirtualNetwork

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool VirtualNetwork::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualNetwork::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualNetwork::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualNetwork::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.metadata)
  return _internal_metadata();
}
inline void VirtualNetwork::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualNetwork::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualNetwork::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualNetwork::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualNetwork::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.metadata)
  return _msg;
}
inline void VirtualNetwork::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec spec = 2;
inline bool VirtualNetwork::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool VirtualNetwork::has_spec() const {
  return _internal_has_spec();
}
inline void VirtualNetwork::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec& VirtualNetwork::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualNetworkSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec& VirtualNetwork::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.spec)
  return _internal_spec();
}
inline void VirtualNetwork::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* VirtualNetwork::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* VirtualNetwork::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* VirtualNetwork::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* VirtualNetwork::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.spec)
  return _msg;
}
inline void VirtualNetwork::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus status = 3;
inline bool VirtualNetwork::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool VirtualNetwork::has_status() const {
  return _internal_has_status();
}
inline void VirtualNetwork::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus& VirtualNetwork::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualNetworkStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus& VirtualNetwork::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.status)
  return _internal_status();
}
inline void VirtualNetwork::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* VirtualNetwork::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* VirtualNetwork::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* VirtualNetwork::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* VirtualNetwork::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.status)
  return _msg;
}
inline void VirtualNetwork::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork.status)
}

// -------------------------------------------------------------------

// VirtualNetworkList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool VirtualNetworkList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualNetworkList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualNetworkList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualNetworkList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.metadata)
  return _internal_metadata();
}
inline void VirtualNetworkList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualNetworkList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualNetworkList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualNetworkList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualNetworkList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.metadata)
  return _msg;
}
inline void VirtualNetworkList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork items = 2;
inline int VirtualNetworkList::_internal_items_size() const {
  return items_.size();
}
inline int VirtualNetworkList::items_size() const {
  return _internal_items_size();
}
inline void VirtualNetworkList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork* VirtualNetworkList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork >*
VirtualNetworkList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork& VirtualNetworkList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork& VirtualNetworkList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork* VirtualNetworkList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork* VirtualNetworkList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetwork >&
VirtualNetworkList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkList.items)
  return items_;
}

// -------------------------------------------------------------------

// VirtualNetworkRouteTargetReferenceList

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference routeTargetReferences = 1;
inline int VirtualNetworkRouteTargetReferenceList::_internal_routetargetreferences_size() const {
  return routetargetreferences_.size();
}
inline int VirtualNetworkRouteTargetReferenceList::routetargetreferences_size() const {
  return _internal_routetargetreferences_size();
}
inline void VirtualNetworkRouteTargetReferenceList::clear_routetargetreferences() {
  routetargetreferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* VirtualNetworkRouteTargetReferenceList::mutable_routetargetreferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList.routeTargetReferences)
  return routetargetreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference >*
VirtualNetworkRouteTargetReferenceList::mutable_routetargetreferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList.routeTargetReferences)
  return &routetargetreferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& VirtualNetworkRouteTargetReferenceList::_internal_routetargetreferences(int index) const {
  return routetargetreferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference& VirtualNetworkRouteTargetReferenceList::routetargetreferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList.routeTargetReferences)
  return _internal_routetargetreferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* VirtualNetworkRouteTargetReferenceList::_internal_add_routetargetreferences() {
  return routetargetreferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* VirtualNetworkRouteTargetReferenceList::add_routetargetreferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference* _add = _internal_add_routetargetreferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList.routeTargetReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::RouteTargetReference >&
VirtualNetworkRouteTargetReferenceList::routetargetreferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceList.routeTargetReferences)
  return routetargetreferences_;
}

// -------------------------------------------------------------------

// VirtualNetworkRouter

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool VirtualNetworkRouter::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouter::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualNetworkRouter::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualNetworkRouter::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.metadata)
  return _internal_metadata();
}
inline void VirtualNetworkRouter::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualNetworkRouter::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualNetworkRouter::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualNetworkRouter::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualNetworkRouter::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.metadata)
  return _msg;
}
inline void VirtualNetworkRouter::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec spec = 2;
inline bool VirtualNetworkRouter::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouter::has_spec() const {
  return _internal_has_spec();
}
inline void VirtualNetworkRouter::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec& VirtualNetworkRouter::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualNetworkRouterSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec& VirtualNetworkRouter::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.spec)
  return _internal_spec();
}
inline void VirtualNetworkRouter::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* VirtualNetworkRouter::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* VirtualNetworkRouter::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* VirtualNetworkRouter::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* VirtualNetworkRouter::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.spec)
  return _msg;
}
inline void VirtualNetworkRouter::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus status = 3;
inline bool VirtualNetworkRouter::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouter::has_status() const {
  return _internal_has_status();
}
inline void VirtualNetworkRouter::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus& VirtualNetworkRouter::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualNetworkRouterStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus& VirtualNetworkRouter::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.status)
  return _internal_status();
}
inline void VirtualNetworkRouter::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* VirtualNetworkRouter::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* VirtualNetworkRouter::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* VirtualNetworkRouter::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* VirtualNetworkRouter::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.status)
  return _msg;
}
inline void VirtualNetworkRouter::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouterStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter.status)
}

// -------------------------------------------------------------------

// VirtualNetworkRouterEntry

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualNetworkRouterSelector = 1;
inline bool VirtualNetworkRouterEntry::_internal_has_virtualnetworkrouterselector() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || virtualnetworkrouterselector_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouterEntry::has_virtualnetworkrouterselector() const {
  return _internal_has_virtualnetworkrouterselector();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& VirtualNetworkRouterEntry::_internal_virtualnetworkrouterselector() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* p = virtualnetworkrouterselector_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_LabelSelector_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& VirtualNetworkRouterEntry::virtualnetworkrouterselector() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.virtualNetworkRouterSelector)
  return _internal_virtualnetworkrouterselector();
}
inline void VirtualNetworkRouterEntry::unsafe_arena_set_allocated_virtualnetworkrouterselector(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkrouterselector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkrouterselector_);
  }
  virtualnetworkrouterselector_ = virtualnetworkrouterselector;
  if (virtualnetworkrouterselector) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.virtualNetworkRouterSelector)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterEntry::release_virtualnetworkrouterselector() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* temp = virtualnetworkrouterselector_;
  virtualnetworkrouterselector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterEntry::unsafe_arena_release_virtualnetworkrouterselector() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.virtualNetworkRouterSelector)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* temp = virtualnetworkrouterselector_;
  virtualnetworkrouterselector_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterEntry::_internal_mutable_virtualnetworkrouterselector() {
  _has_bits_[0] |= 0x00000001u;
  if (virtualnetworkrouterselector_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector>(GetArenaForAllocation());
    virtualnetworkrouterselector_ = p;
  }
  return virtualnetworkrouterselector_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterEntry::mutable_virtualnetworkrouterselector() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* _msg = _internal_mutable_virtualnetworkrouterselector();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.virtualNetworkRouterSelector)
  return _msg;
}
inline void VirtualNetworkRouterEntry::set_allocated_virtualnetworkrouterselector(::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkrouterselector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkrouterselector_);
  }
  if (virtualnetworkrouterselector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkrouterselector));
    if (message_arena != submessage_arena) {
      virtualnetworkrouterselector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtualnetworkrouterselector, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  virtualnetworkrouterselector_ = virtualnetworkrouterselector;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.virtualNetworkRouterSelector)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
inline bool VirtualNetworkRouterEntry::_internal_has_namespaceselector() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || namespaceselector_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouterEntry::has_namespaceselector() const {
  return _internal_has_namespaceselector();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& VirtualNetworkRouterEntry::_internal_namespaceselector() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* p = namespaceselector_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_LabelSelector_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& VirtualNetworkRouterEntry::namespaceselector() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.namespaceSelector)
  return _internal_namespaceselector();
}
inline void VirtualNetworkRouterEntry::unsafe_arena_set_allocated_namespaceselector(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* namespaceselector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespaceselector_);
  }
  namespaceselector_ = namespaceselector;
  if (namespaceselector) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.namespaceSelector)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterEntry::release_namespaceselector() {
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* temp = namespaceselector_;
  namespaceselector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterEntry::unsafe_arena_release_namespaceselector() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.namespaceSelector)
  _has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* temp = namespaceselector_;
  namespaceselector_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterEntry::_internal_mutable_namespaceselector() {
  _has_bits_[0] |= 0x00000002u;
  if (namespaceselector_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector>(GetArenaForAllocation());
    namespaceselector_ = p;
  }
  return namespaceselector_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterEntry::mutable_namespaceselector() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* _msg = _internal_mutable_namespaceselector();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.namespaceSelector)
  return _msg;
}
inline void VirtualNetworkRouterEntry::set_allocated_namespaceselector(::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* namespaceselector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespaceselector_);
  }
  if (namespaceselector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespaceselector));
    if (message_arena != submessage_arena) {
      namespaceselector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespaceselector, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  namespaceselector_ = namespaceselector;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry.namespaceSelector)
}

// -------------------------------------------------------------------

// VirtualNetworkRouterList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool VirtualNetworkRouterList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouterList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualNetworkRouterList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualNetworkRouterList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.metadata)
  return _internal_metadata();
}
inline void VirtualNetworkRouterList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualNetworkRouterList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualNetworkRouterList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualNetworkRouterList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualNetworkRouterList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.metadata)
  return _msg;
}
inline void VirtualNetworkRouterList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter items = 2;
inline int VirtualNetworkRouterList::_internal_items_size() const {
  return items_.size();
}
inline int VirtualNetworkRouterList::items_size() const {
  return _internal_items_size();
}
inline void VirtualNetworkRouterList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter* VirtualNetworkRouterList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter >*
VirtualNetworkRouterList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter& VirtualNetworkRouterList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter& VirtualNetworkRouterList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter* VirtualNetworkRouterList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter* VirtualNetworkRouterList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkRouter >&
VirtualNetworkRouterList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterList.items)
  return items_;
}

// -------------------------------------------------------------------

// VirtualNetworkRouterSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool VirtualNetworkRouterSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouterSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void VirtualNetworkRouterSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualNetworkRouterSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualNetworkRouterSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.commonSpec)
  return _internal_commonspec();
}
inline void VirtualNetworkRouterSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualNetworkRouterSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualNetworkRouterSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.commonSpec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualNetworkRouterSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000002u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualNetworkRouterSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.commonSpec)
  return _msg;
}
inline void VirtualNetworkRouterSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.commonSpec)
}

// optional string type = 2;
inline bool VirtualNetworkRouterSpec::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualNetworkRouterSpec::has_type() const {
  return _internal_has_type();
}
inline void VirtualNetworkRouterSpec::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VirtualNetworkRouterSpec::type() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualNetworkRouterSpec::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.type)
}
inline std::string* VirtualNetworkRouterSpec::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.type)
  return _s;
}
inline const std::string& VirtualNetworkRouterSpec::_internal_type() const {
  return type_.Get();
}
inline void VirtualNetworkRouterSpec::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualNetworkRouterSpec::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualNetworkRouterSpec::release_type() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualNetworkRouterSpec::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.type)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualNetworkSelector = 3;
inline bool VirtualNetworkRouterSpec::_internal_has_virtualnetworkselector() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || virtualnetworkselector_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouterSpec::has_virtualnetworkselector() const {
  return _internal_has_virtualnetworkselector();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& VirtualNetworkRouterSpec::_internal_virtualnetworkselector() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* p = virtualnetworkselector_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_LabelSelector_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& VirtualNetworkRouterSpec::virtualnetworkselector() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.virtualNetworkSelector)
  return _internal_virtualnetworkselector();
}
inline void VirtualNetworkRouterSpec::unsafe_arena_set_allocated_virtualnetworkselector(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkselector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkselector_);
  }
  virtualnetworkselector_ = virtualnetworkselector;
  if (virtualnetworkselector) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.virtualNetworkSelector)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterSpec::release_virtualnetworkselector() {
  _has_bits_[0] &= ~0x00000004u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* temp = virtualnetworkselector_;
  virtualnetworkselector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterSpec::unsafe_arena_release_virtualnetworkselector() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.virtualNetworkSelector)
  _has_bits_[0] &= ~0x00000004u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* temp = virtualnetworkselector_;
  virtualnetworkselector_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterSpec::_internal_mutable_virtualnetworkselector() {
  _has_bits_[0] |= 0x00000004u;
  if (virtualnetworkselector_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector>(GetArenaForAllocation());
    virtualnetworkselector_ = p;
  }
  return virtualnetworkselector_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* VirtualNetworkRouterSpec::mutable_virtualnetworkselector() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* _msg = _internal_mutable_virtualnetworkselector();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.virtualNetworkSelector)
  return _msg;
}
inline void VirtualNetworkRouterSpec::set_allocated_virtualnetworkselector(::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* virtualnetworkselector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkselector_);
  }
  if (virtualnetworkselector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkselector));
    if (message_arena != submessage_arena) {
      virtualnetworkselector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtualnetworkselector, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  virtualnetworkselector_ = virtualnetworkselector;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.virtualNetworkSelector)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter import = 4;
inline bool VirtualNetworkRouterSpec::_internal_has_import() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || import_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouterSpec::has_import() const {
  return _internal_has_import();
}
inline void VirtualNetworkRouterSpec::clear_import() {
  if (import_ != nullptr) import_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter& VirtualNetworkRouterSpec::_internal_import() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* p = import_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ImportVirtualNetworkRouter_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter& VirtualNetworkRouterSpec::import() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.import)
  return _internal_import();
}
inline void VirtualNetworkRouterSpec::unsafe_arena_set_allocated_import(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* import) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(import_);
  }
  import_ = import;
  if (import) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.import)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* VirtualNetworkRouterSpec::release_import() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* temp = import_;
  import_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* VirtualNetworkRouterSpec::unsafe_arena_release_import() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.import)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* temp = import_;
  import_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* VirtualNetworkRouterSpec::_internal_mutable_import() {
  _has_bits_[0] |= 0x00000008u;
  if (import_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter>(GetArenaForAllocation());
    import_ = p;
  }
  return import_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* VirtualNetworkRouterSpec::mutable_import() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* _msg = _internal_mutable_import();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.import)
  return _msg;
}
inline void VirtualNetworkRouterSpec::set_allocated_import(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter* import) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete import_;
  }
  if (import) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ImportVirtualNetworkRouter>::GetOwningArena(import);
    if (message_arena != submessage_arena) {
      import = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, import, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  import_ = import;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec.import)
}

// -------------------------------------------------------------------

// VirtualNetworkRouterStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool VirtualNetworkRouterStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool VirtualNetworkRouterStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void VirtualNetworkRouterStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualNetworkRouterStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualNetworkRouterStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus.commonStatus)
  return _internal_commonstatus();
}
inline void VirtualNetworkRouterStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualNetworkRouterStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualNetworkRouterStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualNetworkRouterStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualNetworkRouterStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus.commonStatus)
  return _msg;
}
inline void VirtualNetworkRouterStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus.commonStatus)
}

// -------------------------------------------------------------------

// VirtualNetworkSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool VirtualNetworkSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool VirtualNetworkSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void VirtualNetworkSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualNetworkSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualNetworkSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.commonSpec)
  return _internal_commonspec();
}
inline void VirtualNetworkSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualNetworkSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualNetworkSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.commonSpec)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualNetworkSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000001u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualNetworkSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.commonSpec)
  return _msg;
}
inline void VirtualNetworkSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.commonSpec)
}

// optional bool fabricSNAT = 2;
inline bool VirtualNetworkSpec::_internal_has_fabricsnat() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VirtualNetworkSpec::has_fabricsnat() const {
  return _internal_has_fabricsnat();
}
inline void VirtualNetworkSpec::clear_fabricsnat() {
  fabricsnat_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool VirtualNetworkSpec::_internal_fabricsnat() const {
  return fabricsnat_;
}
inline bool VirtualNetworkSpec::fabricsnat() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.fabricSNAT)
  return _internal_fabricsnat();
}
inline void VirtualNetworkSpec::_internal_set_fabricsnat(bool value) {
  _has_bits_[0] |= 0x00000020u;
  fabricsnat_ = value;
}
inline void VirtualNetworkSpec::set_fabricsnat(bool value) {
  _internal_set_fabricsnat(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.fabricSNAT)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference v4SubnetReference = 3;
inline bool VirtualNetworkSpec::_internal_has_v4subnetreference() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || v4subnetreference_ != nullptr);
  return value;
}
inline bool VirtualNetworkSpec::has_v4subnetreference() const {
  return _internal_has_v4subnetreference();
}
inline void VirtualNetworkSpec::clear_v4subnetreference() {
  if (v4subnetreference_ != nullptr) v4subnetreference_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualNetworkSpec::_internal_v4subnetreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = v4subnetreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualNetworkSpec::v4subnetreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v4SubnetReference)
  return _internal_v4subnetreference();
}
inline void VirtualNetworkSpec::unsafe_arena_set_allocated_v4subnetreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v4subnetreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(v4subnetreference_);
  }
  v4subnetreference_ = v4subnetreference;
  if (v4subnetreference) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v4SubnetReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::release_v4subnetreference() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = v4subnetreference_;
  v4subnetreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::unsafe_arena_release_v4subnetreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v4SubnetReference)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = v4subnetreference_;
  v4subnetreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::_internal_mutable_v4subnetreference() {
  _has_bits_[0] |= 0x00000002u;
  if (v4subnetreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    v4subnetreference_ = p;
  }
  return v4subnetreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::mutable_v4subnetreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_v4subnetreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v4SubnetReference)
  return _msg;
}
inline void VirtualNetworkSpec::set_allocated_v4subnetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v4subnetreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete v4subnetreference_;
  }
  if (v4subnetreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(v4subnetreference);
    if (message_arena != submessage_arena) {
      v4subnetreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v4subnetreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  v4subnetreference_ = v4subnetreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v4SubnetReference)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference v6SubnetReference = 4;
inline bool VirtualNetworkSpec::_internal_has_v6subnetreference() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || v6subnetreference_ != nullptr);
  return value;
}
inline bool VirtualNetworkSpec::has_v6subnetreference() const {
  return _internal_has_v6subnetreference();
}
inline void VirtualNetworkSpec::clear_v6subnetreference() {
  if (v6subnetreference_ != nullptr) v6subnetreference_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualNetworkSpec::_internal_v6subnetreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = v6subnetreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualNetworkSpec::v6subnetreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v6SubnetReference)
  return _internal_v6subnetreference();
}
inline void VirtualNetworkSpec::unsafe_arena_set_allocated_v6subnetreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v6subnetreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(v6subnetreference_);
  }
  v6subnetreference_ = v6subnetreference;
  if (v6subnetreference) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v6SubnetReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::release_v6subnetreference() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = v6subnetreference_;
  v6subnetreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::unsafe_arena_release_v6subnetreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v6SubnetReference)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = v6subnetreference_;
  v6subnetreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::_internal_mutable_v6subnetreference() {
  _has_bits_[0] |= 0x00000004u;
  if (v6subnetreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    v6subnetreference_ = p;
  }
  return v6subnetreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::mutable_v6subnetreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_v6subnetreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v6SubnetReference)
  return _msg;
}
inline void VirtualNetworkSpec::set_allocated_v6subnetreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* v6subnetreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete v6subnetreference_;
  }
  if (v6subnetreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(v6subnetreference);
    if (message_arena != submessage_arena) {
      v6subnetreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v6subnetreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  v6subnetreference_ = v6subnetreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.v6SubnetReference)
}

// repeated string routeTargetList = 5;
inline int VirtualNetworkSpec::_internal_routetargetlist_size() const {
  return routetargetlist_.size();
}
inline int VirtualNetworkSpec::routetargetlist_size() const {
  return _internal_routetargetlist_size();
}
inline void VirtualNetworkSpec::clear_routetargetlist() {
  routetargetlist_.Clear();
}
inline std::string* VirtualNetworkSpec::add_routetargetlist() {
  std::string* _s = _internal_add_routetargetlist();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
  return _s;
}
inline const std::string& VirtualNetworkSpec::_internal_routetargetlist(int index) const {
  return routetargetlist_.Get(index);
}
inline const std::string& VirtualNetworkSpec::routetargetlist(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
  return _internal_routetargetlist(index);
}
inline std::string* VirtualNetworkSpec::mutable_routetargetlist(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
  return routetargetlist_.Mutable(index);
}
inline void VirtualNetworkSpec::set_routetargetlist(int index, const std::string& value) {
  routetargetlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
}
inline void VirtualNetworkSpec::set_routetargetlist(int index, std::string&& value) {
  routetargetlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
}
inline void VirtualNetworkSpec::set_routetargetlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  routetargetlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
}
inline void VirtualNetworkSpec::set_routetargetlist(int index, const char* value, size_t size) {
  routetargetlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
}
inline std::string* VirtualNetworkSpec::_internal_add_routetargetlist() {
  return routetargetlist_.Add();
}
inline void VirtualNetworkSpec::add_routetargetlist(const std::string& value) {
  routetargetlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
}
inline void VirtualNetworkSpec::add_routetargetlist(std::string&& value) {
  routetargetlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
}
inline void VirtualNetworkSpec::add_routetargetlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  routetargetlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
}
inline void VirtualNetworkSpec::add_routetargetlist(const char* value, size_t size) {
  routetargetlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VirtualNetworkSpec::routetargetlist() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
  return routetargetlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VirtualNetworkSpec::mutable_routetargetlist() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.routeTargetList)
  return &routetargetlist_;
}

// repeated string importRouteTargetList = 6;
inline int VirtualNetworkSpec::_internal_importroutetargetlist_size() const {
  return importroutetargetlist_.size();
}
inline int VirtualNetworkSpec::importroutetargetlist_size() const {
  return _internal_importroutetargetlist_size();
}
inline void VirtualNetworkSpec::clear_importroutetargetlist() {
  importroutetargetlist_.Clear();
}
inline std::string* VirtualNetworkSpec::add_importroutetargetlist() {
  std::string* _s = _internal_add_importroutetargetlist();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
  return _s;
}
inline const std::string& VirtualNetworkSpec::_internal_importroutetargetlist(int index) const {
  return importroutetargetlist_.Get(index);
}
inline const std::string& VirtualNetworkSpec::importroutetargetlist(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
  return _internal_importroutetargetlist(index);
}
inline std::string* VirtualNetworkSpec::mutable_importroutetargetlist(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
  return importroutetargetlist_.Mutable(index);
}
inline void VirtualNetworkSpec::set_importroutetargetlist(int index, const std::string& value) {
  importroutetargetlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
}
inline void VirtualNetworkSpec::set_importroutetargetlist(int index, std::string&& value) {
  importroutetargetlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
}
inline void VirtualNetworkSpec::set_importroutetargetlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  importroutetargetlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
}
inline void VirtualNetworkSpec::set_importroutetargetlist(int index, const char* value, size_t size) {
  importroutetargetlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
}
inline std::string* VirtualNetworkSpec::_internal_add_importroutetargetlist() {
  return importroutetargetlist_.Add();
}
inline void VirtualNetworkSpec::add_importroutetargetlist(const std::string& value) {
  importroutetargetlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
}
inline void VirtualNetworkSpec::add_importroutetargetlist(std::string&& value) {
  importroutetargetlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
}
inline void VirtualNetworkSpec::add_importroutetargetlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  importroutetargetlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
}
inline void VirtualNetworkSpec::add_importroutetargetlist(const char* value, size_t size) {
  importroutetargetlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VirtualNetworkSpec::importroutetargetlist() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
  return importroutetargetlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VirtualNetworkSpec::mutable_importroutetargetlist() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.importRouteTargetList)
  return &importroutetargetlist_;
}

// repeated string exportRouteTargetList = 7;
inline int VirtualNetworkSpec::_internal_exportroutetargetlist_size() const {
  return exportroutetargetlist_.size();
}
inline int VirtualNetworkSpec::exportroutetargetlist_size() const {
  return _internal_exportroutetargetlist_size();
}
inline void VirtualNetworkSpec::clear_exportroutetargetlist() {
  exportroutetargetlist_.Clear();
}
inline std::string* VirtualNetworkSpec::add_exportroutetargetlist() {
  std::string* _s = _internal_add_exportroutetargetlist();
  // @@protoc_insertion_point(field_add_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
  return _s;
}
inline const std::string& VirtualNetworkSpec::_internal_exportroutetargetlist(int index) const {
  return exportroutetargetlist_.Get(index);
}
inline const std::string& VirtualNetworkSpec::exportroutetargetlist(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
  return _internal_exportroutetargetlist(index);
}
inline std::string* VirtualNetworkSpec::mutable_exportroutetargetlist(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
  return exportroutetargetlist_.Mutable(index);
}
inline void VirtualNetworkSpec::set_exportroutetargetlist(int index, const std::string& value) {
  exportroutetargetlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
}
inline void VirtualNetworkSpec::set_exportroutetargetlist(int index, std::string&& value) {
  exportroutetargetlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
}
inline void VirtualNetworkSpec::set_exportroutetargetlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  exportroutetargetlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
}
inline void VirtualNetworkSpec::set_exportroutetargetlist(int index, const char* value, size_t size) {
  exportroutetargetlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
}
inline std::string* VirtualNetworkSpec::_internal_add_exportroutetargetlist() {
  return exportroutetargetlist_.Add();
}
inline void VirtualNetworkSpec::add_exportroutetargetlist(const std::string& value) {
  exportroutetargetlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
}
inline void VirtualNetworkSpec::add_exportroutetargetlist(std::string&& value) {
  exportroutetargetlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
}
inline void VirtualNetworkSpec::add_exportroutetargetlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  exportroutetargetlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
}
inline void VirtualNetworkSpec::add_exportroutetargetlist(const char* value, size_t size) {
  exportroutetargetlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VirtualNetworkSpec::exportroutetargetlist() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
  return exportroutetargetlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VirtualNetworkSpec::mutable_exportroutetargetlist() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.exportRouteTargetList)
  return &exportroutetargetlist_;
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType virtualNetworkProperties = 8;
inline bool VirtualNetworkSpec::_internal_has_virtualnetworkproperties() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || virtualnetworkproperties_ != nullptr);
  return value;
}
inline bool VirtualNetworkSpec::has_virtualnetworkproperties() const {
  return _internal_has_virtualnetworkproperties();
}
inline void VirtualNetworkSpec::clear_virtualnetworkproperties() {
  if (virtualnetworkproperties_ != nullptr) virtualnetworkproperties_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType& VirtualNetworkSpec::_internal_virtualnetworkproperties() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* p = virtualnetworkproperties_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualNetworkType_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType& VirtualNetworkSpec::virtualnetworkproperties() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.virtualNetworkProperties)
  return _internal_virtualnetworkproperties();
}
inline void VirtualNetworkSpec::unsafe_arena_set_allocated_virtualnetworkproperties(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* virtualnetworkproperties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtualnetworkproperties_);
  }
  virtualnetworkproperties_ = virtualnetworkproperties;
  if (virtualnetworkproperties) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.virtualNetworkProperties)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* VirtualNetworkSpec::release_virtualnetworkproperties() {
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* temp = virtualnetworkproperties_;
  virtualnetworkproperties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* VirtualNetworkSpec::unsafe_arena_release_virtualnetworkproperties() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.virtualNetworkProperties)
  _has_bits_[0] &= ~0x00000008u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* temp = virtualnetworkproperties_;
  virtualnetworkproperties_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* VirtualNetworkSpec::_internal_mutable_virtualnetworkproperties() {
  _has_bits_[0] |= 0x00000008u;
  if (virtualnetworkproperties_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType>(GetArenaForAllocation());
    virtualnetworkproperties_ = p;
  }
  return virtualnetworkproperties_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* VirtualNetworkSpec::mutable_virtualnetworkproperties() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* _msg = _internal_mutable_virtualnetworkproperties();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.virtualNetworkProperties)
  return _msg;
}
inline void VirtualNetworkSpec::set_allocated_virtualnetworkproperties(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType* virtualnetworkproperties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete virtualnetworkproperties_;
  }
  if (virtualnetworkproperties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualNetworkType>::GetOwningArena(virtualnetworkproperties);
    if (message_arena != submessage_arena) {
      virtualnetworkproperties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtualnetworkproperties, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  virtualnetworkproperties_ = virtualnetworkproperties;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.virtualNetworkProperties)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference providerNetworkReference = 9;
inline bool VirtualNetworkSpec::_internal_has_providernetworkreference() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || providernetworkreference_ != nullptr);
  return value;
}
inline bool VirtualNetworkSpec::has_providernetworkreference() const {
  return _internal_has_providernetworkreference();
}
inline void VirtualNetworkSpec::clear_providernetworkreference() {
  if (providernetworkreference_ != nullptr) providernetworkreference_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualNetworkSpec::_internal_providernetworkreference() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* p = providernetworkreference_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_ResourceReference_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualNetworkSpec::providernetworkreference() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.providerNetworkReference)
  return _internal_providernetworkreference();
}
inline void VirtualNetworkSpec::unsafe_arena_set_allocated_providernetworkreference(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* providernetworkreference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(providernetworkreference_);
  }
  providernetworkreference_ = providernetworkreference;
  if (providernetworkreference) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.providerNetworkReference)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::release_providernetworkreference() {
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = providernetworkreference_;
  providernetworkreference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::unsafe_arena_release_providernetworkreference() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.providerNetworkReference)
  _has_bits_[0] &= ~0x00000010u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* temp = providernetworkreference_;
  providernetworkreference_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::_internal_mutable_providernetworkreference() {
  _has_bits_[0] |= 0x00000010u;
  if (providernetworkreference_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>(GetArenaForAllocation());
    providernetworkreference_ = p;
  }
  return providernetworkreference_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualNetworkSpec::mutable_providernetworkreference() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _msg = _internal_mutable_providernetworkreference();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.providerNetworkReference)
  return _msg;
}
inline void VirtualNetworkSpec::set_allocated_providernetworkreference(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* providernetworkreference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete providernetworkreference_;
  }
  if (providernetworkreference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference>::GetOwningArena(providernetworkreference);
    if (message_arena != submessage_arena) {
      providernetworkreference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, providernetworkreference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  providernetworkreference_ = providernetworkreference;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.providerNetworkReference)
}

// optional bool isProviderNetwork = 10;
inline bool VirtualNetworkSpec::_internal_has_isprovidernetwork() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VirtualNetworkSpec::has_isprovidernetwork() const {
  return _internal_has_isprovidernetwork();
}
inline void VirtualNetworkSpec::clear_isprovidernetwork() {
  isprovidernetwork_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool VirtualNetworkSpec::_internal_isprovidernetwork() const {
  return isprovidernetwork_;
}
inline bool VirtualNetworkSpec::isprovidernetwork() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.isProviderNetwork)
  return _internal_isprovidernetwork();
}
inline void VirtualNetworkSpec::_internal_set_isprovidernetwork(bool value) {
  _has_bits_[0] |= 0x00000040u;
  isprovidernetwork_ = value;
}
inline void VirtualNetworkSpec::set_isprovidernetwork(bool value) {
  _internal_set_isprovidernetwork(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.isProviderNetwork)
}

// optional bool fabricForwarding = 11;
inline bool VirtualNetworkSpec::_internal_has_fabricforwarding() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool VirtualNetworkSpec::has_fabricforwarding() const {
  return _internal_has_fabricforwarding();
}
inline void VirtualNetworkSpec::clear_fabricforwarding() {
  fabricforwarding_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool VirtualNetworkSpec::_internal_fabricforwarding() const {
  return fabricforwarding_;
}
inline bool VirtualNetworkSpec::fabricforwarding() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.fabricForwarding)
  return _internal_fabricforwarding();
}
inline void VirtualNetworkSpec::_internal_set_fabricforwarding(bool value) {
  _has_bits_[0] |= 0x00000080u;
  fabricforwarding_ = value;
}
inline void VirtualNetworkSpec::set_fabricforwarding(bool value) {
  _internal_set_fabricforwarding(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec.fabricForwarding)
}

// -------------------------------------------------------------------

// VirtualNetworkStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool VirtualNetworkStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool VirtualNetworkStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void VirtualNetworkStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualNetworkStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualNetworkStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus.commonStatus)
  return _internal_commonstatus();
}
inline void VirtualNetworkStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualNetworkStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualNetworkStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualNetworkStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualNetworkStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus.commonStatus)
  return _msg;
}
inline void VirtualNetworkStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus.commonStatus)
}

// optional int64 virtualNetworkNetworkId = 2;
inline bool VirtualNetworkStatus::_internal_has_virtualnetworknetworkid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VirtualNetworkStatus::has_virtualnetworknetworkid() const {
  return _internal_has_virtualnetworknetworkid();
}
inline void VirtualNetworkStatus::clear_virtualnetworknetworkid() {
  virtualnetworknetworkid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VirtualNetworkStatus::_internal_virtualnetworknetworkid() const {
  return virtualnetworknetworkid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VirtualNetworkStatus::virtualnetworknetworkid() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus.virtualNetworkNetworkId)
  return _internal_virtualnetworknetworkid();
}
inline void VirtualNetworkStatus::_internal_set_virtualnetworknetworkid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  virtualnetworknetworkid_ = value;
}
inline void VirtualNetworkStatus::set_virtualnetworknetworkid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_virtualnetworknetworkid(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus.virtualNetworkNetworkId)
}

// -------------------------------------------------------------------

// VirtualNetworkType

// optional string rpf = 1;
inline bool VirtualNetworkType::_internal_has_rpf() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualNetworkType::has_rpf() const {
  return _internal_has_rpf();
}
inline void VirtualNetworkType::clear_rpf() {
  rpf_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VirtualNetworkType::rpf() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.rpf)
  return _internal_rpf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualNetworkType::set_rpf(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 rpf_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.rpf)
}
inline std::string* VirtualNetworkType::mutable_rpf() {
  std::string* _s = _internal_mutable_rpf();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.rpf)
  return _s;
}
inline const std::string& VirtualNetworkType::_internal_rpf() const {
  return rpf_.Get();
}
inline void VirtualNetworkType::_internal_set_rpf(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  rpf_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualNetworkType::_internal_mutable_rpf() {
  _has_bits_[0] |= 0x00000001u;
  return rpf_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualNetworkType::release_rpf() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.rpf)
  if (!_internal_has_rpf()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return rpf_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualNetworkType::set_allocated_rpf(std::string* rpf) {
  if (rpf != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rpf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rpf,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.rpf)
}

// optional string forwardingMode = 2;
inline bool VirtualNetworkType::_internal_has_forwardingmode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VirtualNetworkType::has_forwardingmode() const {
  return _internal_has_forwardingmode();
}
inline void VirtualNetworkType::clear_forwardingmode() {
  forwardingmode_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VirtualNetworkType::forwardingmode() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.forwardingMode)
  return _internal_forwardingmode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualNetworkType::set_forwardingmode(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 forwardingmode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.forwardingMode)
}
inline std::string* VirtualNetworkType::mutable_forwardingmode() {
  std::string* _s = _internal_mutable_forwardingmode();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.forwardingMode)
  return _s;
}
inline const std::string& VirtualNetworkType::_internal_forwardingmode() const {
  return forwardingmode_.Get();
}
inline void VirtualNetworkType::_internal_set_forwardingmode(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  forwardingmode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualNetworkType::_internal_mutable_forwardingmode() {
  _has_bits_[0] |= 0x00000002u;
  return forwardingmode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualNetworkType::release_forwardingmode() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.forwardingMode)
  if (!_internal_has_forwardingmode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return forwardingmode_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualNetworkType::set_allocated_forwardingmode(std::string* forwardingmode) {
  if (forwardingmode != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  forwardingmode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), forwardingmode,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType.forwardingMode)
}

// -------------------------------------------------------------------

// VirtualRouter

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool VirtualRouter::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualRouter::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualRouter::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& VirtualRouter::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.metadata)
  return _internal_metadata();
}
inline void VirtualRouter::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualRouter::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualRouter::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualRouter::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* VirtualRouter::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.metadata)
  return _msg;
}
inline void VirtualRouter::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.metadata)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec spec = 2;
inline bool VirtualRouter::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool VirtualRouter::has_spec() const {
  return _internal_has_spec();
}
inline void VirtualRouter::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec& VirtualRouter::_internal_spec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualRouterSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec& VirtualRouter::spec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.spec)
  return _internal_spec();
}
inline void VirtualRouter::unsafe_arena_set_allocated_spec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.spec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* VirtualRouter::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* VirtualRouter::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* VirtualRouter::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* VirtualRouter::mutable_spec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.spec)
  return _msg;
}
inline void VirtualRouter::set_allocated_spec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.spec)
}

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus status = 3;
inline bool VirtualRouter::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool VirtualRouter::has_status() const {
  return _internal_has_status();
}
inline void VirtualRouter::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus& VirtualRouter::_internal_status() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_VirtualRouterStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus& VirtualRouter::status() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.status)
  return _internal_status();
}
inline void VirtualRouter::unsafe_arena_set_allocated_status(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.status)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* VirtualRouter::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* VirtualRouter::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.status)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* VirtualRouter::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* VirtualRouter::mutable_status() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.status)
  return _msg;
}
inline void VirtualRouter::set_allocated_status(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouterStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter.status)
}

// -------------------------------------------------------------------

// VirtualRouterList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool VirtualRouterList::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool VirtualRouterList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualRouterList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& VirtualRouterList::metadata() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.metadata)
  return _internal_metadata();
}
inline void VirtualRouterList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualRouterList::release_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualRouterList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualRouterList::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* VirtualRouterList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.metadata)
  return _msg;
}
inline void VirtualRouterList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.metadata)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter items = 2;
inline int VirtualRouterList::_internal_items_size() const {
  return items_.size();
}
inline int VirtualRouterList::items_size() const {
  return _internal_items_size();
}
inline void VirtualRouterList::clear_items() {
  items_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter* VirtualRouterList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter >*
VirtualRouterList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.items)
  return &items_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter& VirtualRouterList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter& VirtualRouterList::items(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.items)
  return _internal_items(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter* VirtualRouterList::_internal_add_items() {
  return items_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter* VirtualRouterList::add_items() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::VirtualRouter >&
VirtualRouterList::items() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterList.items)
  return items_;
}

// -------------------------------------------------------------------

// VirtualRouterSpec

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;
inline bool VirtualRouterSpec::_internal_has_commonspec() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || commonspec_ != nullptr);
  return value;
}
inline bool VirtualRouterSpec::has_commonspec() const {
  return _internal_has_commonspec();
}
inline void VirtualRouterSpec::clear_commonspec() {
  if (commonspec_ != nullptr) commonspec_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualRouterSpec::_internal_commonspec() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* p = commonspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonSpec_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec& VirtualRouterSpec::commonspec() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.commonSpec)
  return _internal_commonspec();
}
inline void VirtualRouterSpec::unsafe_arena_set_allocated_commonspec(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonspec_);
  }
  commonspec_ = commonspec;
  if (commonspec) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.commonSpec)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualRouterSpec::release_commonspec() {
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualRouterSpec::unsafe_arena_release_commonspec() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.commonSpec)
  _has_bits_[0] &= ~0x00000004u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* temp = commonspec_;
  commonspec_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualRouterSpec::_internal_mutable_commonspec() {
  _has_bits_[0] |= 0x00000004u;
  if (commonspec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>(GetArenaForAllocation());
    commonspec_ = p;
  }
  return commonspec_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* VirtualRouterSpec::mutable_commonspec() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* _msg = _internal_mutable_commonspec();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.commonSpec)
  return _msg;
}
inline void VirtualRouterSpec::set_allocated_commonspec(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec* commonspec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonspec_;
  }
  if (commonspec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonSpec>::GetOwningArena(commonspec);
    if (message_arena != submessage_arena) {
      commonspec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonspec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  commonspec_ = commonspec;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.commonSpec)
}

// optional .k8s.io.api.core.v1.ObjectReference parent = 2;
inline bool VirtualRouterSpec::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || parent_ != nullptr);
  return value;
}
inline bool VirtualRouterSpec::has_parent() const {
  return _internal_has_parent();
}
inline const ::k8s::io::api::core::v1::ObjectReference& VirtualRouterSpec::_internal_parent() const {
  const ::k8s::io::api::core::v1::ObjectReference* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::api::core::v1::ObjectReference&>(
      ::k8s::io::api::core::v1::_ObjectReference_default_instance_);
}
inline const ::k8s::io::api::core::v1::ObjectReference& VirtualRouterSpec::parent() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.parent)
  return _internal_parent();
}
inline void VirtualRouterSpec::unsafe_arena_set_allocated_parent(
    ::k8s::io::api::core::v1::ObjectReference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.parent)
}
inline ::k8s::io::api::core::v1::ObjectReference* VirtualRouterSpec::release_parent() {
  _has_bits_[0] &= ~0x00000008u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* VirtualRouterSpec::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.parent)
  _has_bits_[0] &= ~0x00000008u;
  ::k8s::io::api::core::v1::ObjectReference* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::k8s::io::api::core::v1::ObjectReference* VirtualRouterSpec::_internal_mutable_parent() {
  _has_bits_[0] |= 0x00000008u;
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::api::core::v1::ObjectReference>(GetArenaForAllocation());
    parent_ = p;
  }
  return parent_;
}
inline ::k8s::io::api::core::v1::ObjectReference* VirtualRouterSpec::mutable_parent() {
  ::k8s::io::api::core::v1::ObjectReference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.parent)
  return _msg;
}
inline void VirtualRouterSpec::set_allocated_parent(::k8s::io::api::core::v1::ObjectReference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent));
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.parent)
}

// optional bool virtualRouterDpdkEnabled = 3;
inline bool VirtualRouterSpec::_internal_has_virtualrouterdpdkenabled() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VirtualRouterSpec::has_virtualrouterdpdkenabled() const {
  return _internal_has_virtualrouterdpdkenabled();
}
inline void VirtualRouterSpec::clear_virtualrouterdpdkenabled() {
  virtualrouterdpdkenabled_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool VirtualRouterSpec::_internal_virtualrouterdpdkenabled() const {
  return virtualrouterdpdkenabled_;
}
inline bool VirtualRouterSpec::virtualrouterdpdkenabled() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterDpdkEnabled)
  return _internal_virtualrouterdpdkenabled();
}
inline void VirtualRouterSpec::_internal_set_virtualrouterdpdkenabled(bool value) {
  _has_bits_[0] |= 0x00000010u;
  virtualrouterdpdkenabled_ = value;
}
inline void VirtualRouterSpec::set_virtualrouterdpdkenabled(bool value) {
  _internal_set_virtualrouterdpdkenabled(value);
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterDpdkEnabled)
}

// optional string virtualRouterIPAddress = 4;
inline bool VirtualRouterSpec::_internal_has_virtualrouteripaddress() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualRouterSpec::has_virtualrouteripaddress() const {
  return _internal_has_virtualrouteripaddress();
}
inline void VirtualRouterSpec::clear_virtualrouteripaddress() {
  virtualrouteripaddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VirtualRouterSpec::virtualrouteripaddress() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterIPAddress)
  return _internal_virtualrouteripaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualRouterSpec::set_virtualrouteripaddress(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 virtualrouteripaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterIPAddress)
}
inline std::string* VirtualRouterSpec::mutable_virtualrouteripaddress() {
  std::string* _s = _internal_mutable_virtualrouteripaddress();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterIPAddress)
  return _s;
}
inline const std::string& VirtualRouterSpec::_internal_virtualrouteripaddress() const {
  return virtualrouteripaddress_.Get();
}
inline void VirtualRouterSpec::_internal_set_virtualrouteripaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  virtualrouteripaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualRouterSpec::_internal_mutable_virtualrouteripaddress() {
  _has_bits_[0] |= 0x00000001u;
  return virtualrouteripaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualRouterSpec::release_virtualrouteripaddress() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterIPAddress)
  if (!_internal_has_virtualrouteripaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return virtualrouteripaddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualRouterSpec::set_allocated_virtualrouteripaddress(std::string* virtualrouteripaddress) {
  if (virtualrouteripaddress != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  virtualrouteripaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), virtualrouteripaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterIPAddress)
}

// optional string virtualRouterType = 5;
inline bool VirtualRouterSpec::_internal_has_virtualroutertype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VirtualRouterSpec::has_virtualroutertype() const {
  return _internal_has_virtualroutertype();
}
inline void VirtualRouterSpec::clear_virtualroutertype() {
  virtualroutertype_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VirtualRouterSpec::virtualroutertype() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterType)
  return _internal_virtualroutertype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualRouterSpec::set_virtualroutertype(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 virtualroutertype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterType)
}
inline std::string* VirtualRouterSpec::mutable_virtualroutertype() {
  std::string* _s = _internal_mutable_virtualroutertype();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterType)
  return _s;
}
inline const std::string& VirtualRouterSpec::_internal_virtualroutertype() const {
  return virtualroutertype_.Get();
}
inline void VirtualRouterSpec::_internal_set_virtualroutertype(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  virtualroutertype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualRouterSpec::_internal_mutable_virtualroutertype() {
  _has_bits_[0] |= 0x00000002u;
  return virtualroutertype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualRouterSpec::release_virtualroutertype() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterType)
  if (!_internal_has_virtualroutertype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return virtualroutertype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualRouterSpec::set_allocated_virtualroutertype(std::string* virtualroutertype) {
  if (virtualroutertype != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  virtualroutertype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), virtualroutertype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualRouterType)
}

// repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineReferences = 6;
inline int VirtualRouterSpec::_internal_virtualmachinereferences_size() const {
  return virtualmachinereferences_.size();
}
inline int VirtualRouterSpec::virtualmachinereferences_size() const {
  return _internal_virtualmachinereferences_size();
}
inline void VirtualRouterSpec::clear_virtualmachinereferences() {
  virtualmachinereferences_.Clear();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualRouterSpec::mutable_virtualmachinereferences(int index) {
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualMachineReferences)
  return virtualmachinereferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >*
VirtualRouterSpec::mutable_virtualmachinereferences() {
  // @@protoc_insertion_point(field_mutable_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualMachineReferences)
  return &virtualmachinereferences_;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualRouterSpec::_internal_virtualmachinereferences(int index) const {
  return virtualmachinereferences_.Get(index);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference& VirtualRouterSpec::virtualmachinereferences(int index) const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualMachineReferences)
  return _internal_virtualmachinereferences(index);
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualRouterSpec::_internal_add_virtualmachinereferences() {
  return virtualmachinereferences_.Add();
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* VirtualRouterSpec::add_virtualmachinereferences() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference* _add = _internal_add_virtualmachinereferences();
  // @@protoc_insertion_point(field_add:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualMachineReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::ResourceReference >&
VirtualRouterSpec::virtualmachinereferences() const {
  // @@protoc_insertion_point(field_list:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec.virtualMachineReferences)
  return virtualmachinereferences_;
}

// -------------------------------------------------------------------

// VirtualRouterStatus

// optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;
inline bool VirtualRouterStatus::_internal_has_commonstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || commonstatus_ != nullptr);
  return value;
}
inline bool VirtualRouterStatus::has_commonstatus() const {
  return _internal_has_commonstatus();
}
inline void VirtualRouterStatus::clear_commonstatus() {
  if (commonstatus_ != nullptr) commonstatus_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualRouterStatus::_internal_commonstatus() const {
  const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* p = commonstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus&>(
      ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::_CommonStatus_default_instance_);
}
inline const ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus& VirtualRouterStatus::commonstatus() const {
  // @@protoc_insertion_point(field_get:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus.commonStatus)
  return _internal_commonstatus();
}
inline void VirtualRouterStatus::unsafe_arena_set_allocated_commonstatus(
    ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commonstatus_);
  }
  commonstatus_ = commonstatus;
  if (commonstatus) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus.commonStatus)
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualRouterStatus::release_commonstatus() {
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualRouterStatus::unsafe_arena_release_commonstatus() {
  // @@protoc_insertion_point(field_release:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus.commonStatus)
  _has_bits_[0] &= ~0x00000001u;
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* temp = commonstatus_;
  commonstatus_ = nullptr;
  return temp;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualRouterStatus::_internal_mutable_commonstatus() {
  _has_bits_[0] |= 0x00000001u;
  if (commonstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>(GetArenaForAllocation());
    commonstatus_ = p;
  }
  return commonstatus_;
}
inline ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* VirtualRouterStatus::mutable_commonstatus() {
  ::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* _msg = _internal_mutable_commonstatus();
  // @@protoc_insertion_point(field_mutable:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus.commonStatus)
  return _msg;
}
inline void VirtualRouterStatus::set_allocated_commonstatus(::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus* commonstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commonstatus_;
  }
  if (commonstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ssd_git::juniper::net::contrail::cn2::contrail::pkg::apis::core::v1alpha1::CommonStatus>::GetOwningArena(commonstatus);
    if (message_arena != submessage_arena) {
      commonstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commonstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commonstatus_ = commonstatus;
  // @@protoc_insertion_point(field_set_allocated:ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus.commonStatus)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace core
}  // namespace apis
}  // namespace pkg
}  // namespace contrail
}  // namespace cn2
}  // namespace contrail
}  // namespace net
}  // namespace juniper
}  // namespace ssd_git

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ssd_2dgit_2ejuniper_2enet_2fcontrail_2fcn2_2fcontrail_2fpkg_2fapis_2fcore_2fv1alpha1_2fgenerated_2eproto
